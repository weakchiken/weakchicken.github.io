<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[request]]></title>
    <url>%2F2019%2F07%2F06%2Frequest%2F</url>
    <content type="text"><![CDATA[前提摘要想写下这一篇的原因还是起源于在网上下载图片的时候一张一张下载的太慢而且麻烦，所以就想着写一个东西， 能够快速批量下载。于是，就有了爬虫的想法，当然，以我现有水平只能够用request去爬取，爬虫的相关内容会在以后慢慢更新的一句话，我用爬虫就是用来下载资源的~后面会更新相关内容来完善。。。。注意:以下内容都是以python3为基础实现简单介绍网络爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。 服务器的交互方式http中与服务器定义的几种基本交互方式，get、post、delete、put、head和options。get请求常用于查询获取资源信息，常见表现形式url传递参数数据， 以？开始&amp;分隔参数值。post请求向服务器提交数据。put请求向服务器端发送信息修改数据。delete请求向服务器发送信息删除数据。基础先要了解request是一个模块，在python中就是一个库，用来抓取网上资源的 下载requests模块 若是安装过python3，则命令端输入`pip install requests`即可 用法先导入`requests`模块(这个模块名称为requests)只不过平时都说是request了，这一点不能弄错 import requests 与请求网址交互 1234requests.get(&quot;url&quot;)requests.post(&quot;url&quot;)requests.put(&quot;url&quot;)request.delete(&quot;url&quot;) 说一下常用的GET请求： 两种方法： 1.直接传: 例如：requests.get(&quot;http://www.baidu.com&quot;) 2.间接传: 例如：url = &quot;http://www.baidu.com&quot; requests.get(url=url) 间接传的好处是可以添加其他参数 常用属性和方法1234567url #打印返回地址text #以文本方式返回html源码content #以字节流返回html源码cookies #返回cookies信息status_code #打印状态码headers #返回html头信息encoding #处理字符集get请求回复对象所包含的属性：12345678resp = requests.get()resp.text 获取网站源码（字符串类型）resp.encoding 访问或定制编码方式,如一般所得网页源码出现乱码的情况下可以设置：resp.encoding=&apos;gb2312&apos;resp.url 获取请求的urlresp.content 获取网站源码，但响应的是字节类型resp.status_code 响应的状态码resp.headers 响应的头信息resp.json() 获取json数据]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优美文章]]></title>
    <url>%2F2019%2F07%2F04%2F%E4%BC%98%E7%BE%8E%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[摘要每一个人都不是超人，都不可能会有无穷的精力，但还是需要我们努力的奔跑！基于此，于考试的紧张期间写下一些感悟文章来反思自己，生活不需要一致的工作和学习，偶尔也需要一些放松。活在当下，立足当下，去努力，去超越。这个世界很大，你不打算去看看嘛？最后，奉上座右铭：我并不想着去超越谁，只是想比昨天的自己强一点点······以下内容从网上摘抄而来，并非自己写的。你的人品，决定你的前途文／李思圆1 我在老家有两个朋友老王和老张。老王5年前跟老张借了5万块，说是做装修生意急用，并承诺两年内还清。老张二话没说，把钱借给了老王。出于信任，也没让他写借条。但两年后，老王只字不提还钱的事，倒是全款买了一辆新车。 老张问他要钱，老王推三阻四。一会儿说有事不在家，一会儿电话又打不通，甚至故意玩消失。最终两家人闹掰了，老张没要回钱，吃了一个哑巴亏。村里人都知道这件事，虽然大家嘴上没说，但心里都觉得老王不厚道。又过了两年，村里上百户人搬迁，都需要装修新房。老王心想，乡亲们一定会找他。可奇怪的是，即便他的报价低了很多，许多村民也不买账。原来，他的坏口碑一传十，十传百，没过几年，装修生意彻底做不下去了。有时候，一个人或许可以靠不讲信用获取一些暂时的利益，但那绝不是正道。想要站得稳，走得远，笑到最后，还得靠人品做支撑。2前些日子我朋友的公司搞竞聘，有个工作能力非常强的男同事落选了。后来男同事得知，他是被总经理撤下来了。总经理对他说：小伙子，既要学会做事，更要学会做人。后来这个男同事负气辞职，总经理才道出真相。原来有次这个男同事坐电梯时，一个外卖小哥背着一个很重的外卖包，风尘仆仆地想进来。电梯里是有空间的，只要这个男同事往后退几步就行，但他就是故意不让。一边快速按关门键，一边说，几步路而已，也要坐电梯。这件事被总经理知道了，就把他拉入了黑名单。一个学不会尊重别人的人，心性就出了问题。这样的人，谁敢重用？也许一个人的前途，跟自身的智商、实力和运气等有关，可拼到最后，人品才是最终的把关口。3曾听一位读者说起，他曾供职的私企因经营不善大规模裁员。当时许多被裁的员工闹情绪，有人故意销毁重要文件，有人把客户的联络方式偷偷拷贝走，还有人四处造谣说老板的坏话。这位读者丢了工作也不开心。但在最后一个月，他对工作依然没有敷衍了事。在交接工作时，他还把需要特别注意的事项一一罗列出来。老板被他的所作所为感动，通过熟人把他介绍到另外一家公司工作。这位读者因为踏实肯干，很快就走上了管理岗位，薪水待遇也提高很多。人品就是一个人的根基。为人善良、懂得体谅、不去做小人之事，这样的人，会格外得到好运的眷顾、贵人的扶持和机会的偏爱。4有人说，能力和学历才是好工作的敲门砖，情商和智商才是好职位的守护神。但其实无论在哪行哪业，都不缺高手。前途一片光明的人，一定不是颠倒黑白、动歪脑筋的人，而是那些在同等条件下，人品过关的人。也许你反应快、人脉广、办法多，但这些也只是你的加分项。为人诚实，待人和善，有底线有原则，不做有损他人的事，这些却是你的必选项。一个人能力差一点，灵性少一点，实力欠一点，都可以花时间和精力慢慢去补足，但人品差却是致命的缺陷。好人品，是做人的良心，是为人的修养。没有了好人品，其他都免谈。一个人走得远不远、久不久、稳不稳，人品才是最关键的因素。小结学会做人，学会做事，掌握好人生的必选项，添加加分项，我们会更好的适应这个世界]]></content>
      <categories>
        <category>总结</category>
        <category>想法</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map与vector的用法]]></title>
    <url>%2F2019%2F07%2F02%2Fmap%E4%B8%8Evector%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vector向量 相当于一个数组在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。map映照容器的元素数据是一个键值和一个映照数据组成的，键值与映照数据之间具有一一映照的关系。map映照容器的数据结构是采用红黑树来实现的，插入键值的元素不允许重复，比较函数只对元素的键值进行比较，元素的各项数据可通过键值检索出来。使用map容器需要头文件包含语句“#include”，map文件也包含了对multimap多重映照容器的定义。mapMap是c++的一个标准容器，它提供了很好一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果，总结了一些map基本简单实用的操作！map最基本的构造函数；123map&lt;string , int &gt;mapstring; map&lt;int ,string &gt;mapint;map&lt;sring, char&gt;mapstring; map&lt; char ,string&gt;mapchar;map&lt;char ,int&gt;mapchar; map&lt;int ,char &gt;mapint；map添加数据；1234map&lt;int ,string&gt; maplive; 1.maplive.insert(pair&lt;int,string&gt;(102,&quot;aclive&quot;));2.maplive.insert(map&lt;int,string&gt;::value_type(321,&quot;hai&quot;));3, maplive[112]=&quot;April&quot;;//map中最简单最常用的插入添加！map中元素的查找：123456find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。 map&lt;int ,string &gt;::iterator l_it;; l_it=maplive.find(112);if(l_it==maplive.end()) cout&lt;&lt;&quot;we do not find 112&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;wo find 112&quot;&lt;&lt;endl;map中元素的删除：123456如果删除112；map&lt;int ,string &gt;::iterator l_it;;l_it=maplive.find(112);if(l_it==maplive.end()) cout&lt;&lt;&quot;we do not find 112&quot;&lt;&lt;endl;else maplive.erase(l_it); //delete 112;map中 swap的用法：12345678910111213141516171819202122232425262728293031323334353637 Map中的swap不是一个容器中的元素交换，而是两个容器交换； For example： #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) &#123; map &lt;int, int&gt; m1, m2, m3; map &lt;int, int&gt;::iterator m1_Iter; m1.insert ( pair &lt;int, int&gt; ( 1, 10 ) ); m1.insert ( pair &lt;int, int&gt; ( 2, 20 ) ); m1.insert ( pair &lt;int, int&gt; ( 3, 30 ) ); m2.insert ( pair &lt;int, int&gt; ( 10, 100 ) ); m2.insert ( pair &lt;int, int&gt; ( 20, 200 ) ); m3.insert ( pair &lt;int, int&gt; ( 30, 300 ) ); cout &lt;&lt; &quot;The original map m1 is:&quot;; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter-&gt;second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl; // This is the member function version of swap //m2 is said to be the argument map; m1 the target map m1.swap( m2 ); cout &lt;&lt; &quot;After swapping with m2, map m1 is:&quot;; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;After swapping with m2, map m2 is:&quot;; for ( m1_Iter = m2.begin( ); m1_Iter != m2.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl; // This is the specialized template version of swap swap( m1, m3 ); cout &lt;&lt; &quot;After swapping with m3, map m1 is:&quot;; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl;&#125;map的sort问题：123456789101112131415161718192021222324252627 Map中的元素是自动按key升序排序,所以不能对map用sort函数： For example： #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) &#123; map &lt;int, int&gt; m1; map &lt;int, int&gt;::iterator m1_Iter; m1.insert ( pair &lt;int, int&gt; ( 1, 20 ) ); m1.insert ( pair &lt;int, int&gt; ( 4, 40 ) ); m1.insert ( pair &lt;int, int&gt; ( 3, 60 ) ); m1.insert ( pair &lt;int, int&gt; ( 2, 50 ) ); m1.insert ( pair &lt;int, int&gt; ( 6, 40 ) ); m1.insert ( pair &lt;int, int&gt; ( 7, 30 ) ); cout &lt;&lt; &quot;The original map m1 is:&quot;&lt;&lt;endl; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; m1_Iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl; &#125; The original map m1 is: 1 20 2 50 3 60 4 40 6 40 7 30map的基本操作函数：1234567891011121314151617181920C++ Maps是一种关联式容器，包含“关键字/值”对begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数总结：优点：(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()(2) 随机访问方便，即支持[ ]操作符和vector.at()(3) 节省空间。缺点：(1) 在内部进行插入删除操作效率低。(2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。(3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放vector标准库Vector类型使用需要的头文件：#includeVector：Vector 是一个类模板。不是一种数据类型。 Vector是一种数据类型。定义和初始化Vectorv1; //默认构造函数v1为空Vectorv2(v1);//v2是v1的一个副本Vectorv3(n,i);//v3包含n个值为i的元素Vectorv4(n); //v4含有n个值为0的元素值初始化1&gt; 如果没有指定元素初始化式，标准库自行提供一个初始化值进行值初始化。2&gt; 如果保存的式含有构造函数的类类型的元素，标准库使用该类型的构造函数初始化。3&gt; 如果保存的式没有构造函数的类类型的元素，标准库产生一个带初始值的对象，使用这个对象进行值初始化。Vector对象最重要的几种操作v.push_back(t) 在数组的最后添加一个值为t的数据v.size() 当前使用数据的大小v.empty() 判断vector是否为空v[n] 返回v中位置为n的元素v1=v2 把v1的元素替换为v2元素的副本v1==v2 判断v1与v2是否相等！=、&lt;、&lt;=、&gt;、&gt;= 保持这些操作符惯有含义vector容器类型vector容器是一个模板类，可以存放任何类型的对象（但必须是同一类对象）。vector对象可以在运行时高效地添加元素，并且vector中元素是连续存储的。vector的构造函数原型：templateexplicit vector(); // 默认构造函数，vector对象为空explicit vector(size_type n, const T&amp; v = T()); // 创建有n个元素的vector对象vector(const vector&amp; x);vector(const_iterator first, const_iterator last);注：vector容器内存放的所有对象都是经过初始化的。如果没有指定存储对象的初始值，那么对于内置类型将用0初始化，对于类类型将调用其默认构造函数进行初始化（如果有其它构造函数而没有默认构造函数，那么此时必须提供元素初始值才能放入容器中）。举例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;string&gt; v1; // 创建空容器，其对象类型为string类vector&lt;string&gt; v2(10); // 创建有10个具有初始值（即空串）的string类对象的容器vector&lt;string&gt; v3(5, &quot;hello&quot;); // 创建有5个值为“hello”的string类对象的容器vector&lt;string&gt; v4(v3.begin(), v3.end()); // v4是与v3相同的容器（完全复制）vector的操作（下面的函数都是成员函数）bool empty() const; // 如果为容器为空，返回true；否则返回falsesize_type max_size() const; // 返回容器能容纳的最大元素个数size_type size() const; // 返回容器中元素个数size_type capacity() const; // 容器能够存储的元素个数，有：capacity() &gt;= size()void reserve(size_type n); // 确保capacity() &gt;= nvoid resize(size_type n, T x = T()); // 确保返回后，有：size() == n；如果之前size()&lt;n，那么用元素x的值补全。reference front(); // 返回容器中第一个元素的引用（容器必须非空）const_reference front() const;reference back(); // 返回容器中最后一个元素的引用（容器必须非空）const_reference back() const;reference operator[](size_type pos); // 返回下标为pos的元素的引用（下标从0开始；如果下标不正确，则属于未定义行为。const_reference operator[](size_type pos) const;reference at(size_type pos); // 返回下标为pos的元素的引用；如果下标不正确，则抛出异常out_of_rangeconst_reference at(size_type pos) const;void push_back(const T&amp; x); // 向容器末尾添加一个元素void pop_back(); // 弹出容器中最后一个元素（容器必须非空）// 注：下面的插入和删除操作将发生元素的移动（为了保持连续存储的性质），所以之前的迭代器可能失效iterator insert(iterator it, const T&amp; x = T()); // 在插入点元素之前插入元素（或者说在插入点插入元素）void insert(iterator it, size_type n, const T&amp; x); // 注意迭代器可能不再有效（可能重新分配空间）void insert(iterator it, const_iterator first, const_iterator last);iterator erase(iterator it); // 删除指定元素，并返回删除元素后一个元素的位置（如果无元素，返回end()）iterator erase(iterator first, iterator last); // 注意：删除元素后，删除点之后的元素对应的迭代器不再有效。void clear() const; // 清空容器，相当于调用erase( begin(), end())void assign(size_type n, const T&amp; x = T()); // 赋值，用指定元素序列替换容器内所有元素void assign(const_iterator first, const_iterator last);const_iterator begin() const; // 迭代序列iterator begin();const_iterator end() const;iterator end();const_reverse_iterator rbegin() const;reverse_iterator rbegin();const_reverse_iterator rend() const;reverse_iterator rend();vector对象的比较（非成员函数）针对vector对象的比较有六个比较运算符：operator==、operator!=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=。其中，对于operator==和operator!=，如果vector对象拥有相同的元素个数，并且对应位置的元素全部相等，则两个vector对象相等；否则不等。对于operator&lt;、operator&lt;=、operator&gt;、operator&gt;=，采用字典排序策略比较。注：其实只需要实现operator==和operator!=就可以了，其它可以根据这两个实现。因为，operator!= (lhs, rhs) 就是 !(lhs == rhs)，operator&lt;=(lhs, rhs) 就是 !(rhs &lt; lhs)，operator&gt;(lhs, rhs) 就是 (rhs &lt; lhs)，operator&gt;=（lhs, rhs) 就是 !(lhs, rhs)。vector类的迭代器vector类的迭代器除了支持通用的前缀自增运算符外，还支持算术运算：it + n、it - n、it2 - it1。注意it2 - it1返回值为difference_type（signed类型）。注意，任何改变容器大小的操作都可能造成以前的迭代器失效。应用示例1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; v(5, &quot;hello&quot;); vector&lt;string&gt; v2(v.begin(), v.end()); assert(v == v2); cout&lt;&lt;&quot;&gt; Before operation&quot;&lt;&lt;endl; for(vector&lt;string&gt;::const_iterator it = v.begin(); it &lt; v.end(); ++it) cout&lt;&lt;*it&lt;&lt;endl; v.insert(v.begin() + 3, 4, &quot;hello, world&quot;); cout&lt;&lt;&quot;&gt; After insert&quot;&lt;&lt;endl; for(vector&lt;string&gt;::size_type i = 0; i &lt; v.size(); ++i) cout&lt;&lt;v[i]&lt;&lt;endl; vector&lt;string&gt;::iterator it = v.erase(v.begin() + 3, v.begin() + 6); assert(*it == &quot;hello, world&quot;); cout&lt;&lt;&quot;&gt; After erase&quot;&lt;&lt;endl; for(vector&lt;string&gt;::size_type i = 0; i != v.size(); ++i) cout&lt;&lt;v[i]&lt;&lt;endl; assert(v.begin() + v.size() == v.end()); assert(v.end() - v.size() == v.begin()); assert(v.begin() - v.end() == -vector&lt;string&gt;::difference_type(v.size()));return 0;&#125;程序说明：上面程序中用了三个循环输出容器中的元素，每个循环的遍历方式是不一样的。特别需要说明的是，第二个循环在条件判断中使用了size() 函数，而不是在循环之前先保存在变量中再使用。之所以这样做，有两个原因：其一，如果将来在修改程序时，在循环中修改了容器元素个数，这个循环仍然能很好地工作，而如果先保存size()函数值就不正确了；其二，由于这些小函数（其实现只需要一条返回语句）基本上都被声明为inline，所以不需要考虑效率问题。c++编程语言中有一种叫做Vector的应用方法，它的作用在实际编程中是非常重要的。下面简单介绍一下C++ Vector的相关应用技巧及基本内容。基本用法(1)vector&lt; 类型 &gt; 标识符 ;(2)vector&lt; 类型 &gt; 标识符(最大容量) ；(3)vector&lt; 类型 &gt; 标识符（最大容量，初始所有值）；(4) int i[4] = {12,3,4,5};vector&lt; 类型 &gt; vi(i , i+2); //得到i索引值为3以后的值 ；(5)vector&lt; vector&gt; //vi 定义2维的容器；记得一定要有空格，不然会报错vector&lt; int &gt; line// 在使用的时候一定要首先将vi个行进行初始化;for(int i = 0 ; i &lt; 10 ; i ++){vector.push_back(line);}/// 个人认为使用vector定义二维数组很好，因为是长度可以不预先确定。(6)C++ Vector排序123456vector&lt; int &gt; vi ;vi.push_back(1);vi.push_back(3);vi.push_back(0);sort(vi.begin() , vi.end()); /// /小到大reverse(vi.begin(),vi.end()) /// 从大道小(7)顺序访问1234567891011121314vector &lt; int &gt; vi ;for( int i = 0 ; i &lt; 10 ; i ++)&#123; vector.push_back(i);&#125;for(int i = 0 ; i &lt; 10 ; i ++) /// 第一种调用方法&#123; cout &lt;&lt;vector[i] &lt;&lt;&quot; &quot; ;&#125;for(vector&lt;int&gt;::iterator it = vi.begin() ; it !=vi.end() ; it++; ///第二种调用方法&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;&#125;(8)寻找1234567vector &lt; int &gt; vi ;for( int i = 0 ; i &lt; 10 ; i ++)&#123; vector.push_back(i);&#125; vector &lt; int &gt;::interator it = find(vi.begin() , vi.end,3) ; cout &lt;&lt; *it &lt;&lt; endl ; ///返回容器内找到值的位置。(9)使用数组对C++ Vector进行初始化12345678int i[10] =&#123;1,2,3,4,5,6,7,78,8&#125; ;///第一种vector&lt;int&gt; vi(i+1,i+3); ///从第2个元素到第三个元素for(vector &lt;int&gt;::interator it = vi.begin() ; it != vi.end() ; it++;&#123; cout &lt;&lt; *it &lt;&lt;&quot; &quot; ;&#125;(10) 结构体类型1234567891011121314151617struct temp&#123; public : string str ; public : int id ;&#125;tmpint main()&#123; vector &lt;temp&gt; t ; temp w1 ; w1.str = &quot;Hellowor&quot; ; w1.id = 1 ; t.push_back(t1); cout &lt;&lt; w1.str &lt;&lt; &quot;,&quot; &lt;&lt;w1.id &lt;&lt;endl ; return 0 ;&#125;比较]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图]]></title>
    <url>%2F2019%2F06%2F29%2F%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[概念介绍：二分图二分图又称作二部图，又称作偶图，是图论中的一种特殊模型顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(iin A,j in B)，则称图G为一个二分图。简单来说，就是顶点集 V 可分割为两个互不相交的子集，且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。当图中的顶点分为两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连时，此时是一特殊的二分图，称为完全二分图。充要条件是：图 G 中至少存在两个点，且图中所有回路的长度均为偶数。匹配在给定一个二分图 G，在 G 的一个子图 M 中，若 M 的边集中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。简单来说，匹配就是一个二分图中边的集合，其中任意两条边都没有公共顶点。如图，红边就是一个匹配最大匹配给定二分图 G 中的所有匹配，所含匹配边数最多的匹配，称为这个图的最大匹配，选择最大匹配的问题即为图的最大匹配问题如图，红边就是一个最大匹配完全匹配一个匹配中，图中每个顶点都与图中某条边相关联，则称此匹配为完全匹配，即一个图的某个匹配中，所有的顶点都是匹配点，就是一个完全匹配。显然，由于完全匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突，因此完全匹配一定是最大匹配。但要注意的是，并非每个图都存在完全匹配。简单来说，对于一个二分图，左点集中的每一个点都与右点集的一个点匹配，或者右点集中的每一个点都与左点集的一个点匹配。完美匹配对于一个二分图，左点集与右点集的点数相同，若存在一个匹配，包含左点集、右点集的所有顶点，则称为完美匹配。简单来说，对于一个二分图，左点集中的每一个点都与右点集的一个点匹配，并且右点集中的每一个点都与左点集的一个点匹配。如下图，红线所连接的匹配，不仅是一个完全匹配，还是一个完美匹配最大匹配问题举例来说，如下图所示，若存在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢？这就是完全匹配问题。而最多有多少互相喜欢的男孩/女孩可以配对？这就是最大匹配问题。最优匹配带权二分图的权值最大的完全匹配称为最佳匹配，要注意的是，二分图的最优匹配不一定是二分图的最大权匹配。实质上最优匹配问题就是求边权和最大的最大匹配问题。求解技巧：可以添加一些权值为 0 的边，使得最优匹配和最大权匹配统一起来。交替路从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路增广路从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。其实，如果交替路以非匹配点结束的，那么这条交替路就是一条增广路我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的1.匈牙利算法基本思想：通过寻找增广路，把增广路中的匹配边和非匹配边的身份交换，这样就会多出一条匹配边，直到找不到增广路为止。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define MAXN 9999using namespace std;int nx,ny;//nx表示二分图左边顶点的个数，ny表示二分图右边顶点的个数int m;//m代表边的条数int cx[MAXN],cy[MAXN];//如果有cx[i]=j，则必有cy[j]=i，说明i点和j点能够匹配int x,y;//x点到y点有边int e[MAXN][MAXN];//邻接矩阵int visited[MAXN];//标记数组，标记的永远是二分图右边的顶点int ret;//最后结果int point(int u)//这个函数的作用是寻找增广路和更新cx，xy数组，如果找到了增广路，函数返回1，找不到，函数返回0。&#123; for(int v=1;v&lt;=ny;v++)//依次遍历右边的所有顶点 &#123; if(e[u][v]&amp;&amp;!visited[v])//条件一：左边的u顶点和右边的v顶点有连通边，条件二：右边的v顶点在没有被访问过，这两个条件必须同时满足 &#123; visited[v]=1;//将v顶点标记为访问过的 if(cy[v]==-1||point(cy[v]))//条件一：右边的v顶点没有左边对应的匹配的点，条件二：以v顶点在左边的匹配点为起点能够找到一条增广路（如果能够到达条件二，说明v顶点在左边一定有对应的匹配点）。 &#123; cx[u]=v;//更新cx，cy数组 cy[v]=u; return 1; &#125; &#125; &#125; return 0;//如果程序到达了这里，说明对右边所有的顶点都访问完了，没有满足条件的。&#125;int main()&#123; while (cin&gt;&gt;m&gt;&gt;nx&gt;&gt;ny) &#123; memset(cx,-1,sizeof(cx));//初始化cx，cy数组的值为-1 memset(cy,-1,sizeof(cy)); memset(e,0,sizeof(e));//初始化邻接矩阵 ret=0; while (m--)//输入边的信息和更新邻接矩阵 &#123; cin&gt;&gt;x&gt;&gt;y; e[x][y]=1; &#125; for(int i=1;i&lt;=nx;i++)//对二分图左边的所有顶点进行遍历 &#123; if(cx[i]==-1)//如果左边的i顶点还没有匹配的点，就对i顶点进行匹配 &#123; memset(visited,0,sizeof(visited));//每次进行point时，都要对visited数组进行初始化 ret+=point(i);//point函数传入的参数永远是二分图左边的点 &#125; &#125; cout&lt;&lt;ret&lt;&lt;endl; &#125;&#125;2.KM算法KM算法写的比较好的文章https://www.cnblogs.com/wenruo/p/5264235.htmlhttps://www.cnblogs.com/logosG/p/logos.html?tdsourcetag=s_pcqq_aiomsg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;list&gt;#include&lt;set&gt;#define INT 9654234#define mod 1000000007typedef long long ll;using namespace std;const int MAXN = 305;int N;int ex_gir[MAXN];//每个妹子的期望值int ex_boy[MAXN];//每个男生的期望值bool vis_gir[MAXN];//记录每一轮匹配过的女生bool vis_boy[MAXN];//记录每一轮匹配过的男生 每进行新的一轮，都要重新初始化这两个数组int match[MAXN];//match[i]代表和i男生匹配的女生的编号int slack[MAXN];//slack[i]代表i男生如果要获得女生的芳心，至少需要增加的期待值int love[MAXN][MAXN];//记录每个妹子和男生的好感度bool dfs(int gir)//dfs函数求的是编号为gir的女孩能否匹配到男生，如果能，返回true，否则，返回false&#123; vis_gir[gir]=true;//标记 for(int i=1;i&lt;=N;i++) &#123; if(vis_boy[i])//我们规定每次匹配对于某个男生只访问一遍，如果先前访问过了，就换个男生 continue ; int gap=ex_gir[gir]+ex_boy[i]-love[gir][i]; if(gap==0)//如果这个条件满足，说明编号为gir女孩和编号为i的男孩可能能够匹配成功 &#123; vis_boy[i]=true;//标记 if(match[i]==-1||dfs(match[i]))//如果这两个条件满足其中一个，说明编号为gir女孩和编号为i的男孩匹配成功 &#123; match[i]=gir; return true; &#125; &#125; else slack[i]=min(slack[i],gap);//如果gap不等于0，说明当前状态编号为gir女孩和编号为i的男孩不可能匹配成功，更新slack[i]。 &#125; return false;&#125;int km()&#123; memset(match,-1,sizeof(match)); memset(ex_boy,0,sizeof(ex_boy)); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) ex_gir[i]=max(love[i][j],ex_gir[i]);//初始化ex_gir数组 for(int i=1;i&lt;=N;i++) &#123; fill(slack,slack+N+1,INT); while (1)//这个while循环结束的条件是直到让编号为i的女生找到可以匹配的男生后 &#123; memset(vis_gir,false,sizeof(vis_gir)); memset(vis_boy,false,sizeof(vis_gir)); if(dfs(i))//如果这个条件满足，说明编号为i的女生找到了匹配的男生，换下一个女生,如果这个条件不满足，说明这个女生没有匹配到男生，让这个女生降低期望值后继续匹配 break ; int t=INT; for(int j=1;j&lt;=N;j++)//寻找在这一轮匹配中没有匹配到的男生如果要获得女生芳心所需要增加的期待值的最小值 if(!vis_boy[j]) t=min(t,slack[j]); for(int i=1;i&lt;=N;i++)//让在这一轮匹配中匹配过的女生的期待值减小，匹配过的男生的期待值增加 &#123; if(vis_gir[i]) ex_gir[i]-=t; if(vis_boy[i]) ex_boy[i]+=t; else slack[i]-=t;//因为有些女生的期待值减小了，所以这一轮没有被匹配过的男生得到女生的芳心所需要增加的期待值就变小了，所以slack数组中的相应的值要变小 &#125; &#125; &#125; int res=0;//计算好感和 for(int i=1;i&lt;=N;i++) res+=love[match[i]][i]; return res;&#125;int main()&#123; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) cin&gt;&gt;love[i][j]; cout&lt;&lt;km()&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath语法]]></title>
    <url>%2F2019%2F06%2F27%2Fxpath%2F</url>
    <content type="text"><![CDATA[xpath基本语法XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，有不同类型的节点，包括元素节点，属性节点和文本节点，提供在数据结构树中找寻节点的能力。起初 XPath 的提出的初衷是将其作为一个通用的、介于XPointer与XSLT间的语法模型。但是 XPath 很快的被开发者采用来当作小型查询语言。简单来说我们通过Xpath可以获取XML中的指定元素和指定节点的值。在网络爬虫中我们通过会把爬虫获取的HTML数据转换成XML结构，然后通过XPath解析，获取我们想要的结果。样例：123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt; &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book&gt; &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt;1.选取节点表达式描述nodename选取此节点的所有子节点/从根节点选取//从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置.选取当前节点..选取当前节点的父节点@选取属性2. 路径表达式路径表达式结果bookstore选取 bookstore 元素的所有子节点。/bookstore选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！bookstore/book选取属于 bookstore 的子元素的所有 book 元素。//book选取所有 book 子元素，而不管它们在文档中的位置。bookstore//book选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。//@lang选取名为 lang 的所有属性。3.谓词(Predicates)谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。路径表达式结果/bookstore/book[1]选取属于 bookstore 子元素的第一个 book 元素。/bookstore/book[last()]选取属于 bookstore 子元素的最后一个 book 元素。/bookstore/book[last()-1]选取属于 bookstore 子元素的倒数第二个 book 元素。/bookstore/book[position()&lt;3]选取最前面的两个属于 bookstore 元素的子元素的 book 元素。//title[@lang]选取所有拥有名为 lang 的属性的 title 元素。//title[@lang=’eng’]选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。/bookstore/book[price&gt;35.00]选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。/bookstore/book[price&gt;35.00]/title选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。4.选取未知节点XPath 通配符可用来选取未知的 XML 元素。通配符描述*匹配任何元素节点。@*匹配任何属性节点。node()匹配任何类型的节点。实例路径表达式结果/bookstore/*选取 bookstore 元素的所有子元素。//*选取文档中的所有元素。//title[@*]选取所有带有属性的 title 元素。5.选取若干路径通过在路径表达式中使用“|”运算符，您可以选取若干个路径。实例：路径表达式结果//book/title \//book/price选取 book 元素的所有 title 和 price 元素。//title \// price选取文档中的所有 title 和 price 元素。/bookstore/book/title \//price选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。]]></content>
      <categories>
        <category>Python</category>
        <category>xpath</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列栈和队列都是比较常用的数据结构。栈的应用非常的广泛，比如说，递归函数的实现就是借助于栈保存相关的数据。操作系统中每个线程也会使用栈来保存函数调用涉及到的一些参数和其他变量等。栈最大的一个特点就是先进后出(FILO—First-In/Last-Out)。队列和栈不同的是，队列是一种先进先出(FIFO—first in first out)的数据结构。1.栈头文件: #include&lt;stack&gt;栈是后进先出(Last In Fisrt Out)的一种特殊的线性表。栈可以存储多种类型数据，包括但不限于int char string double以及pair等等。栈的基本操作如下:12345678910111213stack&lt;int&gt;S; //定义栈S.push(x); //入栈——入栈是把元素压入栈底；S.pop(); //出栈——出栈是删除栈顶元素；S.top(); //取栈顶元素——取栈顶元素只返回元素，不删除；S.empty(); //判断栈是否为空——的判空一般都和 while 循环配套使用，比如下面代码输出栈内所有元素，并清空栈。若为空，则返回trueS.size(); //获取栈的大小——获取栈的大小返回栈內元素数量；注: empty的一般用法:while(!S.empty())&#123; cout&lt;&lt;S.top()&lt;&lt;endl; S.pop();&#125;2.队列头文件是#include&lt;queue&gt;注意：一般用到优先队列的时候都会用到结构体结构体：struct 结构体名称{ }自定义命名; eg:struct node{}student;在运用结构体的时候一般在输入的时候，可以直接带着结构体的方式输入优先队列：用的时候为priority_queue详解链接：https://blog.csdn.net/c20182030/article/details/70757660friend bool operator==(const Sales_item&amp;, const Sales_item&amp;);的用法：1234这个函数是友元函数，返回的是bool值operator是用于运算符重载的，判断两个Sales_item类型的数据时否相等， operator是C++的关键字，它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。这是C++扩展运算符功能的方法，虽然样子古怪，但也可以理解：一方面要使运算符的使用方法与其原来一致，另一方面扩展其功能只能通过函数的方式（c++中，“功能”都是由函数实现的)。1234operator是重载的意思operator _运算符号_ （参数）所谓运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。自定义类的赋值运算符重载函数的作用与内置赋值运算符的作用类似，但是要要注意的是，它与拷贝构造函数与析构函数一样，要注意深拷贝浅拷贝的问题，在没有深拷贝浅拷贝的情况下，如果没有指定默认的赋值运算符重载函数，那么系统将会自动提供一个赋值运算符重载函数。]]></content>
      <categories>
        <category>图论</category>
        <category>线性结构</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM题解]]></title>
    <url>%2F2019%2F06%2F25%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[将题解和题目集区分开主要是为了确保先思考，想方法，最后再对照题解主要还是为了养成独立思考的好习惯对应于习题集https://weakdouqing.github.io/2019/05/22/%E9%A2%98%E7%9B%AE%E9%9B%86/1.The Triangle12345678910111213141516171819202122232425262728293031323334353637题解：#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[101][101];int dp[101][101];int main()&#123; int n, m; int i, j; while(scanf(&quot;%d&quot;,&amp;m)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(i=1;i&lt;=m;i++) &#123; for(j=1;j&lt;=i;j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; for(j=1;j&lt;=m;j++) dp[m][j] = a[m][j]; for(i=m-1;i&gt;=1;i--) &#123; for(j=1;j&lt;=i;j++) &#123; dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]) + a[i][j]; &#125; &#125; cout&lt;&lt;dp[1][1]&lt;&lt;endl; &#125; return 0; &#125;2.区间完美数1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,c,d;long long lcm(long long a,long long b)&#123; return a*b/__gcd(a,b);&#125;long long solve(long long x)&#123; return x-x/c-x/d+x/lcm(c,d);&#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; cout&lt;&lt;solve(b)-solve(a-1)&lt;&lt;endl; return 0;&#125;3.最短路dijkstra算法写的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define INF 0x3fffffffusing namespace std;const int maxx=1e5; int map[110][110], dis[110], vis[110];void dijkstra(int n, int x)&#123; int p, minn; //将所有的两点间的距离存储，并将所有点设置为未访问 for(int i = 1; i &lt;= n; i ++) &#123; dis[i] = map[1][i]; vis[i] = 0; &#125; vis[x] = 1; //遍历所有点，找到最小路径 for(int i = 1; i &lt;= n; i ++) &#123; minn = INF; for(int j = 1; j &lt;= n; j ++) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; minn) &#123; p = j; minn = dis[j]; &#125; &#125; vis[p] = 1; for(int j = 1; j &lt;= n; j ++) &#123; if(!vis[j] &amp;&amp; dis[p] + map[p][j] &lt; dis[j]) &#123; dis[j] = dis[p] + map[p][j]; &#125; &#125; &#125; &#125;int main()&#123; int n, m, i, j, a, b, t; //初始化距离值为无穷 while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m)!=EOF) &#123; if(n == 0 &amp;&amp; m == 0) break; for(i = 1; i &lt;= n; i ++) &#123; for(j = 1; j &lt;= n; j ++) &#123; map[i][j] = INF; &#125; &#125; //设置两点之间的权值 for(i = 1; i &lt;= m; i ++) &#123; scanf(&quot;%d %d %d&quot;,&amp;a, &amp;b, &amp;t); map[a][b] = map[b][a] = t; &#125; dijkstra(n, 1); printf(&quot;%d\n&quot;,dis[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Question Solution</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题优化(二)]]></title>
    <url>%2F2019%2F06%2F24%2Fnext%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Next主题优化(二)继上一次的优化没完成的部分，此次继续添加一些优化内容若是想要更多内容，可以自行百度/Google一下，继续更新内容1.字数统计和阅读时长1.安装插件npm install hexo-symbols-count-time –save2.修改站点配置文件找到合适的地方添加下面的代码1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true3.修改主题配置文件123456789101112# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 2752.给文章添加阴影效果打开themes/next/source/css/_custom/custom.styl，添加下面的代码：12345678// 为文章添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;3.添加宠物1.安装依赖包安装依赖包,在站点根目录，打开Git Bash ，安装hexo-helper-live2d在站点配置文件或者主题配置文件添加以下内容1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true2.安装想要的宠物文件npm install {packagename}Eg:如果安装下面图示的宠物/1.png)如效果图所示的宠物名为haruto， 则为 npm install live2d-widget-model-haruto,其他宠物包点击live2d-widget-models。如果需要修改宠物的位置，可以在display下添加1234# 水平位置hOffset: 0# 垂直位置vOffset: -204.添加网站已运行时间在themes/layout/_parrials/footer.swing中添加12345678910111213141516171819202122232425262728&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout(&quot;siteTime()&quot;, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(2018,06,07,12,00,00); // 设置建立网站的时间 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+diffYears+&quot; 年 &quot;diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;; &#125; siteTime();&lt;/script&gt;5.添加标签云在next/layout/page.swig中，找到123&lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt;如果你想卷标页先显示标签云，再显示基本的卷标页，可以在这段代码之前添加123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125;如果是先显示默认的卷标页，再显示标签云，则把上面代码添加到后面。如果你只想显示标签云就行，可以把123&lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt;删去就行6.修改界面内容显示区域宽度Next主题默认的设置，两边留白的区域很大。当然我们可以修改设置在themes\next\source\css_custom的custom.styl添加下面参数12345// 屏幕宽度小于1600px$content-desktop = 700px// 屏幕宽度大于或等于 1600px$content-desktop-large = 900px只需要修改对应的参数就行,要注意的是，此方法不适用于Pisces主题]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题优化(一)]]></title>
    <url>%2F2019%2F06%2F22%2Fnext%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Next主题优化(一)搭建完blog肯定要优化一下,不然界面你不会觉得丑吗？这篇文章将写一些能够优化界面的方法,没有的地方请自行搜索补充1.修改Hexo站点配置文件12345678910111213141516# Site 网站title: Dou Qing #网站标题subtitle: ~~愿你天黑有灯，下雨有伞~~ #网站副标题description: 学无止境 #网站描述author: Yan #博主的名字language: zh-Hans #网站使用的语言 PS:如果设置完后没有效果的话,去\themes\landscape\languages里面查看有的语言，一般会有zh-CN,这个就是中文timezone: #网站时区。Hexo 默认使用您电脑的时区# 侧边栏头像设置# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/图片名字 把你的头像设置在这里 #/images/avatar.gif其余的可以看着设置,不想设置的就不设置2.Hexo主题配置文件(next)next更多内容参考:http://theme-next.iissnan.com/theme-settings.html重点！！！！优化的重点！！想要花里胡哨的特效就认真对待这个文件打开Hexo目录/themes/next/_config.yml文件1.开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接2.开启友情链接123456789# Blog rollslinks_icon: linklinks_title: 友情链接 //自己命名即可links_layout: block#links_layout: inlinelinks: #Title: http://example.com 在这开始写你想要的友情链接3.选择Scheme123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Pisces#scheme: Mist#scheme: Pisces#scheme: Gemini4.设置首页不显示全文打开主题配置文件_config.yml,ctrl + F搜索找到”auto_excerpt”，找到12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。5.分类和标签设置首先通过hexo n “name”命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用notepad++或者sublime text打开12345title: namedate: 2014-08-05 11:15:00 tags: ---大概这个样子，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。5.1.设置分类列表123456categories: - 大类- 中类- 小类...---每一层- 内容的下面都是一种包含关系，而不是同级，这点要和标签分开在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。5.2.设置标签12345678tags: - 标签1- 标签2- 标签3- 标签4...- 标签n---3.背景设置1.静态背景修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：123456body &#123; background-image: url(/images/(你想设置的)背景图片名称.png); background-attachment: fixed; background-repeat: repeat; background-size: contain;&#125;background-image: 你想放置图片的urlbackground-attachment: 不随屏幕滚动而滚动background-repeat: 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺background-size: 等比例铺满屏幕将背景图命名为 (你想设置的)背景图片名称.png并放入主题根目录/images下或者可以直接用自动切换图片,url为:https://source.unsplash.com/random/1600x9002.修改不透明度这个主要是为了避免next的过于简洁的界面而造成看起来过于单一完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125;background: #fff; 颜色设置opacity: 0.8;不透明度设置:范围(0-1)PS: 如果设置完没有效果的话,打开你的blog的界面,F12,打开源代码审查页面,找到不合适的地方,根据html的语法和方式修改即可,若是没学过html+css的朋友可以借鉴一下下个网址一个简单方便学习html+css的网站: http://www.w3school.com.cn/3.动态可交互背景(js引入)打开博客根目录/themes/next/layout/_layout.swig文件，在之前添加代码如下：1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;属性说明:12345属性说明： - color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) - opacity: 线条透明度（0~1）, 默认: 0.5 - count: 线条的总数量, 默认: 150 - zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1打开博客根目录/themes/next/_config.yml，找到字段canvas_nest，将其置为true【如果没有找到该字段，请自行添加】运行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 查看效果]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我感想]]></title>
    <url>%2F2019%2F06%2F21%2F%E8%87%AA%E6%88%91%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[一些想法回想起当时创建这个blog的时候，只是想把自己做过的题和一些想法写下又或者是写一些对自己警醒、对别人有用的知识点，来达到共同进步和学习现在看来有点偏离主题了随着对算法的逐步学习，发现要学习的东西真的是很多！！！最后，只是想提醒一下自己学算法这条路是我自己选的，没有任何人逼我，完全是自愿的那么，为什么不再努力一把，一直学下去学习，终将是会有所收获，也许收获的不是自己想要的，但是这份经验以及在学习中所积累的解决方法，依然会使自己逐步趋于完善既然当初选择了学习，那边应该一往无前···再努力先前走一小步，也许明天真的不一样了最后提一个小问题：如果生活向你招出了手，你会拒绝吗？]]></content>
      <categories>
        <category>总结</category>
        <category>想法</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后]]></title>
    <url>%2F2019%2F06%2F20%2FN%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[序言N皇后问题一直是一个百炼不厌的题目写着一篇主要是为了深入理解和学会N皇后学习N皇后的主要思想和解题思路主要运用到的方法有,递归,DFS,遗传算法和CSP最小冲突法要说的一点是，因为本人比较菜，所以遗传算法和最小冲突法还没有学会N皇后问题:描述:1234N皇后问题是一个古老而著名的问题，是回溯算法的典型案例。该问题由西洋棋棋手马克斯·贝瑟尔于1848年提出。在国际象棋上，N皇后问题变成了8皇后问题，著名的数学家高斯认为有76种方案，后来有人用图论的知识解出92种结果，计算机发明后，可以通过算法实现问题的求解。8皇后问题是指在8*8的棋盘上摆放8个皇后，使得任意两个皇后都不在同一行、同一列或者同一斜线上，求满足这种摆放的解为多少个。（答案是92种）学会了8皇后以后，N皇后自然就迎刃而解了。提交问题链接:http://acm.hdu.edu.cn/showproblem.php?pid=255312345678910111213141516Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。Sample Input 1 8 5 0 Sample Output 1 92 10解题思路:首先要模拟一下:1.递归算法:123我们逐列放皇后（从小到大逐列摆放），现在先给第一列放皇后，很显然我们会把它放在第一行，接下来，给第二列放皇后，那么第二列的皇后能放在哪些位置？这时候需要一个判断函数来判断第二列的皇后能放在那里。如果第二列找到放皇后的某一行，那么就进行第三列的摆放，这里就是递归。2.回溯法:123如果还没有进行到最后一列的摆放时就已经不能再放皇后，那么此时需要怎么做？就返回递归的前面一次，把当前列的前面一列的皇后放在后面的行数上（从小到大逐行检验）。如果此时逐行检验已经遍历完所有的行数还是出现上面不能摆放的情况，那就在再返回上一次的递归，在进行逐行检验。这里就是回溯。3.递归算法的终止条件:1234由初始条件知道，第一行第一列放皇后，那么会不会有第一行第一列不放皇后的情况呢？我们能不能把这个位置放空，然后把第一列的皇后放在第二行上，或者更后面的一行。答案是肯定能的。那么问题来了，程序在运行到什么时候会进行这样的处理？当第一行第一列放皇后的所有情况都已经遍历完之后，就会把第一列的皇后放在第二行上，再把这个情况都遍历完，然后又把第一列的皇后放在第三行上，依次类推，直到把第一列的皇后放在最后一行上，当遍历完成时，递归终止。4.遗传算法:12345678910是随机剪枝搜索的一个变化形式。它通过把两个父状态结合来生成后继。算法模拟大自然的自然选择、基因杂交和变异。其中自然选择依据适应值的大小来评估被选中的概率，让更加优质的父状态更有可能传给下一代。生成种群、杂交、和变异都是依赖随机数和概率来模拟“物竞天择，适者生存”的自然法则。算法不断Select, Crossover, Mutate直到产生了一个最优解。一个棋盘可以看成是一条染色体，统称为“状态”，一个棋盘中的皇后可以看成一个基因。我不断调整种群数量的大小、适应值函数、杂交的策略、还有变异的概率，逐渐发现了更加优秀的参数。以下是我的实验结论：假设是N皇后，那么种群的数量最优是4N课本《人工智能：一种现代的方法》上的适应值函数不好，稍微改进一点的适应值函数 f = 冲突皇后对的个数的倒数，这样能够拉开优质和劣质个体被选的概率。 课本上面的“单点+双侧”杂交（随机选择单个杂交点，这个杂交点的两侧都交换）的效果不佳，不如“单点+单侧”杂交，也不如“双点+双点之间”杂交。单个基因（一个皇后）变异的概率小于0.05，比如0.04的时候，效果较好。5.CSP最小冲突法:123456789101112131415161718局部搜索对求解不少constraint satisfy problem有着很棒的效果。N皇后问题就是一个约束满足问题，这里的约束，就是指“皇后之间不能冲突”。该算法使用完全状态的形式化：初始状态每个变量都赋一个值，后继函数每一次改变一个变量的取值，改变取值的依据是使冲突最小化——最小冲突启发式。如果最小冲突值有多个，那么按照一定的概率选择。（经过大量反复实验发现，CSP最小冲突法存在极小概率的不完备性，即永远也找不到满足约束条件的最优解，当遇到此情况的时候，可以选择退出当前的求解，重新生成一个新的初始状态再来一次）该算法最精彩的地方，是时间复杂度可以优化到O(n^2)，于是可以在几秒内解决1万皇后的问题，在几十分钟内解决几万甚至10万皇后的问题！这是前两种算法完全无法比拟的。时间复杂度优化到O(n^2)有一点代价，那就是多付出一些空间复杂度。多出来的空间复杂度是O(n)，这个和优化的时间复杂度（从O(n^4 ) 到O(n^2)）相比，可以说是微不足道的，完全值得的。多出来三个vector，分别用来存储一个棋盘上的（以 8 皇后为例）:8个垂直方向的皇后数量15个主对角线方向的皇后数量15个反对角线方向的皇后数量那么，一个皇后的冲突数量，就是这三个vector中的相应的值相加，利用下标转换关系可以做到。这样计算一个皇后的冲突数量，就可以在常数时间内完成。这是十分吸引人的！当然，每一次放置皇后和移开皇后的时候，需要更新上述三个vector的相应值，维护这三个vector也需要时间开销，不过这也是常数。检测一个状态是否达到最优状态的时候，只需要判断每一个垂直方向（列）上面的皇后数量是否为1，主对角线和反对角线方向上的皇后数量是否是0或者1即可，这个时间复杂度是O(n)6.思路实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Max 20 //表示最大的棋盘边长,可以自定义为其它数据int pos[Max+1]; //为什么只需要定义一个一维数组就能描述二维的棋盘？ //pos[i]是这样定义的：即第i列的皇后放在第pos[i]行上， // 也就是说，pos[i]的索引i代表皇后所在的列，它的值pos[i]代表皇后所在的行int n; //棋盘的边长和皇后的数量int sum; //可以成功摆放的数量，每次遍历成功就加1bool checkNQ(int col)&#123; //对第col之前的列进行逐列检查,pos[i]中i的值为列，pos[i]的值为行 for(int i=1;i&lt;col;i++) if(pos[i]==pos[col]||abs(i-col)==abs(pos[i]-pos[col])) //如果行数相同，或者行数相减的绝对值等于列数相减的绝对值 //此时都不能放皇后，因为对第col列之前的列进行逐列检查， //所以不需要再进行列是否相同的判断 return false; return true;&#125;void dfsNQ(int col,int n)&#123; if(col==n+1) //成功遍历一次,sum加1，然后继续探索其他情况 sum++; for(int i=1;i&lt;=n;i++)&#123; pos[col]=i;//假设第col列的皇后放在第i行上，然后利用checkNQ()函数检查是否能放入 //第一种情况，如果能放入，则继续假设下一列也放在第i行（实际上第i行此时已经不能放了， //所以cheakNQ()函数就会直接返回false, //然后上面的for循环中的i自动加1,即假设第col+1列放在第i+1行，然后又继续检查能否放入。 //第二种情况，如果不能放入，for循环中的i就自动加1，即假设第col列的皇后放在第i+1行上， //又继续检查能否放入 //如果当col&lt;=n时（即列还没有遍历完）再也不能在任何一行放皇后，那么此时dfsNQ中的for循环的i已经 //遍历完，dfsNQ就会返回到上一级的dfsNQ(col+1,n),此时col就会自动减1（因为每次递归都是加1）， //然后，尝试第col列的皇后能否放在第i+1行上，如此进行回溯。 if(checkNQ(col)) dfsNQ(col+1,n); //进行递归 &#125;&#125; int main() &#123; cout&lt;&lt;&quot;请输入皇后的数量：&quot;; cin&gt;&gt;n; dfsNQ(1,n); //传入第一列和n,从第一列开始放皇后。 cout&lt;&lt;endl&lt;&lt;&quot;满足条件的所有摆放次数为：&quot;; cout&lt;&lt;sum; return 0; //说明：dfsNQ函数完全退出的条件是所有满足条件的情况都已经遍历过，再也没有满足条件的遍历 //根据递归的初始化分析得知，前面的遍历都会默认第一行第一列的位置会放皇后， //然而实际情况是这个位置不放皇后也能满足条件的次数甚至更多，那么程序在运行到什么时候会把 //第一行第一列的位置放空呢？答案是当第一行第一列放皇后的满足条件的所有遍历都结束时， //就会把第一列的皇后放在第二行，而把第一行第一列的位置放空。 //如此进行到最后，最后面是把第一列的皇后放在最后一行， //然后再全部遍历，结束时整个dfsNQ函数递归运行结束。主函数return 0. &#125;7.代码实现希望看到这里的你不要只是复制粘贴来过题(ctrl+cv),因为这样做，没有任何意义12345678910111213简单方法之打表法(极度不推荐,如果这样做,将学不会N皇后的精髓算法如DFS/回溯法/递归算法)#include &lt;iostream&gt;using namespace std;int n=1,x[11]=&#123;0,1,0,0,2,10,4,40,92,352,724&#125;;int main()&#123; while(n!=0) &#123; cin &gt;&gt; n; if(n!=0) cout &lt;&lt; x[n] &lt;&lt; endl; &#125; return 0;&#125;1.C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int a[15],ans[15],num,l,m,n,k,r;void dfs(int x)//搜索第x行可不可以放皇后&#123; if(x==n+1)//当查找到第n+1行是结束 &#123; l++; return; &#125; else &#123; for(int i=1;i&lt;=n;i++)//搜索第x行的第i列可不可以放皇后 &#123; a[x]=i;//假设将皇后放在第i列，标记 r=1; for(int j=1;j&lt;x;j++) &#123; if(a[j]==i||i-x==a[j]-j||i+x==a[j]+j)//第一句查询第j列是否已经放了皇后，第二三句查询对角线上是否放了皇后，算一遍就清楚了 &#123; r=0;//如果有，就退出去进行下一次循环，代表这个地方不能放皇后 break; &#125; &#125; if(r==1) dfs(x+1); &#125; &#125;&#125;int dabiao()//题目中说了n不大于10，所以可以直接打表&#123; for(n=1;n&lt;=10;++n) &#123; l=0; dfs(1); ans[n]=l; &#125;&#125;int main()&#123; dabiao(); while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; if(n==0) break; printf(&quot;%d\n&quot;,ans[n]); &#125; return 0;&#125;2.C++语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int vis[3][50], P[15];//三个方向 ↖↑↗在此三个方向都不能有皇后 int n, sum;void DFS(int row);int main()&#123; for(n = 1; n &lt;= 10; n++)//先打表不然会超时的 &#123; memset(vis,0,sizeof(vis)); sum = 0; DFS(1); P[n] = sum; &#125; while(scanf(&quot;%d&quot;,&amp;n), n) &#123; printf(&quot;%d\n&quot;,P[n]); &#125; return 0;&#125;void DFS(int row)&#123; int i; if(row == n + 1)//已经够n行了 &#123; sum ++; return ; &#125; for(i = 1; i &lt;= n; i++) &#123; if(vis[0][row-i+n] == 0 &amp;&amp; vis[1][i] == 0 &amp;&amp; vis[2][row+i] == 0) &#123;//不会回溯的应该好好看看学习学习 vis[0][row-i+n] = vis[1][i] = vis[2][row+i] = 1;//变值 DFS(row + 1);//深搜 vis[0][row-i+n] = vis[1][i] = vis[2][row+i] = 0;//回溯 &#125; &#125;&#125;3.遗传算法伪代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//主循环 void Genetic::GeneticAlgorithm() while m_NotSuccess为真 Select Crossover Mutate End while 打印最优解 End //计算一个state（棋盘）的适应值 //适应值采用“互相攻击皇后对的个数的倒数”，这比书上直接计算不互相攻击的皇后对数作为适应值的方法相比，更能拉开不同状态之间的差距。 //@para state：一个状态的引用 double Genetic::CalcuAdaptive(vector &amp;state) counter←0 For i: 0 to QueenNum-1 do For i: 0 to QueenNum-1 do If 对角线方向互相攻击，或者垂直方向互相攻击 counter++ End if End for End for If counter等于0 m_NotSucess←false，程序的循环终止条件 m_BestOne←state，保存当前的状态 End if Return 1.0/counter End //自然选择，大体思路是轮盘赌选择 void Genetic::Select() 创建一个新的空种群newPopulation For i: 1 to populationSize-1 do m_accumuAdaptive[i]←m_accumuAdaptive[i - 1] + m_adaptive[i] End for totalAdaptive←m_accumuAdaptive的最后一个元素 For i: 0 to populationSize-1 do 先把totalAdaptive(这是一个实数)放大成一个整数 产生一个随机数 ，对totalAdaptive求模，得到 ran 按相同比例缩小成一个实数 用二分查找的方法，在m_ accumuAdaptive内进行查找 ran，找出位置 j 把m_population的第 j 个状态push_back到newPopulation中 End for m_population←newPopulation End杂交有多种思路：选择两个state状态，随机产生一个杂交点，然后对这个杂交点的右（左）边的“基因”进行交换选择两个state状态，随机产生一个杂交点，然后再对这个杂交点两边的“基因”都进行交换。选择两个state状态，随机产生两个杂交点，然后再对这两个杂交点之间的“基因”进行交换。变异： 通过伪随机数，使每一个基因有0.0几的概率进行突变。突变就是用伪随机数赋值。??:4.CSP最小冲突法123456789101112131415161718192021以下是主循环的伪代码 void MinConflict::MinConflictAlgorithm() While 没有找到最优解 For row: 0 to QueenNum-1 do 移开棋盘row这一行的皇后 更新相应的三个保存皇后数量的vector For column: 0 to QueenNum do 计算(row, column)位置的冲突值，常数时间 If 比之前的 min 更小 更新最小值 min, 更新此时的 columnMin Else if 和之前的最小值相等 50%概率更新最小值min，更新此时的 columnMin End if End for 放置皇后到冲突最小的地方(row, columnMin) 更新相应的三个保存皇后数量的vector 如果检测达到了最优状态，即找到了最优解，break For End for End while 打印最优解 End比较效果:遗传算法和CSP最小冲突法的比较:]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础]]></title>
    <url>%2F2019%2F06%2F19%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C语言1.简介：1234C语言是一门面向过程、抽象化的通用程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。C语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。尽管C语言提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的C语言程序可在包括一些类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。2.应用工具：Dev-C++Notepad++VC++3.基础模板：12345678910#include&lt;stdio.h&gt;int main()&#123; //声明变量 //内容（函数体） return 0; &#125;4.C语言简单的a+b12345678910111213#include&lt;stdio.h&gt; //包含标准输入输出的头文件 int main()&#123; int a,b; //定义变量a+b scanf("%d%d",&amp;a,&amp;b); //标准输入scanf,%d十进制转换符号，&amp;取地址符号，scanf里面必须带 sum=a+b; printf("%d\n",sum;) //标准输出printf,\n强制换行符 return 0;&#125;入门c语言：##1.关于数组：a[i] = i ：表示对数组a[i]的第i个元素赋值为i在字符串数组中，如chara[1000],a+3表示将存储字符串的首地址向后取3位名，但是原来的三位并不会消失，只不过在取的时候跳过了n:一个式子：12345678910111213141516171819#include&lt;stdio.h&gt;int a[1000];int main()&#123; int n,m; scanf("%d",&amp;n); while(n--)&#123; scanf("%d",&amp;m); int sum=0; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;a[i]); sum=(sum+a[i]); &#125; printf("%d\n\n",sum); &#125; return 0; &#125;2.需要注意的地方：1.在做算法题的时候，有必要为自己命名的变量赋值，如果不赋值的话可能会影响正常结果。2.在&lt;stdio.h&gt;中输入函数有：scanf(“ “，&amp; ); gets(“字符串”); getchar(“字符”);输出函数有：printf(“ “, )’’; puts(“字符串”)； putchar(“字符”);2.素数判定：对于这个比较好的题（经常错），当然是好好纪念一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546题目：对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。Input：输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。Ouput：对于每个给定范围内的取值，如果表达式的值都为素数，则输出"OK",否则请输出“Sorry”,每组输出占一行。 Sample Input：0 10 0Sample Output：OK详解：#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;//#include&lt;bits/stdc++.h&gt; 万能头文件，hdu不能用（无语。。。。）using namespace std;int main()&#123; int n,m; int j; while(scanf("%d %d",&amp;n,&amp;m)!=EOF) &#123; int sum=0,flag=1; //sum初始化，flag作为最后的判断条件 if(n==0&amp;&amp;m==0) break; for(int i=n;i&lt;=m;i++) //按照题目赋值 &#123; sum=i*i+i+41; //计算sum值 for(int j=2;j&lt;=sqrt(sum);j++) //素数的判定是从2开始的，sqrt(sum)也可以写作sum-1，只不过sqrt比较快一点 &#123; if(sum%j==0)&#123; //要用sum去%j,判断是否为素数 flag=0; //若为素数则是flag（判断条件）为0 break; &#125; if(flag==0) break; &#125; &#125; if(flag==0) printf("Sorry\n"); else printf("OK\n"); &#125; return 0;&#125;进阶素数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677题目：美素数：小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。 问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。 给定一个区间，你能计算出这个区间内有多少个美素数吗？ Input第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。 接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。Output对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。 每组数据占一行，具体输出格式参见样例。Sample Input31 1002 23 19Sample OutputCase #1: 14Case #2: 1Case #3: 4 题解：思路：素筛+打表 本题的目的是计算某个区间的美素数的个数。类似这样的问题，不能每次判定，否则计算上必然超时，所以需要打表。#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define mod 1000000+5bool a[mod];int ans[mod];void prim() //快速素筛--埃拉托斯特尼(Eratosthenes)筛法，比一般的筛法更快一点&#123; int n,m; int i,j; memset(a,true,sizeof(a)); a[0]=a[1]=false; for(i=2;i&lt;mod;i++) &#123; for(j=2;j*i&lt;mod;j++) &#123; a[i*j]=false; &#125; &#125; &#125;int he(int n) //求和&#123; int sum=0; while(n) &#123; sum += n%10; n /= 10; &#125; return sum;&#125;int main()&#123; int t; int i; int shu=1,num=0; prim(); memset(ans,0,sizeof(ans)); //素筛里面初始化为0 int x,y; for(i=2;i&lt;mod;i++) //素筛并打表 &#123; if(a[i]&amp;&amp;a[he(i)]) num++; ans[i]=num; &#125; scanf("%d",&amp;t); while(t--) &#123; scanf("%d %d",&amp;x,&amp;y); printf("Case #%d: %d\n",shu++,ans[y]-ans[x-1]); //ans[y]-ans[x-1]待补 &#125; return 0; &#125;]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown知识点]]></title>
    <url>%2F2019%2F06%2F19%2FMarkdown%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[基础知识点1.标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题效果：2.在里面插入图片（使用相对路径）格式为：1![对图片的文字描述](路径)3.文本样式1234**这是加粗的文字** 要加粗的文字左右分别用两个*号包起来*这是倾斜的文字*` 要倾斜的文字左右分别用一个*号包起来***这是斜体加粗的文字*** 要倾斜和加粗的文字左右分别用三个*号包起来~~这是加删除线的文字~~ 要加删除线的文字左右分别用两个~~号包起来效果：4.引用123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容效果：5.分割线12345三个或者三个以上的 - 或者 * 都可以。-------********效果：可以看到，显示效果是一样的。6.超链接12345[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加例如：[简书](http://jianshu.com)[百度](http://baidu.com)PS：注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替效果：7.列表1.无序列表语法：无序列表用 - + * 任何一种都可以12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格效果：2.有序列表语法：数字加点123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格效果：3.列表嵌套：上一级和下一级之间敲三个空格即可8.表格123456789101112131415161718表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略举例：姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟效果：9代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容`代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行(123456789101112131415161718 代码... 代码... 代码...(```)ps：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。效果：![](Markdown知识点/8.png)## 10.流程图```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;效果：]]></content>
      <categories>
        <category>Base</category>
      </categories>
      <tags>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客]]></title>
    <url>%2F2019%2F06%2F18%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[学习使用hexo搭建自己的博客搭建的目的:1.是为了督促自己的学习2.是加深对计算机知识的理解3.写笔记本上视图看着不舒服相关知识点12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道1.自己搭建的过程经验和总结（写的不好勿喷）：可以参考的链接:https://zhuanlan.zhihu.com/p/266252492.准备Git 和 Node.js这两个工具Git: https://git-scm.com/Node.js: https://nodejs.org/en/安装过程不会的自行百度: https://www.baidu.com/3.开始创建：（打开Git Bash,下面的命令都是在Git Bash中输入）首先要有一个github的账号,连接为: https://github.com/，然后去创建仓库，仓库名命名格式为：你的用户名.github.io配置SSH:输入命令 ssh-keygen -t rsa -C “你的邮件地址” # 然后连续回车。将C盘中的路径”C:\Users\你的用户名.ssh\id_rsa.pub”的内容复制下来，打开之前创建好的GitHub，设置-&gt;SSH and GPG keys-&gt;New SSH key，粘贴到此处确定。然后再bash中输入： ssh -T git@github.com这个命令是用来测试SSH是否配置好，看到You’ve successfully authenticated, but GitHub does not provide shell access.则说明配置好了，否则无法使用hexo d4.安装Hexo输入命令: npm install -g hexo-cli # install可以简写为i5.初始化Hexo在你想要放置你的Blog的地方创建一个文件夹（比如使用Blog）输入命令: hexo init Blog # Blog可以修改成其他的名字找到这个Blog文件夹，进入6.命令:hexo cleanhexo g # 生成 此条和后一条可简写为 hexo s -ghexo s # 预览g是generate的缩写，s是start的缩写，d是deploy的缩写hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容。在输入“hexo s”之后服务会启动（可以通过ctrl+c来停止），此时我们在浏览器输入“localhost:4000”会看到如下情况：此时就表示博客搭建成功了，但是这个主题不太好看，我们稍微设置一下主题。7.修改主题（链接: https://hexo.io/themes/）继续在Git Bash输入“git clone https://github.com/iissnan/hexo-theme-next themes/next”命令完成之后在根目录下打开“_config.yml”文件，修改主题信息（将landscape修改为next）PS：此处安装的是next主题，如果喜欢其他主题，可以自行安装其他主题在Git Bash输入以下命令，然后在浏览器输入“localhost:4000”来查看效果：此时可以看到next主题默认的界面风格，这个是最简洁的，但还是不好看，我们打开“站点根目录/themes/next/_congig.yml ”文件，修改next主题的配置信息，如图：8.安装Hexo扩展npm install hexo-deployer-git –savenpm install9.部署简单理解就是以后你写的东西要相传到网上和别人分享就要通过部署上传到GitHub Pages上传之前，打开站点配置文件_config.yml，位于站点根目录下，修改最后一部分为如下部分。1234deploy: type: git repository: git@github.com:todest/todest.github.io.git # 修改为你的GitHub用户名 branch: master上传到GitHub Pages。此时是已经修改过的样式，至此，用Hexo搭建的本地博客已经完成一下推荐两个大佬的博客：当然，如果可以的话，还是希望你们能看我自己的博客过程啦~~~搭建经验的分享众所周知，学习的过程中如果有老师的指导，肯定要方便不少这次搭建的成功，首先要感谢大佬（手动@亦往沧劫）大佬博客链接：https://blog.todest.cn/修改并完善博客内容看下一篇文章：https://weakdouqing.github.io/2019/06/22/next主题优化(一)/#more推荐博客：https://blog.csdn.net/qq_35117024/article/details/81390780另一个：https://blog.csdn.net/lewky_liu/article/details/81277337]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典算法]]></title>
    <url>%2F2019%2F06%2F07%2F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治策略、动态规划、贪心算法、回溯法算法中的经典，同时也是最常用的几种算法1.分治策略(求解递归式的方法)待补2.动态规划能采用动态规划求解的问题的一般要具有3个性质：(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。(3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）动规解题的一般思路动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态动态规划决策过程示意图(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计：（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解算法实现的说明 动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：（1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}算法实现的步骤1、创建一个一维数组或者二维数组，保存每一个子问题的结果，具体创建一维数组还是二维数组看题目而定，基本上如果题目中给出的是一个一维数组进行操作，就可以只创建一个一维数组，如果题目中给出了两个一维数组进行操作或者两种不同类型的变量值，比如背包问题中的不同物体的体积与总体积，找零钱问题中的不同面值零钱与总钱数，这样就需要创建一个二维数组。注：需要创建二维数组的解法，都可以创建一个一维数组运用滚动数组的方式来解决，即一位数组中的值不停的变化，后面会详细徐叙述2、设置数组边界值，一维数组就是设置第一个数字，二维数组就是设置第一行跟第一列的值，特别的滚动一维数组是要设置整个数组的值，然后根据后面不同的数据加进来变幻成不同的值。3、找出状态转换方程，也就是说找到每个状态跟他上一个状态的关系，根据状态转化方程写出代码。4、返回需要的值，一般是数组的最后一个或者二维数组的最右下角。3.贪心算法贪心算法是指：在每一步求解的步骤中，它要求“贪婪”的选择最佳操作，并希望通过一系列的最优选择，能够产生一个问题的（全局的）最优解。贪心算法每一步必须满足一下条件：1、可行的：即它必须满足问题的约束。2、局部最优：他是当前步骤中所有可行选择中最佳的局部选择。3、不可取消：即选择一旦做出，在算法的后面步骤就不可改变了。4.回溯法回溯算法是所有搜索算法中最为基本的一种算法,是一种能避免不必要搜索的穷举式的搜索算法，其基本思想就是穷举搜索。123456789101112► 有许多问题，当需要找出它的解集或者要求回答什么解是满足某些约束条件的最佳解时，往往要使用回溯法► 回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。► 回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含(而不是找到解）问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索（剪枝），逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。算法思想：采用了一种“走不通就掉头”的思想。搜索时往往有多分支，按某一分支为新的出发点，继续向下探索，当所有可能情况都探索过且都无法到达目标的时候，再回退到上一个出发点，继续探索另一个可能情况，这种不断回头寻找目标的方法称为“回溯法”。搜索的方式主要采用深度优先搜索的方式回溯三要素：1) 解空间：该空包含问题的解2) 约束条件3) 状态树N皇后问题跳马问题迷宫问题图的着色问题0-1背包问题装载问题批处理作业调度填数问题组合输出问题算24点问题ACM应用]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法(DP)]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[一般的，我们常用的解决问题的方法有暴力解决法、分而治之、二分法、贪心法和动态规划法。在你遇到一个问题怎么想都想不出其解法的时候，很可能就需要用到动态规划了；在你的题目中出现最优、最多、最好等字眼的时候，很可能可以使用动态规划问题来解决了。动态规划思想那么什么是动态规划（Dynamic Programming）呢？动态规划和分治思想、递归有着千丝万缕的关系。简单来说，分治思想是把一个问题分成一个一个的互不相关小问题，小问题再细分直至不可分（类似于把一根木棍切啊切）；递归就是在程序运行的过程中调用自身的一种编程技巧；动态规划通过寻找过程状态转移方程，将一个问题分解为子问题求解，但是子问题之间可能会有重复，因此如果单纯的使用递归方法来实现动态规划问题时间复杂度会比较高。不过动态规划问题的本质就是递归，这是因为我们在分析动态规划问题的过程中，需要状态转移方程，这个状态转移方程本质上就是递归。后面实现的过程中是否使用递归只是实现的不同而已，其本质就是递归。动态规划有三个最基本的元素：最优子结构、状态转移方程和边界。状态转移方程用于描述将当前状态的解分解为更小状态的关系式；边界即状态转移方程的截止条件；最优子结构即确保通过状态转移方程所选择的子问题也能给出最优的解。下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。数字三角形(POJ1163)在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99输入格式：5 //表示三角形的行数 接下来输入三角形73 88 1 02 7 4 44 5 2 6 5要求输出最大和接下来，我们来分析一下解题思路：首先，肯定得用二维数组来存放数字三角形然后我们用D( r, j) 来表示第r行第 j 个数字(r,j从1开始算)我们用MaxSum(r, j)表示从D(r,j)到底边的各条路径中，最佳路径的数字之和。因此，此题的最终问题就变成了求 MaxSum(1,1)当我们看到这个题目的时候，首先想到的就是可以用简单的递归来解题：D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形，我们可以写出如下的递归式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849if ( r == N) MaxSum(r,j) = D(r,j); else MaxSum( r, j) = Max&#123; MaxSum(r＋1,j), MaxSum(r+1,j+1) &#125; + D(r,j); 完整代码#include &lt;iostream&gt; #include &lt;algorithm&gt; #define MAX 101 using namespace std; int D[MAX][MAX]; int n; int MaxSum(int i, int j)&#123; if(i==n) return D[i][j]; int x = MaxSum(i+1,j); int y = MaxSum(i+1,j+1); return max(x,y)+D[i][j]; &#125;int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl; &#125;超时原因：提交过后会超时，原因如下：重复计算了， 就拿第三行数字1来说，当我们计算从第2行的数字3开始的MaxSum时会计算出从1开始的MaxSum，当我们计算从第二行的数字8开始的MaxSum的时候又会计算一次从1开始的MaxSum，也就是说有重复计算。这样就浪费了大量的时间。也就是说如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2的n次方,对于 n = 100 行，肯定超时。接下来，我们就要考虑如何进行改进，我们自然而然就可以想到如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用n方的时间复杂度完成计算。因为三角形的数字总数是 n(n+1)/2根据这个思路，我们就可以将上面的代码进行改进，使之成为记忆递归型的动态规划程序：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;#define MAX 101int D[MAX][MAX]; int n; int maxSum[MAX][MAX];int MaxSum(int i, int j)&#123; if( maxSum[i][j] != -1 ) return maxSum[i][j]; if(i==n) maxSum[i][j] = D[i][j]; else&#123; int x = MaxSum(i+1,j); int y = MaxSum(i+1,j+1); maxSum[i][j] = max(x,y)+ D[i][j]; &#125; return maxSum[i][j]; &#125; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) &#123; cin &gt;&gt; D[i][j]; maxSum[i][j] = -1; &#125; cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl; &#125;优化代码:因为递归总是需要使用大量堆栈上的空间，很容易造成栈溢出，我们现在就要考虑如何把递归转换为递推，让我们一步一步来完成这个过程。1234567891011121314151617181920212223242526#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX]; int n; int maxSum[MAX][MAX]; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; for( int i = 1;i &lt;= n; ++ i ) maxSum[n][i] = D[n][i]; for( int i = n-1; i&gt;= 1; --i ) for( int j = 1; j &lt;= i; ++j ) maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j]; cout &lt;&lt; maxSum[1][1] &lt;&lt; endl; return 0;&#125;继续优化，而这个优化当然是对于空间进行优化，其实完全没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。对于空间优化后的具体递推过程如下：12345678910111213141516171819202122232425#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX]; int n; int * maxSum; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; maxSum = D[n]; //maxSum指向第n行 for( int i = n-1; i&gt;= 1; --i ) for( int j = 1; j &lt;= i; ++j ) maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j]; cout &lt;&lt; maxSum[1] &lt;&lt; endl; return 0;&#125;总结：递归到动规的一般转化方法递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。动规解题的一般思路将原问题分解为子问题把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。2.确定状态在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。3.确定一些初始状态（边界状态）的值以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。确定状态转移方程定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。数字三角形的状态转移方程:能用动规解决的问题的特点1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集与最小生成树]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[大佬博客：https://blog.csdn.net/qq_40772692/article/details/79667455并查集并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。集就是让每个元素构成一个单元素的集合，也就是按一定顺序将属于同一组的元素所在的集合合并。。在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这样的问题看起来似乎很简单，每次直接暴力查找即可，但是我们需要注意的问题是，在数据量非常大的情况下，那么时间复杂度将达到O（N*n）(n为查询次数)，那么这类问题在实际应用中，如果采取上述方法去做的话，耗费的时间将是巨大的。而如果用常规的数据结构去解决该类问题的话（顺序结构，普通树结构等），那么计算机在空间上也无法承受。所以，并查集这种数据结构便应运而生了。1234567891011121314故事读完，并查集就会了~~~~~江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。&lt;!--more--&gt;但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。下面我们来看并查集的实现。int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。1234567891011121314151617//find函数来查找队长int pre[1000 ]; int find(int x) //查找根节点 &#123; int r=x; while ( pre[r] != r ) //返回根节点 r r=pre[r]; int i=x , j ; while( i != r ) //路径压缩 &#123; j = pre[ i ]; // 在改变上级之前用临时变量 j 记录下他的值 pre[ i ]= r ; //把上级改为根节点 i=j; &#125; return r ; &#125;路径压缩(有时候在find函数里面可以省略)123456789再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低， 以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上 。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？123456789//join函数连接 注意：join函数一般写在find函数下边void join(int x,int y) //判断x y是否连通， //如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起, &#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fx ]=fy; &#125;最小生成树1.最小生成树概念：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树（使所有点联通+建立所有边的代价和最小）2.最小生成树应用：要在n个城市之间铺设光缆，主要目标是要使这 n 个城市的任意两个之间都可以通信，但铺设光缆的费用很高，且各个城市之间铺设光缆的费用不同，因此另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。1.Prim（普里姆）算法（加点法）(1)算法思想：以任意一点为树根出发，集合V是已经确定最短路的点集合，集合U是没有确立最短路的集合。初始时只有树根点在V中。每一次循环就代表要修建一条最短路，到达没到达的点（U），我们只能从已经建成的局部最短路点集V中选取V中所有已确定点能到达的所有其他点里面最小的来建设，有点贪心思想，每次选取代价最小的路，逐渐完善点，知道恰好覆盖所有的点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3fint G[1000][1000];//邻接矩阵存图int dis[1000];//存储最小距离（总的集合U里的）bool judge[1000];//判断该点是否已经加入最小点集合int pre[1000];//记录每个点的前导，用于输出路径int n,m;int prim(int a)&#123; int sum=0;//记录总和 int pos;//记录位置 int minn; judge[a]=1; pos=a; for(int i=1; i&lt;=n-1; i++) &#123; minn=INF; for(int j=1; j&lt;=n; j++) &#123; if(!judge[j]&amp;&amp;dis[j]&lt;minn) &#123; pos=j; minn=dis[j]; &#125; &#125; judge[pos]=1; sum+=minn; cout&lt;&lt;&quot;V&quot;&lt;&lt;pre[pos]&lt;&lt;&quot; -- &quot;&lt;&lt;&quot;V&quot;&lt;&lt;pos&lt;&lt;&quot; is &quot;&lt;&lt;minn&lt;&lt;endl; for(int j=1; j&lt;=n; j++) &#123; if(dis[j]&gt;G[pos][j]&amp;&amp;!judge[j]) &#123; dis[j]=G[pos][j]; pre[j]=pos; &#125; &#125; &#125; return sum;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(i==j) G[i][j]=0; else G[i][j]=INF; &#125; &#125; memset(judge,0,sizeof(judge)); for(int i=0; i&lt;m; i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; G[a][b]=G[b][a]=c; &#125; int s; cin&gt;&gt;s; for(int i=1; i&lt;=n; i++) &#123; pre[i]=s; dis[i]=G[s][i]; &#125; int k=prim(s); cout&lt;&lt;k&lt;&lt;endl; &#125; return 0;&#125;2.克鲁斯克尔（Kruskal）算法（加边法）算法思想：最小生成树最后一定是只有n-1条边！所以我们只要选取最小的n-1条边来吧n个点联通起来即可，但是注意不能产生回路，于是我们就用到了并查集！记Graph中有v个顶点，e条边；新建图Graphnew，Graphnew中拥有原图中的v个顶点，但没有边;将原图Graph中所有e条边按权值从小到大排序；循环：从权值最小的边开始，判断并添加每条边，直至添加了n-1条边：注意：加边的条件是不产生回路！即要连接的两定点不在一个集合里面！（并查集判断是否可以加边）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123; int s,e,v; bool operator &lt;(const Node &amp;n)const&#123; return v&lt;n.v; &#125;&#125;;Node node[1000];int pre[1000];int ranked[1000];int n,m;int finded(int v)//查找&#123; int i=v; while(i!=pre[i])//return pre[v]=v?v:pre[v]=find(pre[v]);//递归 i=pre[i]; int j; while(v!=i) &#123; j=pre[v]; pre[v]=i; v=j; &#125; return i;&#125;void join(int a,int b)//合并&#123; int fx=finded(a); int fy=finded(b); if(fx!=fy) &#123; if(ranked[fx]&lt;ranked[fy]) &#123; pre[fx]=fy; &#125; else &#123; pre[fy]=fx; if(ranked[fx]==ranked[fy]) ranked[fx]++; &#125; &#125;&#125;int Kruskal()&#123; sort(node,node+m); int sizen=0; int sum=0; for(int i=0;i&lt;m&amp;&amp;sizen!=n-1;i++) &#123; if(finded(node[i].s)!=finded(node[i].e)) &#123; join(node[i].s,node[i].e); sum+=node[i].v; sizen++; &#125; &#125; if(sizen&lt;n-1)return -1; return sum;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(ranked,0,sizeof(ranked)); for(int i=1;i&lt;=n;i++) &#123; pre[i]=i; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;node[i].s&gt;&gt;node[i].e&gt;&gt;node[i].v; &#125; int k=Kruskal(); cout&lt;&lt;k&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM模板]]></title>
    <url>%2F2019%2F06%2F02%2FACM%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ACM模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180218121822183218421852186218721882189219021912192219321942195219621972198219922002201220222032204220522062207220822092210221122122213221422152216221722182219222022212222222322242225222622272228222922302231223222332234223522362237223822392240224122422243224422452246224722482249225022512252225322542255225622572258225922602261226222632264226522662267226822692270227122722273227422752276227722782279228022812282228322842285228622872288228922902291229222932294229522962297229822992300230123022303230423052306230723082309231023112312231323142315231623172318231923202321232223232324232523262327232823292330233123322333233423352336233723382339234023412342234323442345234623472348234923502351235223532354235523562357235823592360236123622363236423652366236723682369237023712372237323742375237623772378237923802381238223832384238523862387238823892390239123922393239423952396239723982399240024012402240324042405240624072408240924102411241224132414241524162417241824192420242124222423242424252426242724282429243024312432243324342435243624372438243924402441244224432444244524462447244824492450245124522453245424552456245724582459246024612462246324642465246624672468246924702471247224732474247524762477247824792480248124822483248424852486248724882489249024912492249324942495249624972498249925002501250225032504250525062507250825092510251125122513251425152516251725182519252025212522252325242525252625272528252925302531253225332534253525362537253825392540254125422543254425452546254725482549255025512552255325542555255625572558255925602561256225632564256525662567256825692570257125722573257425752576257725782579258025812582258325842585258625872588258925902591259225932594259525962597259825992600260126022603260426052606260726082609261026112612261326142615261626172618261926202621262226232624262526262627262826292630263126322633263426352636263726382639264026412642264326442645264626472648264926502651265226532654265526562657265826592660266126622663266426652666266726682669267026712672267326742675267626772678267926802681268226832684268526862687268826892690269126922693269426952696269726982699270027012702270327042705270627072708270927102711271227132714271527162717271827192720272127222723272427252726272727282729273027312732273327342735273627372738273927402741274227432744274527462747274827492750275127522753275427552756275727582759276027612762276327642765276627672768276927702771277227732774277527762777277827792780278127822783278427852786278727882789279027912792279327942795279627972798279928002801280228032804280528062807280828092810281128122813281428152816281728182819282028212822282328242825282628272828头文件#define _CRT_SBCURE_NO_DEPRECATE#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; &lt;!--more--&gt;using namespace std; const int maxn = 110;const int INF = 0x3f3f3f3f;经典1.埃拉托斯特尼筛法/* |埃式筛法| |快速筛选素数| |16/11/05ztx|*/ int prime[maxn];bool is_prime[maxn]; int sieve(int n)&#123; int p = 0; for(int i = 0; i &lt;= n; ++i) is_prime[i] = true; is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt;= n; ++i)&#123; // 注意数组大小是n if(is_prime[i])&#123; prime[p++] = i; for(int j = i + i; j &lt;= n; j += i) // 轻剪枝，j必定是i的倍数 is_prime[j] = false; &#125; &#125; return p; // 返回素数个数&#125;2.快速幂/* |快速幂| |16/11/05ztx|*/ typedef long long LL; // 视数据大小的情况而定 LL powerMod(LL x, LL n, LL m)&#123; LL res = 1; while (n &gt; 0)&#123; if (n &amp; 1) // 判断是否为奇数，若是则true res = (res * x) % m; x = (x * x) % m; n &gt;&gt;= 1; // 相当于n /= 2; &#125; return res;&#125;3.大数模拟大数加法/* |大数模拟加法| |用string模拟| |16/11/05ztx, thanks to caojiji|*/ string add1(string s1, string s2)&#123; if (s1 == "" &amp;&amp; s2 == "") return "0"; if (s1 == "") return s2; if (s2 == "") return s1; string maxx = s1, minn = s2; if (s1.length() &lt; s2.length())&#123; maxx = s2; minn = s1; &#125; int a = maxx.length() - 1, b = minn.length() - 1; for (int i = b; i &gt;= 0; --i)&#123; maxx[a--] += minn[i] - '0'; // a一直在减 ， 额外还要减个'0' &#125; for (int i = maxx.length()-1; i &gt; 0;--i)&#123; if (maxx[i] &gt; '9')&#123; maxx[i] -= 10;//注意这个是减10 maxx[i - 1]++; &#125; &#125; if (maxx[0] &gt; '9')&#123; maxx[0] -= 10; maxx = '1' + maxx; &#125; return maxx;&#125;大数阶乘/* |大数模拟阶乘| |用数组模拟| |16/12/02ztx|*/ #include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std; typedef long long LL; const int maxn = 100010; int num[maxn], len; /* 在mult函数中，形参部分：len每次调用函数都会发生改变，n表示每次要乘以的数，最终返回的是结果的长度 tip: 阶乘都是先求之前的(n-1)!来求n! 初始化Init函数很重要，不要落下*/ void Init() &#123; len = 1; num[0] = 1;&#125; int mult(int num[], int len, int n) &#123; LL tmp = 0; for(LL i = 0; i &lt; len; ++i) &#123; tmp = tmp + num[i] * n; //从最低位开始，等号左边的tmp表示当前位，右边的tmp表示进位（之前进的位） num[i] = tmp % 10; // 保存在对应的数组位置，即去掉进位后的一位数 tmp = tmp / 10; // 取整用于再次循环,与n和下一个位置的乘积相加 &#125; while(tmp) &#123; // 之后的进位处理 num[len++] = tmp % 10; tmp = tmp / 10; &#125; return len;&#125; int main() &#123; Init(); int n; n = 1977; // 求的阶乘数 for(int i = 2; i &lt;= n; ++i) &#123; len = mult(num, len, i); &#125; for(int i = len - 1; i &gt;= 0; --i) printf("%d",num[i]); // 从最高位依次输出,数据比较多采用printf输出 printf("\n"); return 0;&#125;4.GCD/* |辗转相除法| |欧几里得算法| |求最大公约数| |16/11/05ztx|*/ int gcd(int big, int small)&#123; if (small &gt; big) swap(big, small); int temp; while (small != 0)&#123; // 辗转相除法 if (small &gt; big) swap(big, small); temp = big % small; big = small; small = temp; &#125; return(big);&#125;5.LCM/* |辗转相除法| |欧几里得算法| |求最小公倍数| |16/11/05ztx|*/ int gcd(int big, int small)&#123; if (small &gt; big) swap(big, small); int temp; while (small != 0)&#123; // 辗转相除法 if (small &gt; big) swap(big, small); temp = big % small; big = small; small = temp; &#125; return(big);&#125;6.全排列/* |求1到n的全排列, 有条件| |16/11/05ztx, thanks to wangqiqi|*/ void Pern(int list[], int k, int n) &#123; // k表示前k个数不动仅移动后面n-k位数 if (k == n - 1) &#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d", list[i]); &#125; printf("\n"); &#125;else &#123; for (int i = k; i &lt; n; i++) &#123; // 输出的是满足移动条件所有全排列 swap(list[k], list[i]); Pern(list, k + 1, n); swap(list[k], list[i]); &#125; &#125;&#125;7.二分搜索/* |二分搜索| |要求：先排序| |16/11/05ztx, thanks to wangxiaocai|*/ // left为最开始元素, right是末尾元素的下一个数，x是要找的数int bsearch(int *A, int left, int right, int x)&#123; int m; while (left &lt; right)&#123; m = left + (right - left) / 2; if (A[m] &gt;= x) right = m; else left = m + 1; // 如果要替换为 upper_bound, 改为:if (A[m] &lt;= v) x = m+1; else y = m; &#125; return left;&#125; /* 最后left == right 如果没有找到135577找6，返回7 如果找有多少的x，可以用lower_bound查找一遍，upper_bound查找一遍，下标相减 C++自带的lower_bound(a,a+n,x)返回数组中最后一个x的下一个数的地址 upper_bound(a,a+n,x)返回数组中第一个x的地址 如果a+n内没有找到x或x的下一个地址，返回a+n的地址 lower_bound(a,a+n,x）-upper_bound(a,a+n,x)返回数组中x的个数*/数据结构并查集8.并查集/* |合并节点操作| |16/11/05ztx, thanks to chaixiaojun|*/ int father[maxn]; // 储存i的father父节点 void makeSet() &#123; for (int i = 0; i &lt; maxn; i++) father[i] = i;&#125; int findRoot(int x) &#123; // 迭代找根节点 int root = x; // 根节点 while (root != father[root]) &#123; // 寻找根节点 root = father[root]; &#125; while (x != root) &#123; int tmp = father[x]; father[x] = root; // 根节点赋值 x = tmp; &#125; return root;&#125; void Union(int x, int y) &#123; // 将x所在的集合和y所在的集合整合起来形成一个集合。 int a, b; a = findRoot(x); b = findRoot(y); father[a] = b; // y连在x的根节点上 或father[b] = a为x连在y的根节点上；&#125; /* 在findRoot(x)中： 路径压缩 迭代 最优版 关键在于在路径上的每个节点都可以直接连接到根上*/图论MST最小生成树Kruskal9.克鲁斯卡尔算法/* |Kruskal算法| |适用于 稀疏图 求最小生成树| |16/11/05ztx thanks to wangqiqi|*/ /* 第一步：点、边、加入vector，把所有边按从小到大排序 第二步：并查集部分 + 下面的code*/ void Kruskal() &#123; ans = 0; for (int i = 0; i&lt;len; i++) &#123; if (Find(edge[i].a) != Find(edge[i].b)) &#123; Union(edge[i].a, edge[i].b); ans += edge[i].len; &#125; &#125;&#125;Prim10.普里姆算法/* |Prim算法| |适用于 稠密图 求最小生成树| |堆优化版，时间复杂度：O(elgn)| |16/11/05ztx, thanks to chaixiaojun|*/ struct node &#123; int v, len; node(int v = 0, int len = 0) :v(v), len(len) &#123;&#125; bool operator &lt; (const node &amp;a)const &#123; // 加入队列的元素自动按距离从小到大排序 return len&gt; a.len; &#125;&#125;; vector&lt;node&gt; G[maxn];int vis[maxn];int dis[maxn]; void init() &#123; for (int i = 0; i&lt;maxn; i++) &#123; G[i].clear(); dis[i] = INF; vis[i] = false; &#125;&#125;int Prim(int s) &#123; priority_queue&lt;node&gt;Q; // 定义优先队列 int ans = 0; Q.push(node(s,0)); // 起点加入队列 while (!Q.empty()) &#123; node now = Q.top(); Q.pop(); // 取出距离最小的点 int v = now.v; if (vis[v]) continue; // 同一个节点，可能会推入2次或2次以上队列，这样第一个被标记后，剩下的需要直接跳过。 vis[v] = true; // 标记一下 ans += now.len; for (int i = 0; i&lt;G[v].size(); i++) &#123; // 开始更新 int v2 = G[v][i].v; int len = G[v][i].len; if (!vis[v2] &amp;&amp; dis[v2] &gt; len) &#123; dis[v2] = len; Q.push(node(v2, dis[v2])); // 更新的点加入队列并排序 &#125; &#125; &#125; return ans;&#125;Bellman-Ford单源最短路Dijkstra11.迪杰斯特拉算法/* |Dijkstra算法| |适用于边权为正的有向图或者无向图| |求从单个源点出发，到所有节点的最短路| |优化版：时间复杂度 O(elbn)| |16/11/05ztx, thanks to chaixiaojun|*/ struct node &#123; int v, len; node(int v = 0, int len = 0) :v(v), len(len) &#123;&#125; bool operator &lt; (const node &amp;a)const &#123; // 距离从小到大排序 return len &gt; a.len; &#125;&#125;; vector&lt;node&gt;G[maxn];bool vis[maxn];int dis[maxn]; void init() &#123; for (int i = 0; i&lt;maxn; i++) &#123; G[i].clear(); vis[i] = false; dis[i] = INF; &#125;&#125;int dijkstra(int s, int e) &#123; priority_queue&lt;node&gt;Q; Q.push(node(s, 0)); // 加入队列并排序 dis[s] = 0; while (!Q.empty()) &#123; node now = Q.top(); // 取出当前最小的 Q.pop(); int v = now.v; if (vis[v]) continue; // 如果标记过了, 直接continue vis[v] = true; for (int i = 0; i&lt;G[v].size(); i++) &#123; // 更新 int v2 = G[v][i].v; int len = G[v][i].len; if (!vis[v2] &amp;&amp; dis[v2] &gt; dis[v] + len) &#123; dis[v2] = dis[v] + len; Q.push(node(v2, dis[v2])); &#125; &#125; &#125; return dis[e];&#125;SPFA12.最短路径快速算法（Shortest Path Faster Algorithm）/* |SPFA算法| |队列优化| |可处理负环|*/ vector&lt;node&gt; G[maxn];bool inqueue[maxn];int dist[maxn]; void Init()&#123; for(int i = 0 ; i &lt; maxn ; ++i)&#123; G[i].clear(); dist[i] = INF; &#125;&#125;int SPFA(int s,int e)&#123; int v1,v2,weight; queue&lt;int&gt; Q; memset(inqueue,false,sizeof(inqueue)); // 标记是否在队列中 memset(cnt,0,sizeof(cnt)); // 加入队列的次数 dist[s] = 0; Q.push(s); // 起点加入队列 inqueue[s] = true; // 标记 while(!Q.empty())&#123; v1 = Q.front(); Q.pop(); inqueue[v1] = false; // 取消标记 for(int i = 0 ; i &lt; G[v1].size() ; ++i)&#123; // 搜索v1的链表 v2 = G[v1][i].vex; weight = G[v1][i].weight; if(dist[v2] &gt; dist[v1] + weight)&#123; // 松弛操作 dist[v2] = dist[v1] + weight; if(inqueue[v2] == false)&#123; // 再次加入队列 inqueue[v2] = true; //cnt[v2]++; // 判负环 //if(cnt[v2] &gt; n) return -1; Q.push(v2); &#125; &#125; &#125; &#125; return dist[e];&#125; /* 不断的将s的邻接点加入队列，取出不断的进行松弛操作，直到队列为空 如果一个结点被加入队列超过n-1次，那么显然图中有负环*/Floyd-Warshall13.弗洛伊德算法/* |Floyd算法| |任意点对最短路算法| |求图中任意两点的最短距离的算法|*/ for (int i = 0; i &lt; n; i++) &#123; // 初始化为0 for (int j = 0; j &lt; n; j++) scanf("%lf", &amp;dis[i][j]);&#125;for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125;&#125;二分图14.染色法/* |交叉染色法判断二分图| |16/11/05ztx|*/ int bipartite(int s) &#123; int u, v; queue&lt;int&gt;Q; color[s] = 1; Q.push(s); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; v = G[u][i]; if (color[v] == 0) &#123; color[v] = -color[u]; Q.push(v); &#125; else if (color[v] == color[u]) return 0; &#125; &#125; return 1;&#125;15..匈牙利算法/* |求解最大匹配问题| |递归实现| |16/11/05ztx|*/ vector&lt;int&gt;G[maxn];bool inpath[maxn]; // 标记int match[maxn]; // 记录匹配对象void init()&#123; memset(match, -1, sizeof(match)); for (int i = 0; i &lt; maxn; ++i) &#123; G[i].clear(); &#125;&#125;bool findpath(int k) &#123; for (int i = 0; i &lt; G[k].size(); ++i) &#123; int v = G[k][i]; if (!inpath[v]) &#123; inpath[v] = true; if (match[v] == -1 || findpath(match[v])) &#123; // 递归 match[v] = k; // 即匹配对象是“k妹子”的 return true; &#125; &#125; &#125; return false;&#125; void hungary() &#123; int cnt = 0; for (int i = 1; i &lt;= m; i++) &#123; // m为需要匹配的“妹子”数 memset(inpath, false, sizeof(inpath)); // 每次都要初始化 if (findpath(i)) cnt++; &#125; cout &lt;&lt; cnt &lt;&lt; endl;&#125;/* |求解最大匹配问题| |dfs实现| |16/11/05ztx|*/ int v1, v2;bool Map[501][501];bool visit[501];int link[501];int result; bool dfs(int x) &#123; for (int y = 1; y &lt;= v2; ++y) &#123; if (Map[x][y] &amp;&amp; !visit[y]) &#123; visit[y] = true; if (link[y] == 0 || dfs(link[y])) &#123; link[y] = x; return true; &#125; &#125; &#125; return false;&#125; void Search() &#123; for (int x = 1; x &lt;= v1; x++) &#123; memset(visit,false,sizeof(visit)); if (dfs(x)) result++; &#125;&#125;动态规划背包16.17.18背包问题/* |01背包| |完全背包| |多重背包| |16/11/05ztx|*/ // 01背包： void bag01(int cost,int weight) &#123; for(i = v; i &gt;= cost; --i) dp[i] = max(dp[i], dp[i-cost]+weight);&#125; // 完全背包： void complete(int cost, int weight) &#123; for(i = cost ; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - cost] + weight);&#125; // 多重背包： void multiply(int cost, int weight, int amount) &#123; if(cost * amount &gt;= v) complete(cost, weight); else&#123; k = 1; while (k &lt; amount)&#123; bag01(k * cost, k * weight); amount -= k; k += k; &#125; bag01(cost * amount, weight * amount); &#125;&#125; // other int dp[1000000];int c[55], m[110];int sum; void CompletePack(int c) &#123; for (int v = c; v &lt;= sum / 2; ++v)&#123; dp[v] = max(dp[v], dp[v - c] + c); &#125;&#125; void ZeroOnePack(int c) &#123; for (int v = sum / 2; v &gt;= c; --v) &#123; dp[v] = max(dp[v], dp[v - c] + c); &#125;&#125; void multiplePack(int c, int m） &#123; if (m * c &gt; sum / 2) CompletePack(c); else&#123; int k = 1; while (k &lt; m)&#123; ZeroOnePack(k * c); m -= k; k &lt;&lt;= 1; &#125; if (m != 0)&#123; ZeroOnePack(m * c); &#125; &#125;&#125;LIS19.最长上升子序列/* |最长上升子序列| |状态转移| |16/11/05ztx|*/ /* 状态转移dp[i] = max&#123; 1.dp[j] + 1 &#125;; j&lt;i; a[j]&lt;a[i]; d[i]是以i结尾的最长上升子序列 与i之前的 每个a[j]&lt;a[i]的 j的位置的最长上升子序列+1后的值比较*/ void solve()&#123; // 参考挑战程序设计入门经典; for(int i = 0; i &lt; n; ++i)&#123; dp[i] = 1; for(int j = 0; j &lt; i; ++j)&#123; if(a[j] &lt; a[i])&#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125;&#125; /* 优化方法： dp[i]表示长度为i+1的上升子序列的最末尾元素 找到第一个比dp末尾大的来代替*/ void solve() &#123; for (int i = 0; i &lt; n; ++i)&#123; dp[i] = INF; &#125; for (int i = 0; i &lt; n; ++i) &#123; *lower_bound(dp, dp + n, a[i]) = a[i]; // 返回一个指针 &#125; printf("%d\n", *lower_bound(dp, dp + n, INF) - dp; &#125; /* 函数lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value的值。*/LCS20.最长公共子序列/* |求最长公共子序列| |递推形式| |16/11/05ztx|*/ void solve() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (s1[i] == s2[j]) &#123; dp[i + 1][j + 1] = dp[i][j] + 1; &#125;else &#123; dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; &#125;&#125;计算几何21.向量基本用法/* |16/11/06ztx|*/ struct node &#123; double x; // 横坐标 double y; // 纵坐标&#125;; typedef node Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Point A, Point B) &#123; return Vector(A.x - B.y, A.y - B.y); &#125;Vector operator * (Vector A, double p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, double p) &#123; return Vector(A.x / p, A.y*p); &#125; double Dot(Vector A, Vector B) &#123; return A.x*B.x + A.y*B.y; &#125; // 向量点乘double Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125; // 向量模长double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125; // 向量之间夹角 double Cross(Vector A, Vector B) &#123; // 叉积计算 公式 return A.x*B.y - A.y*B.x;&#125; Vector Rotate(Vector A, double rad) // 向量旋转 公式 &#123; return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y*cos(rad));&#125; Point getLineIntersection(Point P, Vector v, Point Q, Vector w) &#123; // 两直线交点t1 t2计算公式 Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); // 求得是横坐标 return P + v*t; // 返回一个点&#125;22.求多边形面积/* |16/11/06ztx|*/ node G[maxn];int n; double Cross(node a, node b) &#123; // 叉积计算 return a.x*b.y - a.y*b.x;&#125; int main()&#123; while (scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; for (int i = 0; i &lt; n; i++) scanf("%lf %lf", &amp;G[i].x, &amp;G[i].y); double sum = 0; G[n].x = G[0].x; G[n].y = G[0].y; for (int i = 0; i &lt; n; i++) &#123; sum += Cross(G[i], G[i + 1]); &#125; // 或者 //for (int i = 0; i &lt; n; i++) &#123; //sum += fun(G[i], G[（i + 1）% n]); //&#125; sum = sum / 2.0; printf("%.1f\n", sum); &#125; system("pause"); return 0;&#125;23..判断线段相交/* |16/11/06ztx|*/ node P[35][105]; double Cross_Prouct(node A,node B,node C) &#123; // 计算BA叉乘CA return (B.x-A.x)*(C.y-A.y)-(B.y-A.y)*(C.x-A.x);&#125;bool Intersect(node A,node B,node C,node D) &#123; // 通过叉乘判断线段是否相交； if(min(A.x,B.x)&lt;=max(C.x,D.x)&amp;&amp; // 快速排斥实验； min(C.x,D.x)&lt;=max(A.x,B.x)&amp;&amp; min(A.y,B.y)&lt;=max(C.y,D.y)&amp;&amp; min(C.y,D.y)&lt;=max(A.y,B.y)&amp;&amp; Cross_Prouct(A,B,C)*Cross_Prouct(A,B,D)&lt;0&amp;&amp; // 跨立实验； Cross_Prouct(C,D,A)*Cross_Prouct(C,D,B)&lt;0) // 叉乘异号表示在两侧； return true; else return false;&#125;24.求三角形外心/* |16/11/06ztx|*/ Point circumcenter(const Point &amp;a, const Point &amp;b, const Point &amp;c) &#123; //返回三角形的外心 Point ret; double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1*a1 + b1*b1) / 2; double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2*a2 + b2*b2) / 2; double d = a1*b2 - a2*b1; ret.x = a.x + (c1*b2 - c2*b1) / d; ret.y = a.y + (a1*c2 - a2*c1) / d; return ret;&#125;24.极角排序/* |16/11/06ztx|*/ double cross(point p1, point p2, point q1, point q2) &#123; // 叉积计算 return (q2.y - q1.y)*(p2.x - p1.x) - (q2.x - q1.x)*(p2.y - p1.y);&#125;bool cmp(point a, point b) &#123; point o; o.x = o.y = 0; return cross(o, b, o, a) &lt; 0; // 叉积判断&#125;sort(convex + 1, convex + cnt, cmp); // 按角排序, 从小到大字符串kmp25.克努特-莫里斯-普拉特操作/* |kmp算法| |字符串匹配| |17/1/21ztx|*/ void getnext(char str[maxn], int nextt[maxn]) &#123; int j = 0, k = -1; nextt[0] = -1; while (j &lt; m) &#123; if (k == -1 || str[j] == str[k]) &#123; j++; k++; nextt[j] = k; &#125; else k = nextt[k]; &#125;&#125; void kmp(int a[maxn], int b[maxn]) &#123; int nextt[maxm]; int i = 0, j = 0; getnext(b, nextt); while (i &lt; n) &#123; if (j == -1 || a[i] == b[j]) &#123; // 母串不动，子串移动 j++; i++; &#125; else &#123; // i不需要回溯了 // i = i - j + 1; j = nextt[j]; &#125; if (j == m) &#123; printf("%d\n", i - m + 1); // 母串的位置减去子串的长度+1 return; &#125; &#125; printf("-1\n");&#125;26.kmp扩展/* |16/11/06ztx|*/ #include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std; const int MM=100005; int next[MM],extand[MM];char S[MM],T[MM]; void GetNext(const char *T) &#123; int len = strlen(T),a = 0; next[0] = len; while(a &lt; len - 1 &amp;&amp; T[a] == T[a + 1]) a++; next[1] = a; a = 1; for(int k = 2; k &lt; len; k ++) &#123; int p = a + next[a] - 1,L = next[k - a]; if( (k - 1) + L &gt;= p) &#123; int j = (p - k + 1) &gt; 0 ? (p - k + 1) : 0; while(k + j &lt; len &amp;&amp; T[k + j] == T[j]) j++; next[k] = j; a = k; &#125;else next[k] = L; &#125;&#125;void GetExtand(const char *S,const char *T) &#123; GetNext(T); int slen = strlen(S),tlen = strlen(T),a = 0; int MinLen = slen &lt; tlen ? slen : tlen; while(a &lt; MinLen &amp;&amp; S[a] == T[a]) a++; extand[0] = a; a = 0; for(int k = 1; k &lt; slen; k ++) &#123; int p = a + extand[a] - 1, L = next[k - a]; if( (k - 1) + L &gt;= p) &#123; int j = (p - k + 1) &gt; 0 ? (p - k + 1) : 0; while(k + j &lt; slen &amp;&amp; j &lt; tlen &amp;&amp; S[k + j] == T[j]) j ++; extand[k] = j; a = k; &#125; else extand[k] = L; &#125;&#125;void show(const int *s,int len)&#123; for(int i = 0; i &lt; len; i ++) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; int main() &#123; while(cin &gt;&gt; S &gt;&gt; T) &#123; GetExtand(S,T); show(next,strlen(T)); show(extand,strlen(S)); &#125; return 0;&#125;字典树27.字典树/* |16/11/06ztx|*/ struct Trie&#123; int cnt; Trie *next[maxn]; Trie()&#123; cnt = 0; memset(next,0,sizeof(next)); &#125;&#125;; Trie *root; void Insert(char *word) &#123; Trie *tem = root; while(*word != '\0') &#123; int x = *word - 'a'; if(tem-&gt;next[x] == NULL) tem-&gt;next[x] = new Trie; tem = tem-&gt;next[x]; tem-&gt;cnt++; word++; &#125;&#125; int Search(char *word) &#123; Trie *tem = root; for(int i=0;word[i]!='\0';i++) &#123; int x = word[i]-'a'; if(tem-&gt;next[x] == NULL) return 0; tem = tem-&gt;next[x]; &#125; return tem-&gt;cnt;&#125; void Delete(char *word,int t) &#123; Trie *tem = root; for(int i=0;word[i]!='\0';i++) &#123; int x = word[i]-'a'; tem = tem-&gt;next[x]; (tem-&gt;cnt)-=t; &#125; for(int i=0;i&lt;maxn;i++) tem-&gt;next[i] = NULL;&#125; int main() &#123; int n; char str1[50]; char str2[50]; while(scanf("%d",&amp;n)!=EOF) &#123; root = new Trie; while(n--) &#123; scanf("%s %s",str1,str2); if(str1[0]=='i') &#123; Insert(str2); &#125;else if(str1[0] == 's') &#123; if(Search(str2)) printf("Yes\n"); else printf("No\n"); &#125;else &#123; int t = Search(str2); if(t) Delete(str2,t); &#125; &#125; &#125; return 0;&#125;28.AC自动机/* |16/11/06ztx|*/ #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt; using namespace std; #define N 1000010 char str[N], keyword[N];int head, tail; struct node &#123; node *fail; node *next[26]; int count; node() &#123; //init fail = NULL;// 默认为空 count = 0; for(int i = 0; i &lt; 26; ++i) next[i] = NULL; &#125;&#125;*q[N]; node *root; void insert(char *str) &#123; // 建立Trie int temp, len; node *p = root; len = strlen(str); for(int i = 0; i &lt; len; ++i) &#123; temp = str[i] - 'a'; if(p-&gt;next[temp] == NULL) p-&gt;next[temp] = new node(); p = p-&gt;next[temp]; &#125; p-&gt;count++;&#125; void build_ac() &#123; // 初始化fail指针，BFS 数组模拟队列： q[tail++] = root; while(head != tail) &#123; node *p = q[head++]; // 弹出队头 node *temp = NULL; for(int i = 0; i &lt; 26; ++i) &#123; if(p-&gt;next[i] != NULL) &#123; if(p == root) &#123; // 第一个元素fail必指向根 p-&gt;next[i]-&gt;fail = root; &#125;else &#123; temp = p-&gt;fail; // 失败指针 while(temp != NULL) &#123; // 2种情况结束：匹配为空or找到匹配 if(temp-&gt;next[i] != NULL) &#123; // 找到匹配 p-&gt;next[i]-&gt;fail = temp-&gt;next[i]; break; &#125; temp = temp-&gt;fail; &#125; if(temp == NULL) // 为空则从头匹配 p-&gt;next[i]-&gt;fail = root; &#125; q[tail++] = p-&gt;next[i]; // 入队 &#125; &#125; &#125;&#125; int query() // 扫描&#123; int index, len, result; node *p = root; // Tire入口 result = 0; len = strlen(str); for(int i = 0; i &lt; len; ++i) &#123; index = str[i] - 'a'; while(p-&gt;next[index] == NULL &amp;&amp; p != root) // 跳转失败指针 p = p-&gt;fail; p = p-&gt;next[index]; if(p == NULL) p = root; node *temp = p; // p不动，temp计算后缀串 while(temp != root &amp;&amp; temp-&gt;count != -1) &#123; result += temp-&gt;count; temp-&gt;count = -1; temp = temp-&gt;fail; &#125; &#125; return result;&#125; int main() &#123; int num; head= tail = 0; root = new node(); scanf("%d", &amp;num); getchar(); for(int i = 0; i &lt; num; ++i) &#123; scanf("%s",keyword); insert(keyword); &#125; build_ac(); scanf("%s", str); if(query()) printf("YES\n"); else printf("NO\n"); return 0;&#125; /* 假设有N个模式串，平均长度为L；文章长度为M。 建立Trie树：O(N*L) 建立fail指针：O(N*L) 模式匹配：O(M*L) 所以，总时间复杂度为:O( (N+M)*L )。*/线段树29.线段树1）点更新/* |16/12/07ztx|*/ struct node&#123; int left, right; int max, sum;&#125;; node tree[maxn &lt;&lt; 2];int a[maxn];int n;int k = 1;int p, q;string str; void build(int m, int l, int r)//m 是 树的标号&#123; tree[m].left = l; tree[m].right = r; if (l == r)&#123; tree[m].max = a[l]; tree[m].sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(m &lt;&lt; 1, l, mid); build(m &lt;&lt; 1 | 1, mid + 1, r); tree[m].max = max(tree[m &lt;&lt; 1].max, tree[m &lt;&lt; 1 | 1].max); tree[m].sum = tree[m &lt;&lt; 1].sum + tree[m &lt;&lt; 1 | 1].sum;&#125; void update(int m, int a, int val)//a 是 节点位置， val 是 更新的值（加减的值）&#123; if (tree[m].left == a &amp;&amp; tree[m].right == a)&#123; tree[m].max += val; tree[m].sum += val; return; &#125; int mid = (tree[m].left + tree[m].right) &gt;&gt; 1; if (a &lt;= mid)&#123; update(m &lt;&lt; 1, a, val); &#125; else&#123; update(m &lt;&lt; 1 | 1, a, val); &#125; tree[m].max = max(tree[m &lt;&lt; 1].max, tree[m &lt;&lt; 1 | 1].max); tree[m].sum = tree[m &lt;&lt; 1].sum + tree[m &lt;&lt; 1 | 1].sum;&#125; int querySum(int m, int l, int r)&#123; if (l == tree[m].left &amp;&amp; r == tree[m].right)&#123; return tree[m].sum; &#125; int mid = (tree[m].left + tree[m].right) &gt;&gt; 1; if (r &lt;= mid)&#123; return querySum(m &lt;&lt; 1, l, r); &#125; else if (l &gt; mid)&#123; return querySum(m &lt;&lt; 1 | 1, l, r); &#125; return querySum(m &lt;&lt; 1, l, mid) + querySum(m &lt;&lt; 1 | 1, mid + 1, r);&#125; int queryMax(int m, int l, int r)&#123; if (l == tree[m].left &amp;&amp; r == tree[m].right)&#123; return tree[m].max; &#125; int mid = (tree[m].left + tree[m].right) &gt;&gt; 1; if (r &lt;= mid)&#123; return queryMax(m &lt;&lt; 1, l, r); &#125; else if (l &gt; mid)&#123; return queryMax(m &lt;&lt; 1 | 1, l, r); &#125; return max(queryMax(m &lt;&lt; 1, l, mid), queryMax(m &lt;&lt; 1 | 1, mid + 1, r));&#125; build(1,1,n);update(1,a,b);query(1,a,b);2)区间更新/* |16/11/06ztx|*/ typedef long long ll;const int maxn = 100010; int t,n,q;ll anssum; struct node&#123; ll l,r; ll addv,sum;&#125;tree[maxn&lt;&lt;2]; void maintain(int id) &#123; if(tree[id].l &gt;= tree[id].r) return ; tree[id].sum = tree[id&lt;&lt;1].sum + tree[id&lt;&lt;1|1].sum;&#125; void pushdown(int id) &#123; if(tree[id].l &gt;= tree[id].r) return ; if(tree[id].addv)&#123; int tmp = tree[id].addv; tree[id&lt;&lt;1].addv += tmp; tree[id&lt;&lt;1|1].addv += tmp; tree[id&lt;&lt;1].sum += (tree[id&lt;&lt;1].r - tree[id&lt;&lt;1].l + 1)*tmp; tree[id&lt;&lt;1|1].sum += (tree[id&lt;&lt;1|1].r - tree[id&lt;&lt;1|1].l + 1)*tmp; tree[id].addv = 0; &#125;&#125; void build(int id,ll l,ll r) &#123; tree[id].l = l; tree[id].r = r; tree[id].addv = 0; tree[id].sum = 0; if(l==r) &#123; tree[id].sum = 0; return ; &#125; ll mid = (l+r)&gt;&gt;1; build(id&lt;&lt;1,l,mid); build(id&lt;&lt;1|1,mid+1,r); maintain(id);&#125; void updateAdd(int id,ll l,ll r,ll val) &#123; if(tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r) &#123; tree[id].addv += val; tree[id].sum += (tree[id].r - tree[id].l+1)*val; return ; &#125; pushdown(id); ll mid = (tree[id].l+tree[id].r)&gt;&gt;1; if(l &lt;= mid) updateAdd(id&lt;&lt;1,l,r,val); if(mid &lt; r) updateAdd(id&lt;&lt;1|1,l,r,val); maintain(id);&#125; void query(int id,ll l,ll r) &#123; if(tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r)&#123; anssum += tree[id].sum; return ; &#125; pushdown(id); ll mid = (tree[id].l + tree[id].r)&gt;&gt;1; if(l &lt;= mid) query(id&lt;&lt;1,l,r); if(mid &lt; r) query(id&lt;&lt;1|1,l,r); maintain(id);&#125; int main() &#123; scanf("%d",&amp;t); int kase = 0 ; while(t--)&#123; scanf("%d %d",&amp;n,&amp;q); build(1,1,n); int id; ll x,y; ll val; printf("Case %d:\n",++kase); while(q--)&#123; scanf("%d",&amp;id); if(id==0)&#123; scanf("%lld %lld %lld",&amp;x,&amp;y,&amp;val); updateAdd(1,x+1,y+1,val); &#125; else&#123; scanf("%lld %lld",&amp;x,&amp;y); anssum = 0; query(1,x+1,y+1); printf("%lld\n",anssum); &#125; &#125; &#125; return 0;&#125;30.树状数组/* |16/11/06ztx|*/ #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt; using namespace std; typedef long long ll; const int maxn = 50005; int a[maxn];int n; int lowbit(const int t) &#123; return t &amp; (-t);&#125; void insert(int t, int d) &#123; while (t &lt;= n)&#123; a[t] += d; t = t + lowbit(t); &#125;&#125; ll getSum(int t) &#123; ll sum = 0; while (t &gt; 0)&#123; sum += a[t]; t = t - lowbit(t); &#125; return sum;&#125; int main() &#123; int t, k, d; scanf("%d", &amp;t); k= 1; while (t--)&#123; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;d); insert(i, d); &#125; string str; printf("Case %d:\n", k++); while (cin &gt;&gt; str) &#123; if (str == "End") break; int x, y; scanf("%d %d", &amp;x, &amp;y); if (str == "Query") printf("%lld\n", getSum(y) - getSum(x - 1)); else if (str == "Add") insert(x, y); else if (str == "Sub") insert(x, -y); &#125; &#125; return 0;&#125;其他31.中国剩余定理（孙子定理）/* |16/11/06ztx|*/ int CRT(int a[],int m[],int n) &#123; int M = 1; int ans = 0; for(int i=1; i&lt;=n; i++) M *= m[i]; for(int i=1; i&lt;=n; i++) &#123; int x, y; int Mi = M / m[i]; extend_Euclid(Mi, m[i], x, y); ans = (ans + Mi * x * a[i]) % M; &#125; if(ans &lt; 0) ans += M; return ans;&#125; void extend_Euclid(int a, int b, int &amp;x, int &amp;y) &#123; if(b == 0) &#123; x = 1; y = 0; return; &#125; extend_Euclid(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a / b) * y;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径主要思想12345678Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，此时完成一个顶点然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。实例：HDUOJ2544 四种不同算法理解最短路径1.迪杰斯特拉(Dijkstra)算法算法原理：123原理：这里不进行严格证明，Dijkstra的大致思想就是，根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//代码实现:#include &lt;iostream&gt;using namespace std;const int Inf = 1e9;int Map[100 + 10][100 + 10];//存储权值的，即Map[i][j] 有i到j的距离 int flag[100 + 10];//存储的是个个点是否已经找到最短路径 int dis[100 + 10];//由初始点到各个点的最短路径 int dj(int m) &#123; int Max = Inf; int dy = 0; for (int i = 1; i &lt;= m; i++) &#123;//一共m个点一个一个找 for (int k = 1; k &lt;= m; k++) &#123;//找到现在为止离初始点最短的距离 if (Map[1][k] &lt; Max &amp;&amp; !flag[k]) &#123; Max = Map[1][k];//记录大小 dy = k;//记录位置 &#125; &#125; flag[dy] = 1;//表示该点已经找到最短路径 dis[dy] = Map[1][dy];//存储最最短路径 for (int k = 1; k &lt;= m; k++) &#123; //找到经过dy点且在dy临近的点离初始点的最短距离 if (!flag[k]&amp;&amp;Map[1][k] &gt; dis[dy] + Map[dy][k]) &#123; Map[1][k] = dis[dy] + Map[dy][k]; &#125; &#125; dy = 0; Max = Inf; &#125; return dis[m];&#125;int main() &#123; int m, n, a, b, c, s; while (cin &gt;&gt; m &gt;&gt; n &amp;&amp; m || n) &#123; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; Map[i][j] = Inf; &#125; &#125; memset(flag, 0, sizeof(flag)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (Map[a][b] &gt; c) &#123; Map[a][b] = c; Map[b][a] = c; &#125; &#125; cout &lt;&lt; dj(m) &lt;&lt; endl; &#125; return 0;&#125;另一种写法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273思想：每次找到离源点（如1号结点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。步骤：1.开容器v，储存子节点、距离、花费；2、开数组dis记录起始点到各点距离；3、进行n-1次松弛操作（先找出未标记点中离起始点最近的点，标记该点，然后求出该点子节点到起始点的最短距离（优先）与最短花费）；4、输出到终点的最短距离与花费；#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define N 999999999using namespace std;struct node&#123; int er,len,cost;&#125;;vector&lt;node&gt;v[1111];int main()&#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; int dis[1111],spend[1111]; bool vis[1111]; node tmp; int x,y; for(int i=0;i&lt;1111;i++) v[i].clear(); while(m--)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;tmp.len,&amp;tmp.cost); tmp.er=x; v[y].push_back(tmp); tmp.er=y; v[x].push_back(tmp); &#125; scanf(&quot;%d%d&quot;,&amp;x,&amp;y);//起点和终点 for(int i=1;i&lt;=n;i++)&#123; vis[i]=0; dis[i]=spend[i]=N; &#125; for(int i=0;i&lt;v[x].size();i++)&#123; dis[v[x][i].er]=v[x][i].len; spend[v[x][i].er]=v[x][i].cost; &#125; vis[x]=1; for(int k=1;k&lt;=n-1;k++) &#123; int id,mi=N; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;dis[i]&lt;mi)&#123;//查询并记录离x最近的点 id=i;mi=dis[i]; &#125; &#125; vis[id]=1;//标记过的点已经是最短 for(int i=0;i&lt;v[id].size();i++) &#123; int vv=v[id][i].er; if(!vis[vv]&amp;&amp;dis[vv]&gt;dis[id]+v[id][i].len)//未标记、直接距离大于通过id点的距离 dis[vv]=dis[id]+v[id][i].len, spend[vv]=spend[id]+v[id][i].cost; else if(!vis[vv]&amp;&amp;dis[vv]==dis[id]+v[id][i].len&amp;&amp;spend[vv]&gt;spend[vv]+v[id][i].cost)//未标记、距离相等找花费更小的 spend[vv]=spend[id]+v[id][i].cost; &#125; &#125; printf(&quot;%d %d\n&quot;,dis[y],spend[y]); &#125; return 0;&#125;2.Floyd算法弗洛伊德算法（解决多源最短路径）：时间复杂度O(n^3),空间复杂度O(n^2)12345678910111213141516171819202122232425262728293031323334353637思想：最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转......允许经过1~n号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。即求从i号顶点到j号顶点只经过前k号点的最短路程。#include&lt;iostream&gt;#include&lt;string.h&gt;#define inf 99999999using namespace std;int n,dis[111][111];void init()&#123; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++) dis[i][j]=inf; dis[i][i]=0; &#125;&#125;int main()&#123; int m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; init(); while(m--)&#123; int x,y,len; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); dis[x][y]=min(dis[x][y],len); dis[y][x]=dis[x][y]; &#125; for(int k=1;k&lt;=n;k++)//要经过的点 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); printf(&quot;%d\n&quot;,dis[1][n]);//可以选任意两点之间的距离 &#125; return 0;&#125;3.DFS/BFS算法深度或广度优先搜索算法（解决单源最短路径）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263从起始结点开始访问所有的深度遍历路径或广度优先路径，则到达终点结点的路径有多条，取其中路径权值最短的一条则为最短路径。给定一个带权有向图G=（V,E），其中每条边的权是一个实数。另外，还给定V中的一个顶点，称为源。现在要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 [1] 问题。从起始结点开始访问所有的深度遍历路径或广度优先路径，则到达终点结点的路径有多条，取其中路径权值最短的一条则为最短路径#include&lt;iostream&gt;#include&lt;string.h&gt;#define inf 99999999using namespace std;int dis[111][111];bool vis[111];int n,cnt;//n为节点数,cnt为最短长度void init(int x)&#123; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++) dis[i][j]=inf; dis[i][i]=0; vis[i]=0; &#125;&#125;void dfs(int st,int dst)&#123; if(dst&gt;cnt)return ;//距离大于最短路径，无需遍历 if(st==n)&#123;//到达终点 cnt=cnt&gt;dst?dst:cnt; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(!vis[i]&amp;&amp;dis[st][i]!=inf&amp;&amp;dis[st][i])&#123; vis[i]=1; dfs(i,dst+dis[st][i]); vis[i]=0; &#125; &#125;&#125;int main()&#123; int m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; int x,y,len; cnt=inf; init(n); while(m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); dis[x][y]=min(dis[x][y],len);//两点之间距离重复输入取小距离 dis[y][x]=dis[x][y]; &#125; vis[1]=1; dfs(1,0); printf(&quot;%d\n&quot;,cnt); &#125; return 0;&#125;4.Bellman-FordBellman-Ford算法(解决负权边，解决单源最短路径，前几种方法不能求含负权边的图)：：时间复杂度O(nm),空间复杂度O(m)1234主要思想：对所有的边进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。换句话说，第1轮在对所有的边进行松弛后，得到的是从1号顶点只能经过一条边到达其余各定点的最短路径长度。第2轮在对所有的边进行松弛后，得到的是从1号顶点只能经过两条边到达其余各定点的最短路径长度，......代码待补]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM题]]></title>
    <url>%2F2019%2F05%2F22%2F%E9%A2%98%E7%9B%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目集将用来集中题目和提高自己的能力奉上一段千古名句：模拟只会猜题意，贪心只能过样例。数学上来先打表，DP 一般看规律。组合数学靠运气，计算几何瞎暴力。图论一顿套模板，数论只会 GCD。题解：https://weakdouqing.github.io/2019/06/25/%E9%A2%98%E8%A7%A3/#more1.The Triangle(DP)链接：http://poj.org/problem?id=116312345678910111213141516171819202122232425例题：The Triangle 73 88 1 02 7 4 44 5 2 6 5(Figure 1)Figure 1 shows a number triangle. Write a program that calculates the highest sum of numbers passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right. InputYour program is to read from standard input. The first line contains one integer N: the number of rows in the triangle. The following N lines describe the data of the triangle. The number of rows in the triangle is &gt; 1 but &lt;= 100. The numbers in the triangle, all integers, are between 0 and 99. OutputYour program is to write to standard output. The highest sum is written as an integer. Sample Input573 88 1 0 2 7 4 44 5 2 6 5Sample Output302.区间完美数(gcd/lcm)链接: https://hpuoj.com/contest/20/problem/F/Problem Description：对于给定的区间[a,b]，codancer想统计[a,b]内有多少数既不是c的倍数，也不是d的倍数。Input单组输入输入四个数a,b,c,d(1≤a≤b≤1018,1≤c,d≤109)Output输出[a,b]内既不是c的倍数，也不是d的倍数的数的个数。Sample Input2 6 2 3Sample Output1PS：样例解释:[2,6]内的数为2,3,4,5,6,其中只有5既不是2的倍数也不是3的倍数。3.最短路链接: http://acm.hdu.edu.cn/showproblem.php?pid=2544Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间Sample Input2 11 2 33 31 2 52 3 53 1 20 0Sample Output32]]></content>
      <categories>
        <category>ACM</category>
        <category>Questions Set</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马大定理]]></title>
    <url>%2F2019%2F05%2F20%2F%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[费马大定理又被称为“费马最后的定理”。由17世纪法国数学家皮耶·德·费玛提出。他断言当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;int main()&#123; int n,t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++)&#123; cin&gt;&gt;n; if(n&lt;=2) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCM]]></title>
    <url>%2F2019%2F05%2F17%2FLCM%2F</url>
    <content type="text"><![CDATA[LCM(最小公倍数):简单公式： lcm = a / gcd * b实用方法：gcd(ka, kb) = k gcd(a, b) lcm(ka, kb) = k lcm(a, b)c++实现1234567891011121314151617181920212223242526272829303132333435363738394041输入2个正整数A，B，求A与B的最小公倍数。 Input2个数A,B，中间用空格隔开。(1&lt;= A,B &lt;= 10^9)Output输出A与B的最小公倍数。Input示例30 105Output示例210题解：#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int m = a; int n = b; if (a &lt; b) &#123; int temp = a; a = b; b = temp; &#125; int c; while (b != 0) &#123; c = a % b; a = b; b = c; &#125; cout &lt;&lt; (long long int)(m/a)*n &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD]]></title>
    <url>%2F2019%2F05%2F16%2FGCD%2F</url>
    <content type="text"><![CDATA[GCD(最大公约数):欧几里得算法据说是最早的算法，用于计算最大公约数，也是数论的基础算法之一。这里给出使用欧几里得算法求最大公约数的递归和非递归的程序，同时给出穷举法求最大公约数的程序。从计算时间上看，递推法计算速度最快。程序中包含条件编译语句用于统计分析计算复杂度。1234567891011121314151617181920代码： 递归算法： ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b);&#125;循环算法：/* 迭代法（递推法）：欧几里得算法，计算最大公约数 */int gcd(int m, int n)&#123; while(m) &#123; int c = n % m; n = m; m = c; &#125; return n;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排]]></title>
    <url>%2F2019%2F05%2F16%2F%E9%94%99%E6%8E%92%2F</url>
    <content type="text"><![CDATA[错排：公式：a[i]=(i-1)*(a[i-1]+a[i-2])链接：https://blog.csdn.net/achesong/article/details/87387024错排公式的原形为D(n) = n! (1/0! - 1/1! + 1/2! - 1/3! - ….. + (-1)^n/n!)，当n很大时计算就很不方便。一个供参考的简化后的公式是D(n) = [n!/e+0.5] ，其中e是自然对数的底，[x]为x的整数部分。123456789101112131415161718证明：由于1/e = e^(-1) = 1/0! - 1/1! + 1/2! - 1/3! - ..... + (-1)^n/n! + Rn(-1),其中Rn(-1)是余项，等于(-1)^(n+1) * e^u / (n+1)!，且u∈(-1, 0).所以，D(n) = n! * e^(-1) - (-1)^(n+1) * e^u / (n+1), u∈(-1, 0).而|n! Rn| = |(-1)^(n+1) * e^u / (n+1)| = e^u / (n+1) ∈ (1/[e(n+1)], 1/(n+1))，可知即使在n=1时，该余项（的绝对值）也小于1/2。因此，无论n! Rn是正是负，n! / e + 1/2的整数部分都一定与M(n)相同。对于比较小的n，结果及简单解释是：D(0) = 0（所有的元素都放回原位、没有摆错的情况）D(1) = 0（只剩下一个元素，无论如何也不可能摆错）D(2) = 1（两者互换位置）D(3) = 2（ABC变成BCA或CAB）D(4) = 9D(5) = 44D(6) = 265D(7) = 1854D(8) = 14833D(9) = 133496D(10) = 1334961]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教程]]></title>
    <url>%2F2019%2F05%2F14%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo ConfigurationDocs: http://hexo.io/docs/configuration.htmlSource: https://github.com/hexojs/hexo/1.Site 站点信息123456789101112131415title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:2.Directory(目录)123456789101112131415source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:3.Category &amp; Tag(分类和标签)default_category: uncategorized #默认分类category_map:tag_map:4.Archives12345678910112: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev5.Date / Time format(日期时间格式)12345678910111213date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap6.Deployment(部署，将 lmintlcx 改成用户名)1234deploy:type: gitrepo: github创库地址.gitbranch: master]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单排序]]></title>
    <url>%2F2019%2F05%2F13%2F%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单排序：sort(a,a+n);——默认是正序 头文件是algorithma是数组，或字符串，反正好多都可以排，包括结构体，string，n是排序长度。1234567891011#include&lt;iostream&gt; C++中标准输入输出#include&lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b&#125;; //返回值为0或者1，可以换成intint main()&#123; int a[10]=&#123;-1,3,-6,3,-4,0,7,-2,5,8&#125;; sort(a,a+10,cmp); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础]]></title>
    <url>%2F2019%2F05%2F12%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[C++一点内容：重点：当数组定义为全局变量时，数组如果没有初始化，默认为零（0）；大佬的博客链接：https://blog.csdn.net/c20182030/article/list/1?t=1&amp;1.时间/空间复杂度：具体链接：https://blog.csdn.net/qq347198688/article/details/5272576412341.时间复杂度：时间复杂度和空间复杂度一般是针对算法而言，是衡量一个算法是否高效的重要标准。先纠正一个误区，时间复杂度并不是算法执行的时间，再纠正一个误区，算法不单单指冒泡排序之类的，一个循环甚至是一个判断都可以称之为算法。其实理解起来并不冲突，八大排序甚至更多的算法本质上也是通过各种循环判断来实现的。2.空间复杂度：空间复杂度就是一个算法在运行过程中临时占用的存储空间大小，换句话说就是被创建次数最多的变量，它被创建了多少次，那么这个算法的空间复杂度就是多少。具体实现上图：2.OJ判题原理：Online Judge系统（简称OJ）是一个在线的判题系统。用户可以在线提交程序多种程序（如C、C++）源代码，系统对源代码进行编译和执行，并通过与预先设计的测试数据进行比较来检验程序源代码的正确性。万能头文件 #include&lt;bits/stdc++.h&gt;但是有些OJ不支持链接：https://www.cnblogs.com/Kiven5197/p/5745589.html12345678910111213141516171819万能头文件包含的部分文件：#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;fstream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;deque&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;set&gt; using namespace std;int main()&#123; return 0;&#125;C++简单计算a+b为了熟悉一个C++的简单操作123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,sum; // const int a,b; 也可以这样定义变量，c++提供的另一种定义变量的方法 cout&lt;&lt;"请输入两个整数:"&lt;&lt;endl; //cout必须和&lt;&lt;配着用,表示输出 //endl:end line的缩写，与C语言的\n功能一样，强行换行 cin&gt;&gt;a&gt;&gt;b; //cin与&gt;&gt;配合用,表示输入 sum=a+b; cout&lt;&lt;sum; //cout必须和&lt;&lt;配着用,表示输出 //使用cout&lt;&lt;输出的时候不用考虑输出的数据类型，cout会自动考虑 return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
