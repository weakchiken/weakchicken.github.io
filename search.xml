<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集训中学到的方法]]></title>
    <url>%2F2019%2F08%2F30%2F%E9%9B%86%E8%AE%AD%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习就该如贪心！！一直向前~！记录一些会用到并且好用的函数或者是容易混淆的知识点持续更新STL的定义方式：set/stack/queue/vector &lt;int/string&gt; 定义名称；set有自动排序的功能(从小到大)set里面用的是平衡二叉搜索树（也就是红黑树）维护string 字符串名称；map&lt;string/int, int/string&gt; 名称；set的迭代器：set:: iterator it;这个it是为指针用法eg：it = st.begin();cout &lt;&lt; it;it ++;for(; it != st.end(); it ++){cout &lt;&lt; “ “ &lt;&lt; it;}map的迭代器：map&lt;string, int&gt; :: iterator mp;这个mp用法要用mp -&gt; first 或者mp -&gt; second 来表示eg：map&lt;string, int&gt; :: iterator it1;map&lt;string, node&gt; :: iterator it2;for(it2 = mp.begin(); it2 != mp.end(); it2 ++){cout &lt;&lt; it2 -&gt; first &lt;&lt; endl;for(it1 = mp[it2 -&gt; first].count.begin(); it1 != mp[it2 -&gt; first].count.end(); it1 ++){cout &lt;&lt; “|—-“ &lt;&lt; it1 -&gt; first &lt;&lt; “(“ &lt;&lt; it1 -&gt; second &lt;&lt; “)” &lt;&lt; endl;}}嵌套map用法可以为struct node{map&lt;string, int&gt; count;};map&lt;string, node&gt; mp;用的时候为：mp[string].count[string] ++;或者一些操作binary_search的用法头文件 #include &lt;algorithm&gt;使用方法：123456a.函数模板：binary_search(arr[],arr[]+size , indx)b.参数说明： arr[]： 数组首地址 size：数组元素个数 indx:需要查找的值c.函数功能： 在数组中以二分法检索的方式查找，若在数组(要求数组元素非递减)中查找到indx元素则真，若查找不到则返回值为假。gcd的前缀后缀维护说到gcd,就不得不提一下C++11中子代有内置gcd函数,用法是 __gcd(a, b);题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6025持续更新PS:暂时不会讲解，先看代码吧，等以后理解透了在讲解code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int gcd(int a,int b)&#123; if(a&lt;b)&#123; int t=a; a=b;b=t; &#125; return b==0?a:gcd(b,a%b);&#125;int a[1000005],q[1000005],h[1000005];int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int n; cin&gt;&gt;n; memset(q,0,sizeof(q)); memset(h,0,sizeof(h)); int i; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; q[0]=a[0]; for(i=1;i&lt;n-1;i++)&#123; q[i]=gcd(q[i-1],a[i]); &#125; h[n-1]=a[n-1]; for(i=n-2;i&gt;0;i--)&#123; h[i]=gcd(h[i+1],a[i]); &#125; int ans=max(q[n-2],h[1]); for(i=1;i&lt;n-1;i++)&#123; ans=max(ans,gcd(q[i-1],h[i+1])); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;C++中auto的用法C++98 auto早在C++98标准中就存在了auto关键字，那时的auto用于声明变量为自动变量，自动变量意为拥有自动的生命期，这是多余的，因为就算不使用auto声明，变量依旧拥有自动的生命期：123int a =10 ; //拥有自动生命期auto int b = 20 ;//拥有自动生命期static int c = 30 ;//延长了生命期C++98中的auto多余且极少使用，C++11已经删除了这一用法，取而代之的是全新的auto：变量的自动类型推断。C++11 autoauto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：123int a = 10;auto au_a = a;//自动类型推断，au_a为int类型cout &lt;&lt; typeid(au_a).name() &lt;&lt; endl;typeid运算符可以输出变量的类型。程序的运行结果输出了int这种用法就类似于C#中的var关键字。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。而是否会造成编译期的时间消耗，我认为是不会的，在未使用auto时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。为什么用auto:用于代替冗长复杂、变量使用范围专一的变量声明。想象一下在没有auto的时候，我们操作标准库时经常需要这样：1234567891011#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; vs; for (vector&lt;string&gt;::iterator i = vs.begin(); i != vs.end(); i++) &#123; //... &#125;&#125;使用auto 可以简化代码:12345678910#include&lt;string&gt;#include&lt;vector&gt;int main()&#123; vector&lt;string&gt; vs; for (auto i = vs.begin(); i != vs.end(); i++) &#123; //.. &#125;&#125;pair的用法pair的应用pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。1234567pair&lt;T1, T2&gt; p1; //创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。pair&lt;T1, T2&gt; p1(v1, v2); //创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。make_pair(v1, v2); // 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。p1 &lt; p2; // 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。p1 == p2； // 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。p1.first; // 返回对象p1中名为first的公有数据成员p1.second; // 返回对象p1中名为second的公有数据成员pair的创建和初始化1234567891011pair包含两个数值，与容器一样，pair也是一种模板类型。但是又与之前介绍的容器不同；在创建pair对象时，必须提供两个类型名，两个对应的类型名的类型不必相同pair&lt;string, string&gt; anon; // 创建一个空对象anon，两个元素类型都是stringpair&lt;string, int&gt; word_count; // 创建一个空对象 word_count, 两个元素类型分别是string和int类型pair&lt;string, vector&lt;int&gt; &gt; line; // 创建一个空对象line，两个元素类型分别是string和vector类型当然也可以在定义时进行成员初始化：pair&lt;string, string&gt; author(&quot;James&quot;,&quot;Joy&quot;); // 创建一个author对象，两个元素类型分别为string类型，并默认初始值为James和Joy。pair&lt;string, int&gt; name_age(&quot;Tom&quot;, &quot;18&quot;);pair&lt;string, int&gt; name_age2(name_age); // 拷贝构造初始化12345678pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：typedef pair&lt;string,string&gt; Author;Author proust(&quot;March&quot;,&quot;Proust&quot;);Author Joy(&quot;James&quot;,&quot;Joy&quot;);变量间赋值：pair&lt;int, double&gt; p1(1, 1.2);pair&lt;int, double&gt; p2 = p1; //operator =pair对象的操作1234567891011pair&lt;int ,double&gt; p1;p1.first = 1;p1.second = 2.5;cout&lt;&lt;p1.first&lt;&lt;&apos; &apos;&lt;&lt;p1.second&lt;&lt;endl;//输出结果：1 2.5string firstBook;if(author.first==&quot;James&quot; &amp;&amp; author.second==&quot;Joy&quot;) firstBook=&quot;Stephen Hero&quot;;生成新的pair对象还可以利用make_pair创建新的pair对象：12345678910111213141516pair&lt;int, double&gt; p1;p1 = make_pair(1, 1.2);cout &lt;&lt; p1.first &lt;&lt; p1.second &lt;&lt; endl;//output: 1 1.2int a = 8;string m = &quot;James&quot;;pair&lt;int, string&gt; newone;newone = make_pair(a, m);cout &lt;&lt; newone.first &lt;&lt; newone.second &lt;&lt; endl;//output: 8 James通过tie获取pair元素值在某些清况函数会以pair对象作为返回值时，可以直接通过std::tie进行接收。比如：1234567891011121314std::pair&lt;std::string, int&gt; getPreson() &#123; return std::make_pair(&quot;Sven&quot;, 25);&#125;int main(int argc, char **argv) &#123; std::string name; int ages; std::tie(name, ages) = getPreson(); std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; &quot;, ages: &quot; &lt;&lt; ages &lt;&lt; std::endl; return 0;&#125;有关字符串的一些用法1.isalpha(c) ~判断是否为英文字符2.tolower(c) ~将字符转换成小写3.字符串输入sstream4.将字符串分割成单词：stringstream temp(str); //分割成一个个单词5.将字符串插入进set中，自动排序~stringstream的用法：stringstream是 C++ 提供的另一个字串型的串流(stream)物件，和之前学过的iostream、fstream有类似的操作方式。要使用stringstream， 必须先加入这一行：#includestringstream主要是用在將一个字符串分割，可以先用.clear( )以及.str( )將指定字串设定成一开始的內容，再用&gt;&gt;把个別的资料输出。Eg:題目：输入的第一行有一个数字 N 代表接下來有 N 行资料，每一行资料里有不固定个数的整数(最多20个，每行最大200个字元)，编程將每行的总和打印出來。输入：31 2 320 17 23 54 77 60111 222 333 444 555 666 777 888 999输出：625149951234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; string s; stringstream ss; int n; cin &gt;&gt; n; getline(cin, s); //读取换行 for (int i = 0; i &lt; n; i++) &#123; getline(cin, s); ss.clear(); ss.str(s); int sum = 0; while (1) &#123; int a; ss &gt;&gt; a; if(ss.fail()) break; sum += a; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;使用stringstream简化类型转换C++标准库中的提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，即单纯性、类型安全和可扩展性。接下来，我将举例说明怎样使用这些库来实现安全和自动的类型转换。Eg:12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int n = 10000; char s[10]; sprintf(s, &quot;%d&quot;, n); //s中的内容为“10000” //到目前为止看起来还不错。但是，对上面代码的一个微小的改变就会使程序发生错误 printf(&quot;%s\n&quot;, s); sprintf(s, &quot;%f&quot;, n); //错误的格式化符 printf(&quot;%s\n&quot;, s); return 0;&#125;详细学习链接：http://blog.csdn.net/zhang_xueping/article/details/47846807http://blog.csdn.net/u014097230/article/details/52089530优先队列奇偶剪枝]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
        <tag>ACM</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day10]]></title>
    <url>%2F2019%2F07%2F27%2FDay10%2F</url>
    <content type="text"><![CDATA[Day10今天是 又一次 积分赛我心态很好，真的很好，，，，真的很好。。。。OJ再战斐波那契Problem DescriptionDescription:小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。已知:输入格式输入包括 T 组，T∈[1,10].接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]).输出格式输出包含 T 行,每行输出一个整数.样例input31 22 33 4output111code:1234567891011121314151617181920//gcd(f(m),f(n)) = f(gcd(m,n))这个是规律#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a[1000];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); ll x, y; a[2] = 1, a[1] = 1; for(int i = 3; i &lt;= 100; i ++) a[i] = a[i - 1] + a[i - 2]; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%lld %lld&quot;,&amp;x, &amp;y); printf(&quot;%lld\n&quot;,a[__gcd(x, y)]); &#125; return 0;&#125;恐怖的怪物Description:一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。输入格式第一行是一个T。（1≤T≤100）接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。输出格式输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。样例input22 30Y000#3 4R00#00R00R00outputNoYesinput21 50Y0R02 4Y#0R0000outputYesNoinput15 4Y0F00000000000000000outputNocode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair&lt;int,int&gt;const int inf=0x3f3f3f3f;const ll INF=0x3f3f3f3f3f3f3f3f;const int maxn=1000+10;int t,n,m;char mp[maxn][maxn];int vis[maxn][maxn];int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;queue&lt;pii&gt;H,F;queue&lt;pii&gt;que;void init()&#123; while(!que.empty()) que.pop(); while(!H.empty()) H.pop(); while(!F.empty()) F.pop(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) vis[i][j]=0;&#125;bool BFS()&#123; while(!que.empty())&#123; int x=que.front().first; int y=que.front().second; que.pop(); if(vis[x][y]==8) break; for(int i=0;i&lt;4;i++)&#123; int xx=x+d[i][0]; int yy=y+d[i][1]; if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&apos;0&apos;) continue; vis[xx][yy]=vis[x][y]-1; que.push(pii(xx,yy)); while(vis[xx][yy]==14 &amp;&amp; (!H.empty()))&#123; que.push(H.front()); H.pop(); &#125; while(vis[xx][yy]==12 &amp;&amp; (!F.empty()))&#123; que.push(F.front()); F.pop(); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&apos;0&apos;) return false; return true;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,mp[i]+1); for(int j=1;j&lt;=m;j++)&#123; if(mp[i][j]==&apos;Y&apos;) que.push(pii(i,j)),vis[i][j]=15 ;//15 if(mp[i][j]==&apos;H&apos;) H.push(pii(i,j)),vis[i][j]=14;//14 if(mp[i][j]==&apos;F&apos;) F.push(pii(i,j)),vis[i][j]=12;//12 &#125; &#125; if(BFS()) printf(&quot;No\n&quot;); else printf(&quot;Yes\n&quot;); &#125; return 0;&#125;连连看Description:众所周知，《连连看》是一个老少皆宜的游戏。《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。输入格式第一行输入个T,表示T组数据（1≤t≤100）每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。每种棋子只会出现一对，因此数据保证只有一种有效结果。输出格式每组数据输出一行。如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。样例input32 21 22 13 41 6 2 34 5 3 14 2 6 54 41 2 3 68 4 7 85 6 5 71 2 3 4outputNoNoYescode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint mp[200][200];int n,m;int sx,sy;int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//分别对应下，右，左，上int check(int x,int y)&#123; if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1) return 1; return 0;&#125;bool judge(int x,int y,int step,int pos)&#123;//pos表示上一步方向 if(step&gt;3) return 0;//如果超过了三步，不符合规则 if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1)&#123;//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等） mp[x][y]=0;//删去配对字符 mp[sx][sy]=0; return 1; &#125; if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则 int i,x1,y1; for(i=0;i&lt;4;i++)&#123; if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上) (1.右 2.左) x1=x+dir[i][0]; y1=y+dir[i][1]; if(check(x1,y1)) continue;//检查是否越界 if(judge(x1,y1,step+(pos==i?0:1),i))&#123;//找到一个就返回 return 1; &#125; &#125; return 0;&#125;int main()&#123; int t,times,sum; int i,j; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(mp,0,sizeof(mp)); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; scanf(&quot;%d&quot;,&amp;mp[i][j]); &#125; &#125; sum=0; times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到 i=j=1; while(sum&lt;n*m &amp;&amp; times&lt;n*m)&#123; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; times++; sx=i,sy=j; if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1))&#123; sum+=2; times=0; &#125; &#125; &#125; &#125; if(sum==n*m)&#123; printf(&quot;Yes\n&quot;); &#125; else&#123; printf(&quot;No\n&quot;); &#125; &#125; return 0;&#125;Points in rectangleDescription:在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。输入格式第一行输入n,a(1≤a\&lt;n≤1e3)。第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。输出格式第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。样例input6 151 21 32 33 44 5output44 53 42 31 2code:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n, a;int m;struct node&#123; int xo, yo;&#125;biao[10001];node biao1[10001];int cmp(node a, node b)&#123; if(a.xo == b.xo) return a.yo &gt; b.yo; return a.xo &gt; b.xo;&#125;int cnt;bool solve(node point)&#123; return point.yo &gt;= -point.xo + a &amp;&amp; point.yo &gt;= point.xo - a &amp;&amp; point.yo &lt;= point.xo + a &amp;&amp; point.yo &lt;= -point.xo + 2 * n - a;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; a &gt;&gt; m; cnt = 0; for(int i = 0; i &lt; m; i ++) &#123; cin &gt;&gt; biao[i].xo &gt;&gt; biao[i].yo; if(solve(biao[i])) &#123; cnt ++; biao1[i].xo = biao[i].xo; biao1[i].yo = biao[i].yo; &#125; &#125; sort(biao1, biao1 + m, cmp); if(cnt == 0) puts(&quot;-1&quot;); else &#123; cout &lt;&lt; cnt &lt;&lt; endl; for(int i = 0; i &lt; cnt; i ++) &#123; cout &lt;&lt; biao1[i].xo &lt;&lt; &quot; &quot; &lt;&lt; biao1[i].yo &lt;&lt; endl; &#125; &#125; return 0;&#125;code2:123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3+100;struct point&#123; long long x,y; bool friend operator&lt;(point a,point b)&#123; if(a.x==b.x) return a.y&gt;b.y; return a.x&gt;b.x; &#125;&#125;p[N];long long n,a;bool check(point P)&#123; return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;&#125;int main()&#123; //freopen(&quot;17.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;17.out&quot;,&quot;w&quot;,stdout); vector&lt;point&gt; re; cin&gt;&gt;n&gt;&gt;a; int m; cin&gt;&gt;m; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;p[i].x&gt;&gt;p[i].y; if(check(p[i])) re.push_back(p[i]); &#125; sort(re.begin(),re.end()); if(re.empty())&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;re.size()&lt;&lt;endl; for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&apos; &apos;&lt;&lt;v.y&lt;&lt;endl; &#125; return 0;&#125;Numbers of intervalDescription:code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx = 1e6;typedef long long ll;ll a[maxx];ll b[maxx];int main()&#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; b[i] = a[i] + b[i - 1]; &#125; ll ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; int pos = lower_bound(b + 1, b + n + 1, k + b[i - 1]) - b; ans += (n - pos + 1); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;/*这题很巧妙，利用了前缀和与二分查找中的lower_bound首先是前缀和，不断相加前面每一个数的值，(比普通的定义一个变量相加更好用)存值，方便后便用到 找到第一个大于等于要求数的值，然后后边的数肯定都大，只要计数就行了 */剪纸Description:中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：假设剪后的形状为一个三角形，则展开效果为：现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。输入格式多组输入，处理到文件结束。每组输入第一行两个数字n,m（1≤n,m≤100)。接下来n行，每行m个字符，表示对折且剪切后的图形。保证输入字符只包含 ‘.’ 和 ‘’ 。输出格式输出展开后的图形。样例input3 3**. ..…output…….....**..**.....……code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//F#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx = 1000+10;char mmp[maxx][maxx];int main()&#123; int n, m; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m)) &#123; memset(mmp, &apos;.&apos;, sizeof mmp); for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; mmp[i][j]; if(mmp[i][j] == &apos;*&apos;) &#123; mmp[i + n][j + m] = &apos;*&apos;; mmp[i][j] = &apos;.&apos;; &#125; // cout &lt;&lt; a[i][j]; &#125; // puts(&quot;&quot;);// //// &#125; for(int i = 0; i &lt; n * 2; i ++) &#123; for(int j = 0; j &lt; m * 2; j ++) &#123; if(mmp[i][j] != &apos;*&apos;) mmp[i][j] = &apos;.&apos;; if(mmp[i][j] == &apos;*&apos;) &#123; mmp[2 * n - i - 1][j] = &apos;*&apos;; mmp[i][2 * m - j - 1] = &apos;*&apos;; mmp[2 * n - i - 1][2 * m - j - 1] = &apos;*&apos;; &#125; &#125; &#125; for(int i = 0; i &lt; 2 * n; i ++) &#123; for(int j = 0; j &lt; 2 * m; j ++) &#123; cout &lt;&lt; mmp[i][j]; &#125; puts(&quot;&quot;); &#125; &#125; return 0;&#125;Fake hpuoj predictorDescription:总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。具体算法为：其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。本场比赛的积分公式即为RA代表上轮比赛结束后的积分。K为积分系数,对于不同等级的选手的K是不同的。SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。EAi代表A与第i个选手比赛获胜的期望。对于HPU Online Judge，用户等级表为:codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。那么最终codancer打完本场比赛后的rating为现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。输入格式单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。接下来对于每场比赛：第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。输出格式输出codancer最终的rating，向上取整。样例input35tourist 2000capryang 1900boctorio 1800dicer 1800codancer2codancerrookie 2002wzy 1500codanceroutput12code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+10;int n,m,a;struct node&#123; char name[30]; double rating;&#125;p[maxn];double cal(double rating)&#123; if(rating&lt;1350) return 15.0; else if(rating&lt;1500) return 20.0; else if(rating&lt;1600) return 25.0; else if(rating&lt;1700) return 30.0; else if(rating&lt;1800) return 35.0; else return 50.0;&#125;double Rating(double rating)&#123; double k=cal(rating); double ea=0,sa=0; for(int i=0;i&lt;n;i++)&#123; if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue; ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0)); &#125; for(int i=0;i&lt;n;i++)&#123; if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123; sa=n-1-i; break; &#125; &#125; double now_rating=rating+k*(sa-ea);// return now_rating; return ceil(now_rating);&#125;int main()&#123; int m; scanf(&quot;%d&quot;,&amp;m); double codancerNB_rating=0.0; while(m--)&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%s&quot;,p[i].name); if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123; p[i].rating=codancerNB_rating; continue; &#125; scanf(&quot;%lf&quot;,&amp;p[i].rating); &#125; codancerNB_rating=Rating(codancerNB_rating); &#125; printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating)); return 0;&#125;花花与三猫CatliveDescription:“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的：游戏刚开始的时候，中分和李白相距L步，相对而望。老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等）在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。当老父亲的骰子掷到1的时候，中分可以向李白走一步。当老母亲的骰子掷到m的时候，李白可以向中分走一步。当中分和李白相遇的时候，游戏结束。可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。输入格式第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。输出格式输出包括T行，每行一个答案。样例input21 22 1output11code:123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MOD = 1e9 + 7;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); int L, M; while(T--) &#123; scanf(&quot;%d %d&quot;, &amp;L, &amp;M); printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD); &#125; return 0;&#125;code2:123456789101112131415161718192021222324252627//为啥多了几行，学长的意思是打cf的，防止被hack，哈哈#include&lt;bits/stdc++.h&gt;const int MOD = 1e9 + 7;int qpow(int a, int b, int mod)&#123; int res = 1; while(b)&#123; if(b&amp;1) res = 1LL * res * a % mod; a = 1LL * a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int inv(int p, int mod)&#123; return qpow(p, mod - 2, mod);&#125;int main()&#123; int T; scanf(&quot;%d&quot;, &amp;T); int L, M; while(T--)&#123; scanf(&quot;%d %d&quot;, &amp;L, &amp;M); printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD); &#125;&#125;Same StringDescription:有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。输入格式第一行输入一个n(1≤n≤100)，代表字符串的长度。第二行和第三行输入两个字符串s1,s2。第四行输入一个m(1≤m≤325)，代表有m组关系。接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。输出格式如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。样例input6aabbcccdbcad4a cc aa db coutputYEScode:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;bool f[26][26];int main()&#123; int n,m; string s1,s2; cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2; cin&gt;&gt;m; char u,v; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;u&gt;&gt;v; f[u-&apos;a&apos;][v-&apos;a&apos;]=1; &#125; for(int j=0;j&lt;26;j++)&#123; for(int i=0;i&lt;26;i++)&#123; for(int k=0;k&lt;26;k++)&#123; f[i][k]|=(f[i][j]&amp;f[j][k]); &#125; &#125; &#125; bool check=0; for(int i=0;i&lt;n;i++)&#123; if(s1[i]!=s2[i])&#123; if(f[s1[i]-&apos;a&apos;][s2[i]-&apos;a&apos;]==0)&#123; check=1;break; &#125; &#125; &#125; if(check)&#123; puts(&quot;NO&quot;); &#125; else puts(&quot;YES&quot;); // &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
        <tag>搜素算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day9]]></title>
    <url>%2F2019%2F07%2F26%2FDay9%2F</url>
    <content type="text"><![CDATA[Day9今天是 dfs 和 bfs 加训继续学习 dfs 和 bfs，毕竟这一块还是非常重要的OJ链接：https://vjudge.net/contest/314510#overviewKnight MovesProblem DescriptionBackgroundMr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?The ProblemYour task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.For people not familiar with chess, the possible knight moves are shown in Figure 1.InputThe input begins with the number n of scenarios on a single line by itself.Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l l. The second and third line contain pair of integers {0, …, l-1}{0, …, l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.OutputFor each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.123456789101112131415Sample Input380 07 01000 030 50101 11 1Sample Output5280code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;const int maxx = 1e5 + 10;int c, d;int ans, n;int vis[400][400];int dd[8][2] = &#123; -2, 1, -1, 2, 1, 2, 2, 1, -2, -1, -1, -2, 1, -2, 2, -1&#125;;struct node&#123; int x, y, step; &#125;;void bfs(int x, int y)&#123; ans = 0; memset(vis, 0, sizeof vis); queue&lt;node&gt; q; node e1, e2; e1.x = x, e1.y = y, e1.step = 0; q.push(e1); vis[e1.x][e1.y] = 1; while(!q.empty()) &#123; e1 = q.front(); q.pop(); if(e1.x == c &amp;&amp; e1.y == d) &#123; ans = e1.step; break; &#125; for(int i = 0; i &lt; 8; i ++) &#123; e2.x = e1.x + dd[i][0]; e2.y = e1.y + dd[i][1]; if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; n &amp;&amp; vis[e2.x][e2.y] == 0) &#123; vis[e2.x][e2.y] = 1; e2.step = e1.step + 1; q.push(e2); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int T; int a, b; cin &gt;&gt; T; while(T --) &#123; cin &gt;&gt; n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; bfs(a, b); &#125; return 0;&#125;变形课Problem Description呃……变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.Input测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.Output如果Harry可以完成他的作业,就输出”Yes.”,否则就输出”No.”(不要忽略了句号)12345678910111213141516Sample Inputsosoonrivergoesthemgotmoonbeginbig0Sample OutputYes.HintHarry 可以念这个咒语:&quot;big-got-them&quot;.code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;const int maxx = 1e5 + 10;string ss;bool vis[1000 + 10];int i;int flag;struct node&#123; int x, y;&#125;a[1000 + 10];void dfs(int x)&#123; if(a[x].y == &apos;m&apos;) &#123; flag = 1; return; &#125; for(int j = 0; j &lt; i; j ++) &#123; if(a[x].y == a[j].x &amp;&amp; vis[j] == 0) &#123; vis[j] = 1; dfs(j); &#125; &#125;&#125;int main()&#123; while(cin &gt;&gt; ss) &#123; memset(vis, 0, sizeof vis); flag = 0; i = 0; while(cin &gt;&gt; ss) &#123; if(ss[0] != &apos;0&apos;) &#123; a[i].x = ss[0]; a[i].y = ss[ss.size() - 1]; i ++; &#125; else break; for(int j = 0; j &lt; i; j ++) &#123; if(a[j].x == &apos;b&apos;) &#123; vis[j] = 1; dfs(j); &#125; &#125; &#125; if(flag) puts(&quot;Yes.&quot;); else puts(&quot;No.&quot;); &#125; return 0;&#125;PetProblem Description一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。Input输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。Output对于每组数据，输出可能找到仓鼠的站点数。1234567891011121314Sample Input110 20 10 20 31 41 52 63 74 86 9Sample Output2code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121bfs解法:#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;const int maxx = 1e5 + 10;vector&lt;int&gt; v[maxx];int n, d;bool vis[maxx];int dis[maxx];void bfs()&#123; memset(vis, 0, sizeof vis); memset(dis, 0, sizeof dis); queue&lt;int&gt; q; q.push(0); vis[0] = 1; dis[0] = 0; int cnt = 0; while(!q.empty()) &#123; int f = q.front(); q.pop(); if(dis[f] &gt; d) &#123; cnt ++; &#125; for(int i = 0; i &lt; v[f].size(); i ++) &#123; if(vis[v[f][i]] == 0) &#123; dis[v[f][i]] = dis[f] + 1; vis[v[f][i]] = 1; q.push(v[f][i]); &#125; &#125; &#125; printf(&quot;%d\n&quot;,cnt);&#125;int main()&#123;// ios::sync_with_stdio(false); int T; int a, b; while(~scanf(&quot;%d&quot;,&amp;T)) &#123; while(T --) &#123; scanf(&quot;%d %d&quot;,&amp;n, &amp;d); for(int i = 0; i &lt; n; i ++) v[i].clear(); for(int i = 0;i &lt; n - 1; i ++) &#123; scanf(&quot;%d %d&quot;,&amp;a, &amp;b); v[a].push_back(b); &#125; bfs(); &#125; &#125; return 0;&#125;dfs解法:#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 50 ;vector&lt;int&gt;G[maxn] ;int ans ;int n ,m ; int vis[maxn] ;void dfs(int st ,int l)&#123; if ( l &gt; m ) ans ++ ; int len = G[st].size() ; for (int i = 0 ; i &lt; len ; i ++ ) &#123; if ( !vis[G[st][i]] ) &#123; dfs(G[st][i] ,l + 1 ) ; vis[G[st][i]] = 1; &#125; &#125;&#125;int main() &#123; int t ; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) &#123; while ( t -- ) &#123; ans = 0 ; int a ,b ; scanf(&quot;%d %d&quot;,&amp;n ,&amp;m); for (int i = 0 ; i &lt;= n ; i ++ ) G[i].clear() ,vis[i] = 0 ; for (int i = 1 ; i &lt;= n - 1 ; i ++ ) &#123; scanf(&quot;%d %d&quot;,&amp;a ,&amp;b ) ; G[a].push_back(b) ; //G[b].push_back(a) ; &#125; dfs(0 ,0 ) ; printf(&quot;%d\n&quot;,ans) ; &#125; &#125; return 0;&#125;蜘蛛牌Problem Description蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。Input第一个输入数据是T，表示数据的组数。每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。Output对应每组数据输出最小移动距离。12345Sample Input11 2 3 4 5 6 7 8 9 10Sample Output9code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859思路：桶排原理记录每张牌的位置，遍历每张牌，枚举所有可能位置。将牌的大小作为下标。然后依次遍历。。。#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int MAX = 0x3f3f3f3f;char a[100];char visit[100];int ans;void dfs(int num, int sum)&#123; if (num==9) &#123; if(sum&lt;ans) &#123; ans = sum; &#125; return ; &#125; for(int i=1; i&lt;10; i++) &#123; if(visit[i]==0) &#123; visit[i] = 1; for(int j=i+1; j&lt;=10; j++) &#123; if(visit[j]==0) &#123; dfs(num+1, sum + abs(a[j]-a[i])); break; &#125; &#125; visit[i] = 0; &#125; &#125;&#125;int main()&#123; int T, x; scanf(&quot;%d&quot;, &amp;T); while(T--) &#123; for(int i=1; i&lt;=10; i++) &#123; scanf(&quot;%d&quot;, &amp;x); a[x] = i; &#125; memset(visit, 0, sizeof(visit)); ans = MAX; dfs(0, 0); printf(&quot;%d\n&quot;, ans); &#125; return 0;&#125;逃离迷宫Problem Description给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？Input第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。Output每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。12345678910111213141516171819Sample Input25 5...***.**...........*....1 1 1 1 35 5...***.**...........*....2 1 1 1 3Sample Outputnoyescode:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;const int maxx = 1e2 + 10;int n, m, a1, b1, a2, b2, k;char a[maxx][maxx];bool vis[maxx][maxx];int flag;int d[4][2] = &#123; 1, 0, -1, 0, 0, 1, 0, -1&#125;;struct node&#123; int x, y, step;&#125;;void bfs()&#123; memset(vis, 0, sizeof vis); queue&lt;node&gt; q; node e1, e2, e3; e1.x = a1 - 1, e1.y = b1 - 1, e1.step = -1; q.push(e1); vis[e1.x][e1.y] = 1; while(!q.empty()) &#123; e1 = q.front(); q.pop(); if(e1.x == a2 - 1 &amp;&amp; e1.y == b2 - 1 &amp;&amp; e1.step &lt;= k) &#123; flag = 1; return; &#125; for(int i = 0; i &lt; 4; i ++) &#123; e2.x = e1.x + d[i][0]; e2.y = e1.y + d[i][1]; while(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; a[e2.x][e2.y] == &apos;.&apos;) &#123; if(vis[e2.x][e2.y] == 0) &#123; e2.step = e1.step + 1; vis[e2.x][e2.y] = 1; q.push(e2); &#125; e3.x = e2.x + d[i][0]; e3.y = e2.y + d[i][1]; e2 = e3; &#125; &#125; &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T --) &#123; scanf(&quot;%d %d&quot;,&amp;n, &amp;m); for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; a[i][j]; &#125; scanf(&quot;%d %d %d %d %d&quot;,&amp;k, &amp;b1, &amp;a1, &amp;b2, &amp;a2); flag = 0; bfs(); if(flag) puts(&quot;yes&quot;); else puts(&quot;no&quot;); &#125; return 0;&#125;Kaitou Kid - The Phantom Thief (2)Problem Description破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。Input输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：‘S’：入口‘E’：出口‘J’：放有宝石的区域，至少出现一次‘.’：空白区域‘#’：墙Output对每组测试数据，输出至少要封锁的区域数。1234567891011121314151617Sample Input25 5 5SJJJJ..##J.JJJJ.J...EJ...5 5 6SJJJJ..##J.JJJJ.J...EJ...Sample Output02code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;char mapp[10][10];int visit[10][10];int dir[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;int n,m,o;int sx,sy,ex,ey;int flag;struct stu&#123; int x,y; int d; int flag;&#125;;int bfs()&#123; memset(visit,0,sizeof(visit)); stu x,y; queue&lt;stu&gt;root; x.x=sx;x.y=sy;x.flag=1;x.d=0; visit[x.x][x.y]=1; root.push(x); while(root.size()) &#123; x=root.front(); root.pop(); if(x.x==ex&amp;&amp;x.y==ey&amp;&amp;x.flag==2&amp;&amp;x.d&lt;=o) return 0; for(int i=0;i&lt;4;i++) &#123; y.x=x.x+dir[i][0]; y.y=x.y+dir[i][1]; y.d=x.d+1; if(mapp[y.x][y.y]==&apos;J&apos;) y.flag=2; else y.flag=x.flag; if(y.x&lt;0||y.x&gt;=n||y.y&lt;0||y.y&gt;=m||visit[y.x][y.y]==y.flag||mapp[y.x][y.y]==&apos;#&apos;||y.d&gt;o) continue; visit[y.x][y.y]=y.flag; root.push(y); &#125; &#125; return 1;&#125;void dfs(int x)&#123; if(bfs()) flag=1; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; char ma=mapp[i][j]; if(ma==&apos;.&apos;||ma==&apos;J&apos;) &#123; mapp[i][j]=&apos;#&apos;; if(x&gt;0) dfs(x-1); if(flag) return; mapp[i][j]=ma; &#125; &#125; &#125;&#125;int main()&#123; cin.sync_with_stdio(false); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;o; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;mapp[i][j]; if(mapp[i][j]==&apos;S&apos;) sx=i,sy=j; if(mapp[i][j]==&apos;E&apos;) ex=i,ey=j; &#125; &#125; flag=0; re=1&lt;&lt;30; for(int i=0;i&lt;=4;i++) &#123; dfs(i); if(flag) &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; &#125; return 0;&#125;A计划Problem Description可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。Input输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小NM（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前NM表示迷宫的第一层的布置情况，后NM表示迷宫第二层的布置情况。Output如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。12345678910111213141516Sample Input15 5 14S*#*..#........****....#...*.P#.*..***.....*.*.#..Sample OutputYEScode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;const int maxx = 1e5 + 10;int n, m, p;int ans;char a[2][30][30];bool vis[2][30][30];//int step[2][30][30];struct node&#123; int x, y, z; int t; friend bool operator &lt; (node a, node b) &#123; return a.t &gt; b.t; &#125;&#125;e;int d[4][2] = &#123; 0, 1, 0, -1, 1, 0, -1, 0&#125;;int bfs()&#123; memset(vis, 0, sizeof vis); queue&lt;node&gt; q; node e1, e2; e1.x = 0, e1.y = 0, e1.z = 0, e1.t = 0; q.push(e1); vis[e1.x][e1.y][e1.z] = 1; while(!q.empty()) &#123; e1 = q.front(); q.pop(); if(e1.z == e.z &amp;&amp; e1.x == e.x &amp;&amp; e1.y == e.y) &#123; return e1.t; &#125; for(int i = 0; i &lt; 4; i ++) &#123; e2.x = e1.x + d[i][0]; e2.y = e1.y + d[i][1]; e2.z = e1.z; if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; vis[e2.z][e2.x][e2.y] == 0 &amp;&amp; a[e2.z][e2.x][e2.y] != &apos;*&apos;) &#123; if(a[e2.z][e2.x][e2.y] == &apos;#&apos;) &#123; e2.z = 1 - e2.z; if(a[e2.z][e2.x][e2.y] == &apos;*&apos; || a[e2.z][e2.x][e2.y] == &apos;#&apos;) continue; &#125; e2.t = e1.t + 1; if(e2.t &gt; p) continue;//必须剪枝 q.push(e2); vis[e2.z][e2.x][e2.y] = 1; &#125; &#125; &#125; return -1;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T --) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; for(int i = 0; i &lt; 2; i ++) &#123; for(int j = 0; j &lt; n; j ++) &#123; for(int k = 0; k &lt; m; k ++) &#123; cin &gt;&gt; a[i][j][k]; if(a[i][j][k] == &apos;P&apos;) &#123; e.z = i; e.x = j; e.y = k; &#125; &#125; &#125; &#125; ans = bfs();// cout &lt;&lt; ans &lt;&lt; endl; if(ans != -1 &amp;&amp; ans &lt;= p) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125;NightmareProblem DescriptionIgnatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.Given the layout of the labyrinth and Ignatius’ start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.Here are some rules:We can assume the labyrinth is a 2 array.Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.If Ignatius get to the exit when the exploding time turns to 0, he can’t get out of the labyrinth.If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can’t use the equipment to reset the bomb.A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.InputThe input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.There are five integers which indicate the different type of area in the labyrinth:0: The area is a wall, Ignatius should not walk on it.1: The area contains nothing, Ignatius can walk on it.2: Ignatius’ start position, Ignatius starts his escape from this position.3: The exit of the labyrinth, Ignatius’ target position.4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.OutputFor each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1.123456789101112131415161718192021Sample Input33 32 1 11 1 01 1 34 82 1 1 0 1 1 1 01 0 4 1 1 0 4 11 0 0 0 0 0 0 11 1 1 4 1 1 1 35 81 2 1 1 1 1 1 4 1 0 0 0 1 0 0 1 1 4 1 0 1 1 0 1 1 0 0 0 0 3 0 1 1 1 4 1 1 1 1 1 Sample Output4-113code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,a[10][10];struct node&#123; int x,y,step,time;&#125;;int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;int ans;node now,mid;void bfs()&#123; queue&lt;node&gt; q; q.push(now); while(!q.empty()) &#123;// cout&lt;&lt;&quot;?&quot;&lt;&lt;endl; now=q.front(); q.pop(); if(now.time&lt;=0) continue; if(a[now.x][now.y]==3) &#123; ans=now.step; return ; &#125; for(int i=0;i&lt;4;i++) &#123; mid.x=now.x+d[i][0]; mid.y=now.y+d[i][1]; mid.step=now.step+1; mid.time=now.time-1; if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0) continue; if(a[mid.x][mid.y]==4) &#123; a[mid.x][mid.y]=0; mid.time=6; &#125; q.push(mid); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; ans=-1; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;a[i][j]; if(a[i][j]==2) &#123; now.x=i,now.y=j,now.step=0,now.time=6; &#125; &#125; &#125; bfs(); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;胜利大逃亡Problem DescriptionIgnatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.魔王住在一个城堡里,城堡是一个ABC的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.Input输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.Output对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.1234567891011121314Sample Input13 3 4 200 1 1 10 0 1 10 1 1 11 1 1 11 0 0 10 1 1 10 0 0 00 1 1 00 1 1 0Sample Output11code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int a,b,c,k;int s[51][51][51];int vis[51][51][51];struct node&#123; int x,y,z,step;&#125;;node mz,mid,ne;int d[6][3]=&#123;1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1&#125;,ans;void bfs()&#123; mz.x=mz.y=mz.z=mz.step=0; queue&lt;node&gt; q; q.push(mz); vis[0][0][0]=1; while(!q.empty()) &#123; mid=q.front(); q.pop(); if(mid.step&gt;k) &#123; return ; &#125; if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k) &#123; ans=mid.step; return ; &#125; for(int i=0;i&lt;6;i++) &#123; ne.x=mid.x+d[i][0]; ne.y=mid.y+d[i][1]; ne.z=mid.z+d[i][2]; if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1) continue; ne.step=mid.step+1; vis[ne.x][ne.y][ne.z]=1; q.push(ne); &#125; &#125;&#125;int main()&#123; int t;scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(vis,0,sizeof(vis)); ans=-1; scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k); for(int i=0;i&lt;a;i++) &#123; for(int j=0;j&lt;b;j++) &#123; for(int k=0;k&lt;c;k++) &#123; scanf(&quot;%1d&quot;,&amp;s[i][j][k]); &#125; &#125; &#125; bfs(); printf(&quot;%d\n&quot;,ans); &#125;&#125;A strange liftProblem Description计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？Input输入由几个测试用例组成，每个测试用例包含两行。第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。单个0表示输入的结束。Output对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。123456Sample Input5 1 53 3 1 2 50Sample Output3code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int n,a,b,meizi;int s[250][250],ans;int vis[250],step[250];void bfs(int x)&#123; queue&lt;int&gt; q; q.push(x); vis[x]=1,step[x]=0; while(!q.empty()) &#123; int mid=q.front(); q.pop();// cout&lt;&lt;mid&lt;&lt;endl; if(mid==b) &#123;// cout&lt;&lt;&quot;?&quot;&lt;&lt;endl; ans=step[mid]; return ; &#125; for(int i=1;i&lt;=n;i++) &#123;// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl; if(s[mid][i]&amp;&amp;vis[i]==0) &#123; q.push(i); vis[i]=1; step[i]=step[mid]+1; &#125; &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; memset(vis,0,sizeof(vis)); memset(step,0,sizeof(step)); memset(s,0,sizeof(s)); ans=-1; cin&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;meizi; if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n) s[i][meizi+i]=1; if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n) s[i][i-meizi]=1; &#125; bfs(a); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
        <tag>搜素算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我感想]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%BF%83%E6%80%81%2F</url>
    <content type="text"><![CDATA[心态人们常说：心态决定命运今天，写下这篇文章也是想给自己指明方向面朝大海，春暖花开学习的目的说实话，每个人都喜欢玩乐，但是，学习，只是让自己去获得某样东西也许，可以使知识，也可以是技能，又或者是友谊等等也有人说，学习是件痛苦的事但我想说的只有一点，那就是别逼着自己去学习在学习之前，思考并问一下自己，是不是真的想获得某样东西~可以说，没有人不想获得“超能力”，但是这些“超能力”又该怎么来那就是我们的学习很多人把学习固定化了，认为那就是学习书本上的知识那样错了！学习不该有范围，因为学习使我们自己与生俱来的能力我们总是想要去拥有些什么，然后就会不由自主地去选择学习所有说，我们不能因为一些其他的事情而把自己的心态给坏了保持一个良好的心态是我们能够成功的保证永远永远永远要端正好自己的态度切记不可半途而废，要做就一定要做到自己所能做到的最好！！！]]></content>
      <categories>
        <category>总结</category>
        <category>想法</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day8]]></title>
    <url>%2F2019%2F07%2F25%2FDay8%2F</url>
    <content type="text"><![CDATA[Day8今天学习了 树的直径树的直径-&gt;双重BFS/DFS跑图学的效果整体还行树什么是树？树（tree）是包含n（n&gt;0）个结点的有穷集，其中：每个元素称为结点（node）；有一个特定的结点被称为根结点或树根（root）；除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，…Tm−1，其中每一个集合Tm−1（1≤i≤m）本身也是一棵树，被称作原树的子树（subtree）。树的直径的定义树中距离最大的两个结点之间的距离称为树的直径。求解方法两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到离它最远的点，此点就是最长路的另一个端点，于是就找到了树的直径。证明假设此树的最长路径是从s到t,我们选择的点为u。反证法：假设搜到的点是v。1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛盾。2、v不在这条最长路径上，我们在最长路径上选择一个点为po，则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。也许你想说u本身就在最长路径，或则其它的一些情况，但其实都能用类似于上面的反证法来证明的。综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路径长度相关题目POJ 2631POJ 1985POJ 1383带权图相关代码模板(用的时候要合理变动)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# include &lt;iostream&gt;# include &lt;cstring&gt;# include &lt;queue&gt;# include &lt;vector&gt;const int maxn =100020;using namespace std ;int dis[maxn], ans ;bool vis[maxn];vector&lt;pair&lt;int ,int&gt; &gt; V[maxn];int bfs(int x)&#123; memset(dis ,0 , sizeof(dis)); memset(vis ,0 , sizeof(vis)); queue&lt;int &gt; Q ; Q.push(x); vis[x]=1; int point=0; while (!Q.empty())&#123; int F = Q.front(); Q.pop(); if(dis[F] &gt; ans )&#123; ans = dis[F]; point = F; &#125; pair &lt;int ,int &gt; t ; for (int i =0; i &lt; V [F].size (); i ++)&#123; t = V[F][i]; if(vis[t.first]==0)&#123; vis[t.first]=1; dis[t.first]=dis[F] + t.second ; Q.push (t.first); &#125; &#125; &#125; return point;&#125;int main()&#123; int x,y,z ; 输入 ans=0; int point=bfs(1); ans=0; bfs(point); cout&lt;&lt;ans&lt;&lt;endl ; return 0;&#125;OJ链接：https://vjudge.net/contest/313488#overviewLabyrinthProblem DescriptionThe northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.OutputYour program must print exactly one line of output for each test case. The line must contain the sentence “Maximum rope length is X.” where Xis the length of the longest path between any two free blocks, measured in blocks.12345678910111213141516171819Sample Input23 3####.####7 6########.#.####.#.####.#.#.##.....########Sample OutputMaximum rope length is 0.Maximum rope length is 8.HintHuge input, scanf is recommended. If you use recursion, maybe stack overflow. and now C++/c &apos;s stack size is larger than G++/gcccode:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;const int mod = 1e9;typedef long long ll;int n, m;char a[2000][3000];int dis[2000][2000];int ans;int d[4][2] = &#123; 1, 0, -1, 0, 0, 1, 0, -1&#125;;struct node&#123; int x, y;&#125;first, second;void bfs(node first)&#123; ans = 0; memset(dis, -1, sizeof dis); queue&lt;node&gt; q; node e1, e2; e1.x = first.x, e1.y = first.y, dis[e1.x][e1.y] = 0; q.push(e1); while(!q.empty()) &#123; e1 = q.front(); q.pop(); for(int i = 0; i &lt; 4; i ++) &#123; e2.x = e1.x + d[i][0]; e2.y = e1.y + d[i][1]; if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; a[e2.x][e2.y] != &apos;#&apos; &amp;&amp; dis[e2.x][e2.y] == -1) &#123; q.push(e2); dis[e2.x][e2.y] = dis[e1.x][e1.y] + 1; if(ans &lt; dis[e2.x][e2.y]) &#123; ans = dis[e2.x][e2.y]; second.x = e2.x; second.y = e2.y; &#125; &#125; &#125; &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while(T --) &#123; cin &gt;&gt; m &gt;&gt; n; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%s&quot;,&amp;a[i]); &#125; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; if(a[i][j] == &apos;.&apos;) &#123; first.x = i; first.y = j; &#125; &#125; &#125; bfs(first); bfs(second); printf(&quot;Maximum rope length is %d.\n&quot;,ans); &#125; return 0;&#125;Cow MarathonProblem DescriptionAfter hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.InputLines 1…..: Same input format as “Navigation Nightmare”.OutputLine 1: An integer giving the distance between the farthest pair of farms.123456789101112Sample Input7 61 6 13 E6 3 9 E3 5 7 S4 1 3 N2 4 20 W4 7 2 SSample Output52HintThe longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;const int maxn = 5e5 + 10;//数组不要太大，不然会超时 using namespace std;int dis[maxn];int ans, en;bool vis[maxn];vector &lt;pair&lt;int,int&gt; &gt;V[maxn];int bfs(int x) &#123; ans = 0; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(x); vis[x]=1; en = 0; while(!q.empty()) &#123; int f = q.front(); q.pop(); if(dis[f] &gt; ans) &#123; ans = dis[f]; en = f; &#125; pair&lt;int,int &gt; t; for(int i = 0; i &lt; V[f].size();i ++) &#123; t = V[f][i]; if(vis[t.first] == 0) &#123; vis[t.first] = 1; dis[t.first] = dis[f] + t.second; q.push(t.first); &#125; &#125; &#125; return en;&#125;int main ()&#123; int x, y, z; char c[100]; int n, m; while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n)) &#123; for(int i = 0;i &lt; n; i ++) V[i].clear();//注意每次用完vector之后要清空 for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%d %d %d %s&quot;,&amp;x,&amp;y,&amp;z,&amp;c); V[x].push_back(make_pair(y,z)); V[y].push_back(make_pair(x,z)); &#125; bfs(1); bfs(en); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;Roads in the NorthProblem DescriptionBuilding and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.InputInput to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.OutputYou are to output a single integer: the road distance between the two most remote villages in the area.12345678Sample Input5 1 61 4 56 3 92 6 86 1 7Sample Output22code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int mod = 1e9;const int maxx = 1e5 + 10;typedef long long ll;vector&lt;pair&lt;int, int&gt; &gt;v[maxx];int ans;bool vis[maxx];int dis[maxx];int en; //不要用end，是一个保留字 int bfs(int x)&#123; //每次bfs都要初始化 ans = 0; memset(vis, 0, sizeof vis); memset(dis, 0, sizeof dis); //套用bfs模板 queue&lt;int&gt; q; vis[x] = 1; q.push(x); en = 0; while(!q.empty()) &#123; int f = q.front(); q.pop(); //随着ans的不断更新，直到找到一个端点，标记下来 if(dis[f] &gt; ans) &#123; ans = dis[f]; en = f;//一段的开始 &#125; //创建新的数对，表示的是与v[]相连的点 pair&lt;int , int&gt; p; //遍历所有地点 ，根据距离，寻找一端的点 for(int i = 0; i &lt; v[f].size(); i ++) &#123; p = v[f][i];//表示 寻找这个点在图中的所有可能 if(vis[p.first] == 0) //如果这个地点没有经过 &#123; vis[p.first] = 1;//先标记 dis[p.first] = dis[f] + p.second;//加上距离 ，更新ans q.push(p.first);//入队，寻找这个点的所有可能性 &#125; &#125; &#125; return en;//将一端的标记返回出去 &#125;int main()&#123; int x, y, z; while(~scanf(&quot;%d %d %d&quot;,&amp;x, &amp;y, &amp;z)) &#123; //存图，意思就是将与x,y相连的点和对应的权值存储起来，因为是双向的，所以权值一样 v[x].push_back(make_pair(y, z)); v[y].push_back(make_pair(x, z)); &#125; //第一次bfs随便找个点去找到整个图的一个端点 bfs(1); //第二次bfs从一个端点出发去找另一个端点，即为树的直径 bfs(en); //输出答案ans cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;/*题意：有10000个村庄，有很多条路，现在这些路已经把村庄都连了起来，求最远的两个村庄的路的距离。思路，把每一边都历遍一下，找到两个距离最远的村庄。这里有一个结论，在图中，要找到距离最远的两点，先随便从一个点入手BFS，找到距离这个点最远的点，在从这个点BFS找到距离这点最远的点，这两点之间的距离就是这棵树的直径。所以直接进行BFS搜索就行了。*/ComputerProblem DescriptionA school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.Input输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过10^9。输入行中的数字用空格分隔。Output对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。1234567891011121314Sample Input51 12 13 11 1Sample Output32344提示示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int mod = 1e9;const int maxx = 1e5 + 10;typedef long long ll;vector&lt;pair&lt;int, int&gt; &gt; v[maxx];bool vis[maxx];int dis[maxx];int diss[maxx];int ans;int bfs(int x)&#123; ans = 0; memset(vis, 0, sizeof vis); memset(dis, 0, sizeof dis); queue&lt;int&gt; q; q.push(x); vis[x] = 1; int point; while(!q.empty()) &#123; int f = q.front(); q.pop(); if(ans &lt; dis[f]) &#123; ans = dis[f]; point = f; &#125; for(int i = 0; i &lt; v[f].size(); i ++) &#123; if(vis[v[f][i].first] == 0) &#123; vis[v[f][i].first] = 1; dis[v[f][i].first] = v[f][i].second + dis[f]; q.push(v[f][i].first); &#125; &#125; &#125; return point;&#125;int main()&#123; int n; int a, b; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i = 0; i &lt;= n; i ++) v[i].clear(); for(int i = 1; i &lt; n; i ++) &#123; cin &gt;&gt; a &gt;&gt; b; v[i + 1].push_back(make_pair(a, b)); v[a].push_back(make_pair(i + 1, b)); &#125; int point; point = bfs(bfs(1)); for(int i = 1; i &lt;= n; i ++) diss[i] = dis[i]; bfs(point); for(int i = 1; i &lt;= n; i ++) &#123; cout &lt;&lt; max(dis[i], diss[i]) &lt;&lt; endl; &#125; &#125; return 0;&#125;Farthest Nodes in a TreeProblem DescriptionGiven a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.InputInput starts with an integer T (≤ 10), denoting the number of test cases.Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.OutputFor each case, print the case number and the maximum distance.1234567891011121314Sample Input240 1 201 2 302 3 5050 2 202 1 100 3 290 4 50Sample OutputCase 1: 100Case 2: 80code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//e#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;const int maxn = 5e5 + 10;using namespace std;int dis[maxn];int ans, en;bool vis[maxn];vector &lt;pair&lt;int,int&gt; &gt;V[maxn];int bfs(int x) &#123; ans = 0; memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); queue&lt;int&gt;q; q.push(x); vis[x]=1; en = 0; while(!q.empty()) &#123; int f = q.front(); q.pop(); if(dis[f] &gt; ans) &#123; ans = dis[f]; en = f; &#125; pair&lt;int,int &gt; t; for(int i = 0; i &lt; V[f].size();i ++) &#123; t = V[f][i]; if(vis[t.first] == 0) &#123; vis[t.first] = 1; dis[t.first] = dis[f] + t.second; q.push(t.first); &#125; &#125; &#125; return en;&#125;int main ()&#123; int x, y, z; int T, n; cin &gt;&gt; T; int k = 1; while(T --) &#123; cin &gt;&gt; n; for(int i = 0;i &lt; n; i ++) V[i].clear();//注意每次用完vector之后要清空 for(int i = 0; i &lt; n - 1; i ++) &#123; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); V[x].push_back(make_pair(y,z)); V[y].push_back(make_pair(x,z)); &#125; bfs(0); bfs(en); printf(&quot;Case %d: %d\n&quot;,k ++, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
        <tag>搜素算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day7]]></title>
    <url>%2F2019%2F07%2F24%2FDay7%2F</url>
    <content type="text"><![CDATA[Day7今天学习的是dfs常规操作~~~~没写完题这次不是debug了，是真的不会(太菜了。。。)未完待续链接：https://vjudge.net/contest/313683#overviewOil DepositsProblem DescriptionThe GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either *&#39;, representing the absence of oil, or@’, representing an oil pocket.OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.123456789101112131415161718192021Sample Input1 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0 Sample Output0122code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//板子题，8个方向#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 101;char a[mod][mod];int vis[mod][mod];int ans;int n, m;int d[8][2] = &#123; -1, 1, -1, 0, -1, -1, 0, 1, 0, -1, 1, 1, 1, 0, 1, -1&#125;;void DFS(int x, int y)&#123; if(x &lt; 0 || y &lt; 0 || x &gt;=n || y &gt;= m) return ; int xx, yy;// vis[x][y] = 1; for(int i = 0; i &lt; 8; i ++) &#123; xx = x + d[i][0]; yy = y + d[i][1]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] != &apos;*&apos;) &#123; a[xx][yy] = &apos;*&apos;; DFS(xx, yy); &#125; &#125;&#125;int main()&#123; int sx, sy; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m) &amp;&amp; n) &#123;// memset(vis, 0, sizeof(vis)); ans = 0; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; if(a[i][j] == &apos;@&apos;) &#123; ans ++; DFS(i, j); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;How Many Equations Can You FindProblem DescriptionNow give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.InputEach case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999.OutputThe output contains one line for each data set : the number of ways you can find to make the equation.123456Sample Input123456789 321 1Sample Output181code:1234567891011121314151617181920212223242526272829303132333435//每一位都可能放或者不放算术符#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int MAXN = 200 + 10;char str[MAXN][MAXN];bool vis[MAXN][MAXN];char s[100100];ll n,m,len;ll ans;void DFS(int sum,int m)&#123; if(m==len)&#123; if(sum==n)&#123; ans++; &#125; return ; &#125; ll mm=0; for(int i=m;i&lt;len;i++)&#123; mm=mm*10+(s[i]-&apos;0&apos;); DFS(sum+mm,i+1); if(m!=0)&#123; DFS(sum-mm,i+1); &#125; &#125;&#125;int main()&#123; while(scanf(&quot;%s%lld&quot;,s,&amp;n)!=EOF)&#123; ans=0; len=strlen(s); DFS(0,0); printf(&quot;%d\n&quot;,ans); &#125; return 0;&#125;N皇后问题Problem Description在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。Input共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。Output共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。123456789Sample Input1850Sample Output19210code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//第一种写法#include&lt;bits/stdc++.h&gt;using namespace std;int vis[3][20], p[20]; // vis用来存储↖↑↗在此三个方向都不能有皇后 p[n]用来存储解 int n;int num;void DFS(int row)&#123; int i; if(row == n + 1) //已经够n行了 &#123; num ++; return ; &#125; for(i = 1; i &lt;= n; i ++) &#123; if(vis[0][row - i + n] == 0 &amp;&amp; vis[1][i] == 0 &amp;&amp; vis[2][row + i] == 0) &#123; vis[0][row - i + n] = vis[1][i] = vis[2][row + i] = 1;//变值 DFS(row + 1); vis[0][row - i + n] = vis[1][i] = vis[2][row + i] = 0;//回溯 &#125; &#125; &#125;int main()&#123; for(n = 1; n &lt;= 10; n ++) //打表防超时 &#123; memset(vis, 0, sizeof(vis)); num = 0; DFS(1); p[n] = num; &#125; while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; cout &lt;&lt; p[n] &lt;&lt; endl; &#125; return 0;&#125;//第二种#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 12;int a[N], cnt;//x，i表示行，y,a[i]表示列，用check来表示是否可以放置 bool check(int x, int y)&#123; for(int i = 1; i &lt; x; i ++) &#123; //abs(x - i) == abs(a[i] - y)表示的是(x-i)/(a[i]-y)的斜率的绝对值是否为1 if(a[i] == y || abs(x - i) == abs(a[i] - y)) return false; &#125; return true;&#125;void DFS(int x, int m)&#123; //x越界的时候,同时也表示到底了,回溯 if(x &gt; m) &#123; cnt ++; return ; &#125; for(int i = 1; i &lt;= m; i ++) &#123; if(check(x, i)) &#123; a[x] = i; DFS(x + 1, m); &#125; &#125; return ;&#125;int main()&#123; //ans用来存放数据，不打表的话可能超时 int i, ans[11]; //打表并深搜 for(int i = 1; i &lt; 11; i ++) &#123; cnt = 0; DFS(1, i); ans[i] = cnt; &#125; while(cin &gt;&gt; i) &#123; if(i == 0) return 0; cout &lt;&lt; ans[i] &lt;&lt; endl; &#125;&#125;//第三种//行，列，两个对角，共四个数组，每次存入都要查看是否已经存放过#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;int a[105],b[105],c[105],d[105];//a:行,b:列,c:左下到右上,d:左上到右下int i,ans=0;void DFS(int x)&#123; if(x==i+1)&#123; ans++; &#125; for(int j=1;j&lt;=i;j++)&#123; if(!b[j]&amp;&amp;!c[j+x]&amp;&amp;!d[x-j+i])&#123; a[x]=j; b[j]=1; c[j+x]=1; d[x-j+i]=1; DFS(x+1); b[j]=0; c[j+x]=0; d[x-j+i]=0; &#125; &#125;&#125;int main()&#123; int num[15]; int n; for(i=1;i&lt;11;i++) &#123; ans=0; DFS(1); num[i]=ans; &#125; while(cin&gt;&gt;n&amp;&amp;n) &#123; cout&lt;&lt;num[n]&lt;&lt;endl; &#125; return 0;&#125;Fox And Two DotsProblem DescriptionFox Ciel is playing a mobile puzzle game called “Two Dots”. The basic levels are played on a board of size n × m cells, like this:Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, …, dk a cycle if and only if it meets the following condition:These k dots are different: if i ≠ j then di is different from dj.k is at least 4.All dots belong to the same color.For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge.Determine if there exists a cycle on the field.InputThe first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.OutputOutput “Yes” if there exists a cycle, and “No” otherwise.1234567891011121314151617181920212223242526272829303132333435363738394041424344ExamplesInput 3 4AAAAABCAAAAAOutput YesInput 3 4AAAAABCAAADAOutput NoInput 4 4YYYRBYBYBBBYBBBYOutput YesInput 7 6AAAAABABBBABABAAABABABBBABAAABABBBABAAAAABOutput YesInput 2 13ABCDEFGHIJKLMNOPQRSTUVWXYZOutput NoNoteIn first sample test all &apos;A&apos; form a cycle.In second sample there is no such cycle.The third sample is displayed on the picture above (&apos;Y&apos; = Yellow, &apos;B&apos; = Blue, &apos;R&apos; = Red).code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//d#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int vis[55][55];char a[55][55];int d[4][2] = &#123; -1, 0, 1, 0, 0, 1, 0, -1&#125;;int n, m, k;//四个变量表示当前坐标点和上一个坐标点 void DFS(int x, int y, int cx, int cy)&#123; if(vis[x][y] == 1) &#123; //想要表示成环,只需要走以前走过的点就行了，也就是走到了标记过的点 k = 1; //表示成环 return; &#125; vis[x][y] = 1; int xx, yy; for(int i = 0; i &lt; 4; i ++) &#123; xx = x + d[i][0]; yy = y + d[i][1]; // 表示不能往回走并且不能越界 if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] == a[x][y] &amp;&amp; (xx != cx || yy != cy)) &#123; DFS(xx, yy , x, y); &#125; &#125;&#125;int main()&#123; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m)) &#123; k = 0; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%s&quot;,&amp;a[i]); &#125; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; //全部遍历，找寻可能点 if(vis[i][j] == 1) continue; DFS(i, j, i, j); //找到了点，退出循环 if(k == 1) break; &#125; if(k == 1) break; &#125; if(k == 1) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;棋盘问题Problem Description在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。12345678910111213Sample Input2 1#..#4 4...#..#..#..#...-1 -1Sample Output21code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int MAXN = 200 + 10;char str[MAXN][MAXN];bool vis[MAXN];int n,k;ll ans;int d[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;void DFS(int x,int num)&#123; if(num==k)&#123; ans++; return; &#125; for(int i=x;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(str[i][j]==&apos;#&apos;&amp;&amp;!vis[j])&#123; vis[j]=true; DFS(i+1,num+1); vis[j]=false; &#125; &#125; &#125;&#125;main()&#123; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF&amp;&amp;n!=-1&amp;&amp;k!=-1)&#123; memset(str,0,sizeof(str)); memset(vis,false,sizeof(vis)); ans=0; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%s&quot;,str[i]); &#125; DFS(0,0); printf(&quot;%lld\n&quot;,ans); &#125; return 0;&#125;SudokuProblem DescriptionSudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.InputThe input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.OutputFor each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.123456789101112131415161718192021Sample Input1103000509002109400000704000300502006060000050700803004000401000009205800804000107Sample Output143628579572139468986754231391542786468917352725863914237481695619275843854396127code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//每个为0的格子都可能放1~9放完后再查看每一行，列，每个小九宫格中是否含有这个数，如果没有则继续DFS下个格子#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;int a[10][10];int check(int n,int num)&#123; for(int i=0;i&lt;9;i++) &#123; int j=n%9; if(a[i][j]==num) return 0; &#125; for(int j=0;j&lt;9;j++) &#123; int i=n/9; if(a[i][j]==num) return 0; &#125; int ii=n/9/3*3; int jj=n%9/3*3; for(int i=ii;i&lt;ii+3;i++) for(int j=jj;j&lt;jj+3;j++) &#123; if(a[i][j]==num) return 0; &#125; return 1;&#125;int temp;int DFS(int n)&#123; if(n&gt;=81) &#123; temp=1; return 0; &#125; if(a[n/9][n%9]!=0) DFS(n+1); else &#123; for(int i=1;i&lt;=9;i++) &#123; if(check(n,i)==1) &#123; a[n/9][n%9]=i; DFS(n+1); if(temp==1) return 0; a[n/9][n%9]=0; &#125; &#125; &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; temp=0; for(int i=0;i&lt;9;i++) for(int j=0;j&lt;9;j++) scanf(&quot;%1d&quot;,&amp;a[i][j]); DFS(0); for(int i=0;i&lt;9;i++) &#123; for(int j=0;j&lt;9;j++) printf(&quot;%d&quot;,a[i][j]); printf(&quot;\n&quot;); &#125; &#125; return 0;&#125;放苹果Problem Description把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。Input第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。Output对输入的每组数据M和N，用一行输出相应的K。12345Sample Input17 3Sample Output8code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;//#include&lt;&gt;using namespace std;int n, m;int solve(int m, int n)&#123; if(m == 0 || n == 1) return 1; if(n &gt; m) return solve(m, m); else &#123; return solve(m, n - 1) + solve(m - n, n); &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; m &gt;&gt; n; int ans = solve(m, n); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;//PS：苹果可以为0， 盘子不能为0（毕竟是放苹果） /*分析：如果盘子比苹果多，那么一定会有盘子是空的，即为 solve(m, m); 那么这就是一种情况如果盘子比苹果少，那么可以分为：1. 假设没有空盘子，那么上面都有苹果，那么可以看成一开始每个盘子上都有一个苹果 然后我们每次加一个苹果，就剩下m - n个苹果，直到放完为止 即为 solve(m - n, n)2. 假设有空盘子，那么每次拿走一个空盘子 即为: solve(m, n - 1);结果即为这两种情况的和 */Tempter of the BoneProblem Description小明做了一个很久很久的梦，醒来后他竟发现自己和朋友在一个摇摇欲坠的大棋盘上，他们必须得想尽一切办法逃离这里。经过长时间的打探，小明发现，自己所在的棋盘格子上有个机关，上面写着“你只有一次机会，出发后t秒大门会为你敞开”，而他自己所在的棋盘是大小为 N*M 的长方形，他可以向上下左右四个方向移动（不可走有障碍点）。棋盘中有一扇门。根据机关的提示，小明顿时明白了，他和朋友必须在第 t 秒到门口。而这一切，没有回头路！因为一旦他移动了，他刚才所在的点就会消失，并且他不能在一个点上停留超过一秒，不然格子会爆炸。大逃亡开始了，请问小明和朋友能安全的逃出这奇怪的棋盘吗？Input输入多组测试数据。每个测试用例的第一行包含三个整数 N、M 和 T ( 1 &lt; N , M &lt; 7 ; 0 &lt; T &lt; 50 )，分别表示棋盘的大小和门打开的时间。接下来的N行给出棋盘布局，每一行包含M个字符。其中“.”: 无障碍点“X”: 障碍点“S”: 起点“D”: 门输入以 3 个 0 结束。这个测试用例不需要处理。输入数据中的空格有些问题，请不要使用getchar()，如果一定要用可以选择scanf(“%s”,) 自动忽略空格Output对于每组样例输出一行。如果小明能够安全逃出，输出 “YES” ，否则输出 “NO”。1234567891011121314Sample Input4 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0Sample OutputNOYEScode:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, t;char a[30][30]; int vis[40][40];int d[4][2] = &#123; -1, 0, 1, 0, 0, 1, 0, -1&#125;;int flag;int ex, ey;void DFS(int sx, int sy, int ans)&#123; int xx, yy; //很重要，可以减少步骤，也是如何使一旦找到需要的路线就可以连续return出 if(flag) return; if(sx == ex &amp;&amp; sy == ey &amp;&amp; ans == t) &#123; flag = 1; return; &#125; //剪枝的核心 int tem = t - ans - abs(ex - sx) - abs(ey - sy); //剪枝：如果剩余的步数已经不足以走到出口，且必须是偶数，偶数-偶数=偶数，奇数-奇数=偶数， if(tem &lt; 0 || tem &amp; 1) return; for(int i = 0; i &lt; 4; i ++) &#123; xx = sx + d[i][0]; yy = sy + d[i][1]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; vis[xx][yy] == 0 &amp;&amp; a[xx][yy] != &apos;X&apos;) &#123; vis[xx][yy] = 1; DFS(xx, yy, ans + 1); if(flag) return; vis[xx][yy] = 0; &#125; &#125; return;&#125;int main()&#123; int wall, sx, sy; while(~scanf(&quot;%d %d %d&quot;,&amp;n, &amp;m, &amp;t)) &#123; flag = 0, wall = 0; if(n == 0 &amp;&amp; m == 0 &amp;&amp; t == 0) break; memset(vis, 0, sizeof(vis)); for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; a[i][j]; if(a[i][j] == &apos;S&apos;) &#123; sx = i; sy = j; &#125; if(a[i][j] == &apos;D&apos;) &#123; ex = i; ey = j; &#125; if(a[i][j] == &apos;X&apos;) &#123; wall ++; &#125; &#125; &#125; if(t &gt; n * m - wall - 1) &#123; puts(&quot;NO&quot;); continue; &#125; vis[sx][sy] = 1; DFS(sx, sy, 0); if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; return 0;&#125;/*关于奇偶剪枝：不利用奇偶剪枝的话一直TLE，现在对于奇偶剪枝不理解，暂时记住公式，t-cnt为目前剩余的时间，abs(x-dx)+abs(y-dy)为从当前改点到终点（门)所需要的最短步数，剩余时间为偶数（奇数），就需要走偶数步（奇数步），奇数-偶数 = 奇数而奇数-奇数= 偶数，偶数-偶数=偶数所以只有当剩余的时间与目前位置到终点的最短步数奇偶性相同时，才有可能恰好在t时刻到大门的地方（因为中间会有墙，需根据题目条件继续判定，奇偶剪枝只是把范围缩小了）还有就是开头时间步数可移动位置的数量关系，也属于剪枝 勿忘abs(x-dx)+abs(y-dy)为从当前改点到终点（门)所需要的最短步数，但他会根据总时间的需要进行绕行，奇数步绕行后也是奇数步，偶数步绕行后也是偶数步，故他们之间奇偶性是相同的2.此题一开始还有个纠结的问题，就是深搜如何搜到符合条件的路径后就直接退出，一开始不知道怎么解决，因为觉得深搜利用了递归，无法return一下，就直接结束，此时用一个ans来解决就OK了，当搜索多条路径时，记得要还原需要在可能有变化找到结果标志flag及时return，3.对于下一步要走的路径（1）先确定下一步要走哪个格 用for函数和方向数组（2)通过book标记数组和map地图数组判断这个位置是否可以走（越界·是否是墙，是否已经测试或者走过）（3）标记这个位置已经走过（4）进入下一位置，传入这一数组（4）将以标记的数组撤回，以便下次再次搜索（6）将改变的值再改回来4.注意数组变量是否混合，每一个数组或者变量名是否改变5，记得初始化，尤其是while函数*/Red and BlackProblem DescriptionThere is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.Write a program to count the number of black tiles which he can reach by repeating the moves described above.InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)OutputFor each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).123456789101112131415161718192021222324252627282930313233343536373839404142Sample Input6 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0Sample Output4559613code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;char a[30][30];int vis[30][30];int m, n;int ans;int d[4][2] = &#123; 0, 1, 0, -1, 1, 0, -1, 0&#125;;void DFS(int x, int y)&#123; int xx, yy; vis[x][y] = 1; if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m) return ; for(int i = 0; i &lt; 4; i ++) &#123; xx = x + d[i][0]; yy = y + d[i][1]; if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; vis[xx][yy] == 0 &amp;&amp; a[xx][yy] != &apos;#&apos;) &#123; ans ++; DFS(xx, yy); &#125; &#125;&#125;int main()&#123; int sx, sy; while(~scanf(&quot;%d %d&quot;,&amp;m, &amp;n)) &#123; if(m == 0 &amp;&amp; n == 0) break; memset(vis, 0, sizeof(vis)); ans = 1; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; cin &gt;&gt; a[i][j]; if(a[i][j] == &apos;@&apos;) &#123; sx = i; sy = j; &#125; &#125; &#125; DFS(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
        <tag>搜素算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day6]]></title>
    <url>%2F2019%2F07%2F23%2FDay6%2F</url>
    <content type="text"><![CDATA[Day6今天学习的是 BFS + 存图方法BFS:学起来很容易，但是DEBUG是真的累由于自己比较笨，debug时间太长，没写完知识点待补OJ链接：https://vjudge.net/contest/313171#overviewBFS：广度优先搜索链接：存图方式链式前向星在了解什么是链式前向星之前，我们先来看一下什么是前向星。前向星其实就是一种边集数组。我们先把每条边的起点按照从小到大的顺序排序如果起点一样，那么就按照终点从小到达来排序。并记录下以某个点为起点的所有边在数组中的起始位置和边的数量,那么前向星就构造好了。RescueProblem DescriptionAngel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)InputFirst line contains two integers stand for N and M.Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend.Process to the end of the file.OutputFor each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.”1234567891011Sample Input7 8#.#####.#.a#..r.#..#x.....#..#.##...##...#..............Sample Output13code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;char a[300][300];int vis[300][300];int n, m;struct node&#123; int x, y; int step; friend bool operator &lt; (node a, node b) &#123; return a.step &gt; b.step; &#125; //重载运算符，用于自定义优先队列 的排序 &#125;;int d[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;void BFS(int x1, int y1, int x2, int y2)&#123; memset(vis, 0, sizeof(vis)); //先将全部初始化，方便后面标记 priority_queue&lt;node&gt; q; //优先队列 node e1, e2; e1.x = x1, e1.y = y1, e1.step = 0; q.push(e1); vis[x1][y1] = 1; int ans = -1;//表示不可能只走0步 while(!q.empty()) &#123; e1 = q.top(); q.pop(); if(e1.x == x2 &amp;&amp; e1.y == y2) &#123; ans = e1.step; break; &#125; for(int i = 0; i &lt; 4; i ++) &#123; e2.x = e1.x + d[i][0]; e2.y = e1.y + d[i][1]; //遍历寻找，如果不符合条件就continue if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= m || vis[e2.x][e2.y] == 1 || a[e2.x][e2.y] == &apos;#&apos;) continue; else &#123; if(a[e2.x][e2.y] == &apos;x&apos;) e2.step = e1.step + 2; else e2.step = e1.step + 1; &#125; //遍历完一定要把新的数加入队列！！ q.push(e2); vis[e2.x][e2.y] = 1; &#125; &#125; if(ans == -1) puts(&quot;Poor ANGEL has to stay in the prison all his life.&quot;); else cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123; int x1, y1, x2, y2; while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) &#123; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%s&quot;,&amp;a[i]); &#125; //双重for循环来寻找开始的点和 结束的点 for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; if(a[i][j] == &apos;a&apos;) &#123; x1 = i; y1 = j; &#125; if(a[i][j] == &apos;r&apos;) &#123; x2 = i; y2 = j; &#125; &#125; &#125; BFS(x1, y1, x2, y2); &#125; return 0;&#125;Red and BlackProblem DescriptionThere is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.Write a program to count the number of black tiles which he can reach by repeating the moves described above.InputThe input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)OutputFor each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).123456789101112131415161718192021222324252627282930313233343536373839404142Sample Input6 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0Sample Output4559613code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = 300;int n, m; //n表示行 ,m表示列char a[mod][mod];int vis[mod][mod];int d[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;; //struct node&#123;// int x, y;// int step; //用优先队列的时候加上friend bool operator // friend bool operator &lt; (node a, node b)// &#123;// return a.step &gt; b.step;// &#125;//&#125;;//优先队列的BFS//void BFS(int x1, int y1)//&#123;// memset(vis, 0, sizeof(vis));// // priority_queue&lt;node&gt; q; // node e1, e2;// e1.x = x1, e1.y = y1;// q.push(e1);// vis[e1.x][e1.y] = 1;// int num = 1;// while(!q.empty())// &#123;// e1 = q.top();// q.pop(); // for(int i = 0; i &lt; 4; i ++)// &#123;// e2.x = e1.x + d[i][0];// e2.y = e1.y + d[i][1];// if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= m || vis[e2.x][e2.y] == 1 || a[e2.x][e2.y] == &apos;#&apos;) continue;// else num ++; //e2.step = e1.step + 1; // q.push(e2);// vis[e2.x][e2.y] = 1;// &#125;// &#125;// cout &lt;&lt; num &lt;&lt; endl;//&#125;//////不是优先队列的BFS//struct node&#123;// int x, y;// int step;//&#125;;//void BFS(int x1, int y1)//&#123;// memset(vis, 0, sizeof(vis));// // queue&lt;node&gt; q;// node e1, e2;// e1.x = x1, e1.y = y1;// q.push(e1);// vis[e1.x][e1.y] = 1;// int num = 1;// while(!q.empty())// &#123;// e1 = q.top();// q.pop(); // for(int i = 0; i &lt; 4; i ++)// &#123;// e2.x = e1.x + d[i][0];// e2.y = e1.y + d[i][1];// if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= m || vis[e2.x][e2.y] == 1 || a[e2.x][e2.y] == &apos;#&apos;) continue;// else num ++; // q.push(e2);// vis[e2.x][e2.y] = 1;// &#125;// &#125;// cout &lt;&lt; num &lt;&lt; endl;//&#125;//int main()//&#123;// // int x1, y1, x2, y2;// while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n))// &#123;// if(n == 0 &amp;&amp; m == 0) break;// for(int i = 0; i &lt; n; i ++)// &#123;// scanf(&quot;%s&quot;,&amp;a[i]);// &#125;// for(int i = 0; i &lt; n; i ++)// &#123;// for(int j = 0; j &lt; m; j ++)// &#123;// if(a[i][j] == &apos;@&apos;)// &#123;// x1 = i;// y1 = j;// &#125;// &#125;// &#125;// BFS(x1, y1);// &#125;// // return 0;//&#125;//DFS int num;void DFS(int x1, int y1)&#123; int xx, yy; a[x1][y1] = &apos;#&apos;; num ++; for(int i = 0; i &lt; 4; i ++) &#123; xx = x1 + d[i][0]; yy = y1 + d[i][1]; if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m || a[xx][yy] == &apos;#&apos;) continue; else DFS(xx, yy); &#125;&#125;int main()&#123; int x1, y1; while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n)) &#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%s&quot;, &amp;a[i]); &#125; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; m; j ++) &#123; if(a[i][j] == &apos;@&apos;) &#123; x1 = i; y1 = j; &#125; &#125; &#125; memset(vis, 0, sizeof(vis)); num = 0; DFS(x1, y1); cout &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125;Battle CityProblem DescriptionMany of us had played the game “Battle city” in our childhood, and some people (like me) even often play it on computer now.What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).Your tank can’t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?InputThe input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of ‘Y’ (you), ‘T’ (target), ‘S’ (steel wall), ‘B’ (brick wall), ‘R’ (river) and ‘E’ (empty space). Both ‘Y’ and ‘T’ appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.OutputFor each test case, please output the turns you take at least in a separate line. If you can’t arrive at the target, output “-1” instead.12345678Sample Input3 4YBEBEERESSTE0 0Sample Output8code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int mod = 350;const int INF = 5;char a[mod][mod];int vis[mod][mod];int n, k;struct node&#123; int x, y; int step; friend bool operator &lt; (node a, node b) &#123; return a.step &gt; b.step; &#125;&#125;;int d[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;void BFS(int x1, int y1, int x2, int y2)&#123; memset(vis, 0, sizeof(vis)); priority_queue&lt;node&gt; q; node e1, e2; e1.x = x1, e1.y = y1, e1.step = 0; q.push(e1); vis[x1][y1] = 1; int ans = -1; while(!q.empty()) &#123; e1 = q.top(); q.pop(); if(e1.x == x2 &amp;&amp; e1.y == y2) &#123; ans = e1.step; break; &#125; for(int i = 0; i &lt; 4; i ++) &#123; e2.x = e1.x + d[i][0]; e2.y = e1.y + d[i][1]; if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= k || vis[e2.x][e2.y] == 1) continue; else &#123; if(a[e2.x][e2.y] == &apos;S&apos; || a[e2.x][e2.y] == &apos;R&apos;) continue; if(a[e2.x][e2.y] == &apos;B&apos;) e2.step = e1.step + 2; else e2.step = e1.step + 1; &#125; q.push(e2); vis[e2.x][e2.y] = 1; &#125; &#125; if(ans == -1) puts(&quot;-1&quot;); else cout &lt;&lt; ans &lt;&lt; endl; &#125;int main()&#123; int x1, x2, y1, y2; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;k)) &#123; if(n == 0 &amp;&amp; k == 0) break; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%s&quot;,&amp;a[i]); &#125; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; k; j ++) &#123; if(a[i][j] == &apos;Y&apos;) &#123; x1 = i; y1 = j; &#125; if(a[i][j] == &apos;T&apos;) &#123; x2 = i; y2 = j; &#125; &#125; &#125; BFS(x1, y1, x2, y2); &#125; return 0;&#125;Catch That CowProblem Description农夫知道一头牛的位置，想要抓住它。农夫和牛都于数轴上 ，农夫起始位于点 N(0&lt;=N&lt;=100000) ，牛位于点 K(0&lt;=K&lt;=100000) 。农夫有两种移动方式： 1、从 X移动到 X-1或X+1 ，每次移动花费一分钟 2、从 X移动到 2*X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不。最少要花多少时间才能抓住牛？Input一行: 以空格分隔的两个字母: N 和 KOutput一行: 农夫抓住牛需要的最少时间，单位分钟123456Sample Input5 17Sample Output4Hint农夫使用最短时间抓住牛的方案如下: 5-10-9-18-17, 需要4分钟.code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int mod = 1e5 + 10;int vis[mod];int n, k;struct node&#123; int x; int step; friend bool operator &lt; (node a, node b) &#123; return a.step &gt; b.step; &#125;&#125;;void BFS(int x1, int x2)&#123; memset(vis, 0, sizeof(vis)); priority_queue&lt;node&gt; q; node e1, e2; e1.x = x1, e1.step = 0; vis[e1.x] = 1; q.push(e1); while(!q.empty()) &#123; e1 = q.top(); q.pop(); if(e1.x == x2) break; else &#123; if(e1.x - 1 &gt; 0 &amp;&amp; vis[e1.x - 1] == 0) &#123; e2.x = e1.x - 1; e2.step = e1.step + 1; vis[e2.x] = 1; q.push(e2); &#125; if(e1.x + 1 &lt;= 100000 &amp;&amp; vis[e1.x + 1] == 0) &#123; e2.x = e1.x + 1; e2.step = e1.step + 1; vis[e2.x] = 1; q.push(e2); &#125; if(e1.x * 2 &lt;= 100000 &amp;&amp; vis[e1.x * 2] == 0) &#123; e2.x = e1.x * 2; e2.step = e1.step + 1; vis[e2.x] = 1; q.push(e2); &#125; &#125; &#125; cout &lt;&lt; e1.step &lt;&lt; endl; &#125;int main()&#123; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;k)) &#123; if(n &gt; k) cout &lt;&lt; n - k &lt;&lt; endl; else BFS(n, k); &#125; return 0;&#125;Dungeon MasterProblem Description你被困在一个三维的空间中,现在要寻找最短路径逃生！空间由立方体单位构成你每次向上下前后左右移动一个单位需要一分钟你不能对角线移动并且四周封闭是否存在逃出生天的可能性？如果存在，则需要多少时间？Input - 输入输入第一行是一个数表示空间的数量。每个空间的描述的第一行为L，R和C（皆不超过30）。L表示空间的高度。R和C分别表示每层空间的行与列的大小。随后L层地牢，每层R行，每行C个字符。每个字符表示空间的一个单元。’#’表示不可通过单元，’.’表示空白单元。你的起始位置在’S’，出口为’E’。每层空间后都有一个空行。L，R和C均为0时输入结束。Output - 输出每个空间对应一行输出。如果可以逃生，则输出如下Escaped in x minute(s).x为最短脱离时间。如果无法逃生，则输出如下Trapped!1234567891011121314151617181920212223242526Sample Input - 输入样例3 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0Sample Output - 输出样例Escaped in 11 minute(s).Trapped!code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int mod = 30;int L, R, C;char a[mod][mod][mod];int vis[mod][mod][mod];struct node&#123; int x, y, z; int t; friend bool operator &lt; (node a, node b) &#123; return a.t &gt; b.t; &#125;&#125;s, e, e1;//判断是否到达终点 bool yes(node sss)&#123; if(sss.x == e.x &amp;&amp; sss.y == e.y &amp;&amp; sss.z == e.z) return true; else return false;&#125;// 判断该点是否越界 bool check(int x, int y, int z)&#123; if(x &gt;= 0 &amp;&amp; x &lt; L &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; R &amp;&amp; z &gt;= 0 &amp;&amp; z &lt; C &amp;&amp; !vis[x][y][z] &amp;&amp; (a[x][y][z] == &apos;.&apos; || a[x][y][z] == &apos;E&apos;)) return true; else return false;&#125;int d[6][3] = &#123; 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1&#125;;int ans;void BFS()&#123; memset(vis, 0, sizeof(vis)); priority_queue&lt;node&gt; q; node e2; e1.x = s.x, e1.y = s.y, e1.z = s.z, e1.t = 0; q.push(e1); vis[e1.x][e1.y][e1.z] = 1; while(!q.empty()) &#123; e1 = q.top(); q.pop(); if(yes(e1)) &#123; ans = e1.t; break; &#125; else &#123; for(int i = 0; i &lt; 6; i ++) &#123; e2.x = e1.x + d[i][0]; e2.y = e1.y + d[i][1]; e2.z = e1.z + d[i][2]; if(check(e2.x, e2.y, e2.z)) &#123; e2.t = e1.t + 1; q.push(e2); vis[e2.x][e2.y][e2.z] = 1; &#125; else continue; &#125; &#125; &#125; &#125;int main()&#123; while(~scanf(&quot;%d %d %d&quot;,&amp;L, &amp;R, &amp;C)) &#123; if(L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) break; for(int i = 0; i &lt; L; i ++) &#123; for(int j = 0; j &lt; R; j ++) &#123; for(int k = 0; k &lt; C; k ++) &#123; cin &gt;&gt; a[i][j][k]; &#125; &#125; &#125; for(int i = 0; i &lt; L; i ++) &#123; for(int j = 0; j &lt; R; j ++) &#123; for(int k = 0; k &lt; C; k ++) &#123; if(a[i][j][k] == &apos;S&apos;) &#123; s.x = i; s.y = j; s.z = k; &#125; if(a[i][j][k] == &apos;E&apos;) &#123; e.x = i; e.y = j; e.z = k; &#125; &#125; &#125; &#125; BFS(); if(e1.x == e.x &amp;&amp; e1.y == e.y &amp;&amp; e1.z == e.z) printf(&quot;Escaped in %d minute(s).\n&quot;, ans); else printf(&quot;Trapped!\n&quot;); &#125; return 0;&#125;Robot MotionProblem Description A robot has been programmed to follow the instructions in its path. Instructions for the next direction the robot is to move are laid down in a grid. The possible instructions areN north (up the page)S south (down the page)E east (to the right on the page)W west (to the left on the page)For example, suppose the robot starts on the north (top) side of Grid 1 and starts south (down). The path the robot follows is shown. The robot goes through 10 instructions in the grid before leaving the grid.Compare what happens in Grid 2: the robot goes through 3 instructions only once, and then starts a loop through 8 instructions, and never exits.You are to write a program that determines how long it takes a robot to get out of the grid or how the robot loops around.InputThere will be one or more grids for robots to navigate. The data for each is in the following form. On the first line are three integers separated by blanks: the number of rows in the grid, the number of columns in the grid, and the number of the column in which the robot enters from the north. The possible entry columns are numbered starting with one at the left. Then come the rows of the direction instructions. Each grid will have at least one and at most 10 rows and columns of instructions. The lines of instructions contain only the characters N, S, E, or W with no blanks. The end of input is indicated by a row containing 0 0 0.OutputFor each grid in the input there is one line of output. Either the robot follows a certain number of instructions and exits the grid on any one the four sides or else the robot follows the instructions on a certain number of locations once, and then the instructions on some number of locations repeatedly. The sample input below corresponds to the two grids above and illustrates the two forms of output. The word “step” is always immediately followed by “(s)” whether or not the number before it is 1.1234567891011121314Sample Input3 6 5NEESWEWWWESSSNWWWW4 5 1SESWEEESNWNWEENEWSEN0 0 0Sample Output10 step(s) to exit3 step(s) before a loop of 8 step(s)code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char s[12][12];int vis[12][12];int main()&#123; int a,b,c; while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c)) &#123; if(a==0&amp;&amp;b==0&amp;&amp;c==0) break; for(int i=0;i&lt;a;i++) for(int j=0;j&lt;b;j++) cin&gt;&gt;s[i][j]; int x=0,y=c-1,step=0; memset(vis,0,sizeof(vis)); while(true) &#123; step++; if(s[x][y]==&apos;N&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; x--; &#125; else if(s[x][y]==&apos;S&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; x++; &#125; else if(s[x][y]==&apos;W&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; y--; &#125; else if(s[x][y]==&apos;E&apos;&amp;&amp;!vis[x][y]) &#123; vis[x][y]=step; y++; &#125; if(x&lt;0||x==a||y&lt;0||y==b) &#123; printf(&quot;%d step(s) to exit\n&quot;,step); break; &#125; else if(vis[x][y]) &#123; printf(&quot;%d step(s) before a loop of %d step(s)\n&quot;,vis[x][y]-1,step+1-vis[x][y]); break; &#125; &#125; &#125;&#125;Number TransformationProblem DescriptionIn this problem, you are given an integer number s. You can transform any integer number A to another integer number B by adding x to A. This x is an integer number which is a prime factor of A (please note that 1 and A are not being considered as a factor of A). Now, your task is to find the minimum number of transformations required to transform s to another integer number t.InputInput starts with an integer T (≤ 500), denoting the number of test cases.Each case contains two integers: s (1 ≤ s ≤ 100) and t (1 ≤ t ≤ 1000).OutputFor each case, print the case number and the minimum number of transformations needed. If it’s impossible, then print -1.1234567Sample Input26 126 13Sample OutputCase 1: 2Case 2: -1code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;#define INF 0x3f3f3f3fconst int maxx = 1e5;struct node&#123; int x, step; friend bool operator &lt; (node a, node b) &#123; return a.step &gt; b.step; &#125;&#125;;bool vis[10010];int p[10010];int s, t, k, ans;void prime(int n)&#123; k = 0; int m; m = n; for(int i = 2; i &lt;= sqrt(n); i ++) &#123; if(n % i == 0) &#123; p[++ k] = i; while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1 &amp;&amp; m != n) p[++ k] = n;&#125;void BFS()&#123; priority_queue&lt;node&gt; q; node e1, e2; e1.x = s, e1.step = 0; vis[s] = 1; q.push(e1); bool flag = 0; while(!q.empty()) &#123; e1 = q.top(); q.pop(); if(e1.x == t) &#123; flag = 1; ans = min(ans, e1.step); continue; &#125; memset(p, 0, sizeof(p)); prime(e1.x); for(int i = 1; i &lt;= k; i ++) &#123; e2.x = e1.x + p[i]; e2.step = e1.step + 1; if(e2.x &lt;= t &amp;&amp; !vis[e2.x]) &#123; vis[e2.x] = 1; q.push(e2); &#125; &#125; &#125; if(flag) cout &lt;&lt; ans &lt;&lt; endl; else puts(&quot;-1&quot;);&#125;int main()&#123; int n, kase = 0; cin &gt;&gt; n; while(n --) &#123; ans = INF; memset(vis, 0, sizeof(vis)); cin &gt;&gt; s &gt;&gt; t; printf(&quot;Case %d: &quot;, ++ kase); if(s == t) &#123; puts(&quot;0&quot;); continue; &#125; if(s &gt; t) &#123; puts(&quot;-1&quot;); continue; &#125; BFS(); &#125; return 0;&#125;Knight MovesProblem DescriptionA friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.InputThe input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.OutputFor each test case, print one line saying “To get from xx to yy takes n knight moves.”.123456789101112131415161718Sample Inpute2 e4a1 b2b2 c3a1 h8a1 h7h8 a1b1 c3f6 f6Sample OutputTo get from e2 to e4 takes 2 knight moves.To get from a1 to b2 takes 4 knight moves.To get from b2 to c3 takes 2 knight moves.To get from a1 to h8 takes 6 knight moves.To get from a1 to h7 takes 5 knight moves.To get from h8 to a1 takes 6 knight moves.To get from b1 to c3 takes 1 knight moves.To get from f6 to f6 takes 0 knight moves.code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;#define max_v 30int vis[max_v][max_v];int dir[8][2]= &#123;1,-2,2,-1,2,1,1,2,-1,2,-2,1,-2,-1,-1,-2&#125;;int ans;int sx, sy, fx, fy;struct node&#123; int x,y,step;&#125;;void BFS()&#123; memset(vis, 0, sizeof(vis)); queue&lt;node&gt; q; node e1, e2; e1.x = sx; e1.y = sy; e1.step = 0; vis[e1.x][e1.y] = 1; q.push(e1); while(!q.empty()) &#123; e1 = q.front(); q.pop(); if(e1.x == fx &amp;&amp; e1.y == fy) &#123; ans = e1.step; return ; &#125; for(int i = 0; i &lt; 8; i ++) &#123; e2.x = e1.x + dir[i][0]; e2.y = e1.y + dir[i][1]; if(e2.x &gt;= 1 &amp;&amp; e2.y &gt;= 1 &amp;&amp; e2.x &lt;= 8 &amp;&amp; e2.y &lt;= 8 &amp;&amp; vis[e2.x][e2.y] == 0) &#123; e2.step = e1.step + 1; vis[e2.x][e2.y] = 1; q.push(e2); &#125; &#125; &#125;&#125;int main()&#123; char x1, x2; int y1, y2; while(~scanf(&quot;%c%d %c%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2)) &#123; getchar(); sx=x1-&apos;a&apos;+1; sy=y1; fx=x2-&apos;a&apos;+1; fy=y2; BFS(); printf(&quot;To get from %c%d to %c%d takes %d knight moves.\n&quot;,x1, y1, x2, y2, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
        <tag>搜素算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day5]]></title>
    <url>%2F2019%2F07%2F22%2FDay5%2F</url>
    <content type="text"><![CDATA[Day5今天学习的是二分 + 贪心额，又是艰难的一天题写不完，只能慢慢补题了二分算法二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，但它有一个前提，就是必须在有序数据中进行查找。最基本的二分查找1234567891011121314int binarySearch(int[] A, int target, int n)&#123; int low = 0, high = n, mid; while(low &lt;= high)&#123; mid = low + (high - low) / 2; if(A[mid] == target)&#123; return mid; &#125;else if(A[mid] &gt; target)&#123; high = mid - 1; &#125;else&#123; low = mid + 1; &#125; &#125; return -1;&#125;需要注意的点：循环的判定条件是：low &lt;= high为了防止数值溢出，mid = low + (high - low)/2当 A[mid]不等于target时，high = mid - 1或low = mid + 1查找目标值区域的左边界/查找与目标值相等的第一个位置/查找第一个不小于目标值数的位置A = [1,3,3,5, 7 ,7,7,7,8,14,14]target = 7return 4123456789101112131415int binarySearchLowerBound(int[] A, int target, int n)&#123; int low = 0, high = n, mid; while(low &lt;= high)&#123; mid = low + (high - low) / 2; if(target &lt;= A[mid])&#123; high = mid - 1; &#125;else&#123; low = mid + 1; &#125; &#125; if(low &lt; A.length &amp;&amp; A[low] == target) return low; else return -1;&#125;查找目标值区域的右边界/查找与目标值相等的最后一个位置/查找最后一个不大于目标值数的位置A = [1,3,3,5,7,7,7, 7 ,8,14,14]target = 7return 7123456789101112131415int binarySearchUpperBound(int[] A, int target, int n)&#123; int low = 0, high = n, mid; while(low &lt;= high)&#123; mid = low + (high - low) / 2; if(target &gt;= A[mid])&#123; low = mid + 1; &#125;else&#123; high = mid - 1; &#125; &#125; if(high &gt;= 0 &amp;&amp; A[high] == target) return high; else return -1;&#125;查找最后一个小于目标值的数/查找比目标值小但是最接近目标值的数A = [1,3,3, 5 ,7,7,7,7,8,14,14]target = 7return 312345678910int low = 0, high = n, mid;while(low &lt;= high)&#123; mid = low + (high - low) / 2; if(target &lt;= A[mid])&#123; high = mid - 1; &#125;else&#123; low = mid + 1; &#125;&#125;return high &lt; 0 ? -1 : high;查找第一个大于目标值的数/查找比目标值大但是最接近目标值的数A = [1,3,3,5,7,7,7,7, 8 ,14,14]target = 7return 812345678910int low = 0, high = n, mid;while(low &lt;= high)&#123; mid = low + (high - low) / 2; if(target &gt;= A[mid])&#123; low = mid + 1; &#125;else&#123; high = mid - 1; &#125;&#125;return low &gt; n ? -1 : low;贪心算法基本认识：在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。经典例题：哈夫曼树构造价值问题：https://blog.csdn.net/likunkun__/article/details/80258515不完全（可拆分）背包问题：https://blog.csdn.net/likunkun__/article/details/80145612海岸雷达问题：https://blog.csdn.net/likunkun__/article/details/80230259普通字符串变换成回文字符串问题：https://blog.csdn.net/likunkun__/article/details/80230341基本思路：1.建立数学模型来描述问题。2.把求解的问题分成若干个子问题。3.对每一子问题求解，得到子问题的局部最优解。4.把子问题的解局部最优解合成原来解问题的一个解。使用的问题贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。贪心策略的选择因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。OJ链接：https://cn.vjudge.net/contest/313049#overviewPieProblem DescriptionMy birthday is coming up and traditionally I’m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.InputOne line with a positive integer: the number of test cases. Then for each test case:—One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.—One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.OutputFor each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).12345678Sample Input33 34 3 31 24510 51 4 2 3 4 5 6 5 4 2code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define PI acos(-1) // acos(-1) -1的反余弦函数值,等于3.141593 using namespace std;int T, n, m, t;double a[10020];bool fun(double x)&#123; double ans = 0; for(int i = 0; i &lt; x; i ++) &#123; ans += (int)(a[i] / x);// 为了防止每个人能分到&quot;最大的馅饼&quot;， // 拿每个馅饼的体积去除以单个馅饼能分给每一个人最大的体积，这样得到的就是所有人分到的最大的馅饼体积的和 &#125; if(ans &gt;= m + 1) return 1; return 0;&#125;int main()&#123; cin &gt;&gt; T; while(T --) &#123; double ans = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; t; a[i] = t * t * PI; &#125; sort(a, a + n); double l = 0,r = a[n - 1]; double mid = (l + r) / 2; while(r - l &gt;= 0.0000001) &#123; if(fun(mid)) l = mid; else r = mid; mid = (r + l) / 2; &#125; printf(&quot;%.4lf\n&quot;,mid); &#125; return 0;&#125;/*分馅饼，馅饼高度都为1，所以馅饼的体积V=π*r*r*1=π*r*r;分到最大馅饼的体积是：所有馅饼体积之和/（F+1）；（为什么不能是直接所有馅饼之和/（F+1）呢？因为每人只能分到一块，如果讲究平均分的话，一个人分到的就是拼凑起来的“最大的体积”，一个人甚至可能得到超过一块馅饼）最小即为0，然后我们对这两个最大最小值采用二分方法，求出中间符合最大的体积。那么怎么判断那个值就是最大的体积呢？让每个馅饼的体积/能分到最大的体积=能分到的人数，然后将每个馅饼能分到的人数相加，将该人数与F+1做判断比较，然后就是熟悉的套路了。*/Best Cow LineProblem DescriptionFJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.InputLine 1: A single integer: NLines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original lineOutputThe least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line.12345678910Sample Input6ACDBCBSample OutputABCBCDcode:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;char a [2010];int main()&#123; int n; cin &gt;&gt; n; int s = 0, e = n - 1, flag = 0; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; while(s &lt;= e) &#123; for(int i = 0; i &lt;= e - s; i ++) &#123; if(a[s + i] &lt; a[e - i]) &#123; ans ++; flag = 1; break; &#125; if(a[s + i] &gt; a[e - i]) &#123; flag = 0; ans ++; break; &#125; &#125; if(flag) cout &lt;&lt; a[s ++]; else cout &lt;&lt; a[e --]; if(ans % 80 == 0) cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125;Trailing Zeroes (III)Problem DescriptionYou task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 12…*N. For example, 5! = 120, 120 contains one zero on the trail.InputInput starts with an integer T (≤ 10000), denoting the number of test cases.Each case contains an integer Q (1 ≤ Q ≤ 108) in a line.OutputFor each case, print the case number and N. If no solution is found then print ‘impossible’.123456789Sample Input3125Sample OutputCase 1: 5Case 2: 10Case 3: impossiblecode:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxx = 1e9;ll f(ll n)&#123; ll ans = 0; while(n) &#123; ans += n / 5; n = n / 5; &#125; return ans;&#125;int main()&#123; int t, q; ll ans; int Case=0; cin &gt;&gt; t; while(t --) &#123; ans = 0; Case ++; int l = 1, r = maxx; ll mid; cin &gt;&gt; q; while(l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if(f(mid) == q) &#123; ans = mid; r = mid - 1; &#125; else if(f(mid) &lt; q) l = mid + 1; else r = mid - 1; &#125; if(ans) printf(&quot;Case %d: %lld&quot;,Case, ans); else printf(&quot;Case %d: impossible&quot;,Case); cout&lt;&lt;endl; &#125; return 0; &#125;The Frog’s GamesProblem DescriptionThe annual Games in frogs’ kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, theyare out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog’s longest jump distance).InputThe input contains several cases. The first line of each case contains three positive integer L, n, and m.Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.OutputFor each case, output a integer standing for the frog’s ability at least they should have.12345678910Sample Input6 1 2225 3 311 218Sample Output411code:待补湫湫系列故事——消灭兔子Problem Description湫湫减肥越减越肥！最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。游戏规则很简单，用箭杀死免子即可。箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。Input输入数据有多组，每组数据有四行；第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。特别说明：1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。Output如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。123456789101112Sample Input3 31 2 32 3 41 2 33 41 2 31 2 3 41 2 3 1Sample Output64code:待补Strange fuctionProblem DescriptionNow, here is a fuction:F(x) = 6 x^7+8x^6+7x^3+5x^2-y*x (0 &lt;= x &lt;=100)Can you find the minimum value when x is between 0 and 100.InputThe first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)OutputJust the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.1234567Sample Input2100200Sample Output-74.4291-178.8534code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const double mod = 1e-6;double qiu_y(double x)&#123; return 42 * pow(x, 6.0) + 48 * pow(x, 5.0) + 21 * pow(x, 2.0) + 10 * x;&#125;double f(double x, double y)&#123; return 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * pow(x, 2) - x * y;&#125;int main()&#123; int t; double l, r, mid, y, res; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; y; l = 0.0, r = 100.0; while(r - l &gt; mod) &#123; mid = (r + l) / 2; res = qiu_y(mid); if(res &lt; y) &#123; l = mid + 1e-8; &#125; else &#123; r = mid - 1e-8; &#125; &#125; printf(&quot;%0.4lf\n&quot;,f(mid, y)); &#125; return 0;&#125;/*相当于y是个常数求 F(x) = 6 * x^7+8*x^6+7*x^3+5*x^2-y*x (0 &lt;= x &lt;=100)这个函数的最小值，令F&apos; = 0，得出x，y的方程，用二分法解方程得x0(易证得x0&gt;=0 &amp;&amp; x0&lt;=100)，则F&apos;(x0) = 0,由F&apos;&apos; 在[0-100]上恒大于0，所以F&apos;在[0-100]上单增，所以F&apos;(x)&lt;0(x&lt;x0),F&apos;(x)&gt;0(x&gt;x0),所以F(x)在x=x0处取得最小值，所以本题主要就是二分求解方程的x0，然后直接带入x0，y计算即可。*/Can you find it?Problem DescriptionGive you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.InputThere are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.OutputFor each case, firstly you have to print the case number as the form “Case d:”, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print “YES”, otherwise print “NO”.1234567891011121314Sample Input3 3 31 2 31 2 31 2 331410Sample OutputCase 1:NOYESNOcode:待补pairsProblem DescriptionJohn has npoints on the X axis, and their coordinates are (x[i],0),(i=0,1,2,…,n−1)He wants to know how many pairs&lt;a,b&gt;that |x[b]−x[a]|≤k.(a&lt;b)InputThe first line contains a single integer T(about 5), indicating the number of cases.Each test case begins with two integers n,k(1≤n≤100000,1≤k≤109),Next nlines contain an integer xi,means the X coordinates.OutputFor each case, output an integer means how many pairs&lt;a,b&gt;that |x[b]−x[a]|≤k1234567891011121314151617Sample Input25 5-10001001011025 300-1000100101102Sample Output310code:待补Radar InstallationProblem DescriptionAssume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.Figure A Sample Input of Radar InstallationsInputThe input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.The input is terminated by a line containing pair of zerosOutputFor each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.12345678910111213Sample Input3 21 2-3 12 11 20 20 0Sample OutputCase 1: 2Case 2: 1code:待补Aggressive cowsProblem DescriptionFarmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?InputLine 1: Two space-separated integers: N and CLines 2..N+1: Line i+1 contains an integer stall location, xiOutputLine 1: One integer: the largest minimum distance123456789101112131415Sample Input5 312849Sample Output3HintOUTPUT DETAILS: FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. Huge input data,scanf is recommended.code:待补River HopscotchProblem DescriptionEvery year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 ≤ L ≤ 1,000,000,000). Along the river between the starting and ending rocks, N (0 ≤ N ≤ 50,000) more rocks appear, each at an integral distance Di from the start (0 &lt; Di &lt; L).To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to M rocks (0 ≤ M ≤ N).FJ wants to know exactly how much he can increase the shortest distance before he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of M rocks.InputLine 1: Three space-separated integers: L, N, and MLines 2.. N+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.OutputLine 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing M rocks1234567891011Sample Input25 5 2214112117Sample Output4HintBefore removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).code:待补]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day4]]></title>
    <url>%2F2019%2F07%2F21%2FDay4%2F</url>
    <content type="text"><![CDATA[Day4第一次积分赛今天打了第一次积分赛，有点小激动虽然没有大佬们那样NB吧，但至少咱们没爆零(以前的事谁有能记得清楚，是不？)归根结底，还是自己太菜了总结一下，积分赛还是学到了很多知识的不一一列举了，都会在代码中体现的(主要是很多新函数的加入！！！)OJ链接：https://hpuoj.com/contest/22/PS：我们学校OJ不太厉害，可能登不上去。。。Nth power of nProblem Description求 n^n 的个位数。输入格式多组输入，处理到文件结束。每组数据输入一个 n。(1≤n≤1e9)输出格式输出 nn 的个位数。样例input123output147Solve:快速幂即可，答案即为 n^n%10复杂度 O(nlog(n))code:1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9;ll quick_pow(ll a, ll b)&#123; ll res = 1; while(b) &#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; cout &lt;&lt; quick_pow(n, n) % 10 &lt;&lt; endl; &#125; return 0;&#125;复读机的力量Problem DescriptionCodancer: “我好菜啊！”Dicer: “我好菜啊！”Todest: “我好菜啊！”CaprYang: “我好菜啊！”…大佬们又开始装弱了，真正的菜鸡瑟瑟发抖不敢说话。我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。输入格式输入T组,(1≤T≤10)每组第一行输入一个正整数N,表示聊天记录的长度（1≤N≤10000）。接下来N行，每行两个字符串，前一个字符串为姓名，后一个字符为聊天记录。保证所有字符串长度不超过50，保证所有字符串只包含小写字母.输出格式如果没有复读机，输出 “Unbelievable!”(不包含引号）否则按照熟练度从大到小输出所有的复读机，如果熟练度相同，按照字典序从小到大输出。样例input14codancer iamsovegetabledicer iamsovegetabletodest iamsovegetablecapryang iamsovegetableoutputcapryangdicertodest提示数据保证上面大佬们说的话都是瞎话。Solve:只要有一次某个人不是复读的就不是复读机第一个人一定不是复读机使用 map&lt;string,bool&gt; 判断这个人是否是复读机使用 map&lt;string,int&gt; 记录这个人复读的次数用结构体记录排序复杂度 O(n * log(n))code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string x,y;&#125;p[10005];struct nod&#123; string na; int fo;&#125;pp[10005];bool cmp(nod m,nod n)&#123; if(m.fo==n.fo) return m.na&lt;n.na; return m.fo&gt;n.fo;&#125;int main()&#123; int t,n; cin&gt;&gt;t; string x,y; while(t--) &#123; cin&gt;&gt;n; set&lt;string&gt; se; map&lt;string,int&gt; ma; map&lt;string,int&gt; mp; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].x&gt;&gt;p[i].y; se.insert(p[i].x); ma[p[i].x]=1; &#125; ma[p[0].x]=0; for(int i=1;i&lt;n;i++) &#123; if(p[i].y==p[i-1].y) mp[p[i].x]++; if(p[i].y!=p[i-1].y) ma[p[i].x]=0; &#125; int pos=0; for(set&lt;string&gt;::iterator it=se.begin();it!=se.end();it++) &#123; if(ma[*it]) &#123; pp[pos].na=*it; pp[pos].fo=mp[*it]; pos++; &#125; &#125; if(pos==0) puts(&quot;Unbelievable!&quot;); else &#123; sort(pp,pp+pos,cmp); for(int i=0;i&lt;pos;i++) &#123; cout&lt;&lt;pp[i].na&lt;&lt;endl; &#125; &#125; &#125;&#125;官方code:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;struct peo&#123; string name; int num;&#125;;vector&lt;peo&gt; all;map&lt;string,bool&gt; jud;map&lt;string,int&gt; num;string a[N],b[N];set&lt;string&gt; name;bool cmp(peo a,peo b)&#123; if(a.num==b.num) return a.name&lt;b.name; return a.num&gt;b.num;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; int n; jud.clear();num.clear();name.clear();all.clear(); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],jud[a[i]]=1,num[a[i]]=0,name.insert(a[i]); jud[a[1]]=0; for(int i=2;i&lt;=n;i++)&#123; if(b[i]!=b[i-1])&#123; jud[a[i]]=0; &#125; num[a[i]]++; &#125; for(auto v:name)&#123; if(jud[v]) all.push_back(&#123;v,num[v]&#125;); &#125; sort(all.begin(),all.end(),cmp); if(all.size()==0)&#123; cout&lt;&lt;&quot;Unbelievable!&quot;&lt;&lt;endl; &#125; else&#123; for(auto v:all) cout&lt;&lt;v.name&lt;&lt;endl; &#125; &#125; return 0;&#125;无穷的小数Problem Description在十进制下，我们能够很轻易地判断一个小数的位数是有穷的或无穷的，但是把这个小数用二进制表示出的情况下其有穷性和无穷性就会发生改变，比如十进制下的 0.5 ,在二进制下的值为 0.1 ；十进制下的 0.75 ,在二进制下的值为 0.11 ；十进制下的 0.6 ,在二进制下的值为 0.1001100……给你一个十进制的小数，判断其在二进制表示下小数位数是否无穷。输入格式多组输入，处理到文件结束每组数据输入一个六位的小数 n.(0≤n\&lt;1)输出格式如果在二进制下小数位数是有穷的，输出”YES”,否则输出”NO”.样例input0.5000000.6000000.750000outputYESNOYESSolve:由于只有后六位，先乘上 106 防止爆精度。按照最普通的算法，每次乘以 2 再对 106 取余当循环次数超过某一个值时，即可判定为无穷code:1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9;int main()&#123; double n; while(~scanf(&quot;%lf&quot;,&amp;n)) &#123; int i = 0; int flag = 0; while(i &lt;= 10) &#123; n *= 2; if(n == int(n)) &#123; flag = 1; break; &#125; i ++; &#125; if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;/*小数转换成二进制就是每次乘以2直到等于1.如果一个小数在二进制表示下小数位数是无穷的，意思就是无论它乘以几次2，都不会正好等于1。我们只需要乘以2一定的次数，如果出现1，就不是无穷的，反之即无穷的。*/官方code:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double y; while(scanf(&quot;%lf&quot;,&amp;y)!=EOF)&#123; y*=10000000; bool flag=0; long long x=(long long)y; int num=0; while(1)&#123; if(x==0) break; if(num&gt;=200)&#123; flag=1;break; &#125; num++; x=2*x; if(x&gt;=10000000) x-=10000000; if(x==0) break; &#125; if(flag) puts(&quot;NO&quot;); else puts(&quot;YES&quot;); &#125; return 0;&#125;Special StringProblem Description我们定义一个字符串S为Special String只要这个字符串满足下面这些条件:1.这个串是回文的，即把这个字符串正着读和反着读相同，如abba和aca，而ba和abca则不是。2.26个小写字母必须全部出现3.这个串的长度为偶数。对于给定的S,判断它是否是Special String.输入格式输入一个只由小写字母组成的字符串S。(1≤|S|≤1e5)输出格式如果这个字符串是Special String，输出”YE5”,否则输出”N0”样例inputaaaaoutputN0inputabcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcbaoutputYE5PS:如果这一题不过的，请仔细看题，仔细看题！！！Solve:签到题，按题意要求模拟即可是 YE5 和 N0code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; if(s.size() % 2 != 0) &#123; puts(&quot;N0&quot;); return 0; &#125; int len = s.size(); int ans = len - 1; set&lt;char&gt; st; set&lt;char&gt; :: iterator it; int flag = 0; for(int i = 0; i &lt;= len / 2; i ++) &#123; st.insert(s[i]); &#125; for(it = st.begin(); it != st.end(); it ++) &#123; for(int i = &apos;a&apos;; i &lt;= &apos;z&apos;; i ++) &#123; if(st.count(i) == 0) flag = 1;//不是全部有 &#125; &#125; for(int i = 0;i &lt;= len / 2; i ++) &#123; if(s[i] != s[ans --]) &#123; flag = 1; &#125; &#125; if(flag) puts(&quot;N0&quot;); else puts(&quot;YE5&quot;); return 0;&#125;官方code：12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;bool check(string s)&#123; string c=s; reverse(c.begin(), c.end()); return s==c;&#125;pair&lt;int,int&gt; pii;int main()&#123; pii.first=1; pii.second=2; pii=make_pair(1,2); //cout&lt;&lt;pii.first&lt;&lt;&apos; &apos;&lt;&lt;pii.second&lt;&lt;endl; string s; cin&gt;&gt;s; bool flag=0; int l=s.length(); if(l&amp;1) flag=1; if(!check(s)) flag=1; int num[27]; memset(num,0,sizeof(num)); for(int i=0;i&lt;l;i++)&#123; num[s[i]-&apos;a&apos;]++; &#125; for(int i=0;i&lt;26;i++)&#123; if(num[i]==0)&#123; flag=1;break; &#125; &#125; if(flag) cout&lt;&lt;&quot;N0&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YE5&quot;&lt;&lt;endl; return 0;&#125;Max GcdProblem Description一个数组a，现在你需要删除某一项使得它们的gcd最大，求出这个最大值。输入格式第一行输入一个正整数n，表示数组的大小，接下来一行n个数，第i个数为ai。(2≤n≤1e5,1≤ai≤1e9)输出格式输出删除掉某个数以后的gcd的最大值。样例input42 4 8 1output2input41 2 3 4output1提示样例一：删除第四个元素后，2,4,8的最大公因子为2。样例二：无论删除哪一个，最大公因子都为1。Solve:维护前缀 gcd 数组 pre 和后缀 gcd 数组 od删除第 i 个数之后剩余数的 gcd 即为 gcd(prei−1, odi+1)线性枚举即可, 复杂度 O(n)两个都是官方的,学习一下新知识code:123456789101112131415161718192021222324//前缀后缀解法 #include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 100;long long a[N];long long pre[N], sa[N];int main()&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; pre[1] = a[1], sa[n] = a[n]; for(int i = 2; i &lt;= n; i ++) pre[i] = __gcd(pre[i - 1], a[i]); for(int i = n - 1; i &gt;= 1; i --) sa[i] = __gcd(sa[i + 1], a[i]); long long ans = max(pre[n - 1], sa[2]); for(int i = 2; i &lt;= n - 1; i ++) &#123; ans = max(ans, __gcd(pre[i - 1],sa[i + 1])); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;code:1234567891011121314151617181920212223242526272829//贪心解法#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;int a[maxn];bool cmp(int x,int y)&#123; return x &gt; y;&#125;int gcd(int a,int b)&#123; return b ? gcd(b,a % b) : a;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for (int i = 0;i &lt; n;i ++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a,a + n,cmp); int ans = a[0],now = a[0]; for (int i = 1;i &lt; n;i ++) &#123; ans = max(gcd(ans,a[i]),now); now = gcd(now,a[i]); &#125; printf(&quot;%d\n&quot;,ans); return 0;&#125;Count Prime PairsProblem Description对于数组a，如果i≠j并且ai+aj是一个质数，那么我们就称(i,j)为质数对，计算数组中质数对的个数。输入格式第一行输入一个n，表示数组的长度,接下来n个整数，第i个数代表ai。(1≤n≤100000,0≤ai≤100)输出格式输出数组中质数对的个数。样例input31 2 3output4提示样例说明：a1+a2,a2+a1,a2+a3,a3+a2都为质数，总共有四对。Solve:注意到 ai 的范围很小，我们可以先打出 [1, 200] 以内的质数表O(n) 或 O(nlog(n)) 的统计每个数出现的次数对于第 i 个质数 pi，和数组中第 j 个元素 aj，答案应该累加上 pi − aj 出现的次数注意 pi = 2 ∗ aj 的情况，应该加上 aj 出现的次数减去 1code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;int prime[350];int v[250];void init()&#123; for(int i = 0; i &lt; 250; i ++) &#123; prime[i] = 1; &#125; prime[0] = prime[1] = 0; for(int i = 2; i &lt; 250; i ++) &#123; for(int j = 2; j * i &lt; 250; j ++) &#123; prime[i * j] = 0; &#125; &#125;&#125;int main()&#123; int n, a; scanf(&quot;%d&quot;,&amp;n); for(int i = 0; i &lt; 200; i ++) v[i] = 0; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a; v[a] ++; &#125; init(); int ans = 0; for(int i = 1; i &lt;= 200; i ++) &#123; if(prime[i] == 1) &#123; for(int j = 0; j &lt;= i / 2; j ++) &#123; if(j != i - j) ans = ans + v[j] * v[i - j] * 2; else ans = ans + v[j] * (v[j] - 1); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;官方code：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;bool check(int x)&#123; if(x==1) return 0; if(x==2) return 1; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0) return 0; &#125; return 1;&#125;vector&lt;int&gt; pr;void init()&#123; for(int i=1;i&lt;=250;i++)&#123; if(check(i)) pr.push_back(i); &#125;&#125;int a[N];int vis[300];int main()&#123; init(); memset(vis,0,sizeof(vis)); long long ans=0; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],vis[a[i]]++; for(int i=0;i&lt;(int)pr.size();i++)&#123; int now=pr[i]; for(int j=1;j&lt;=n;j++)&#123; if(now&gt;=a[j])&#123; if(now==(a[j]*2)) ans+=vis[a[j]]-1; else&#123; if(vis[a[j]]&amp;&amp;vis[now-a[j]]) ans+=vis[now-a[j]]; &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;平行线Problem Description“大猩猩为什么不喜欢平行线？”“因为平行线没有相交”哈哈哈哈哈哈哈哈哈为了管理动物园不听话的大猩猩们，动物管理员Boctorio 决定去远方的ACM之城找一些平行线，当他逛到一个神奇的店铺时，他发现了一副黑色的图，上面依稀可见一些白色的点。Boctorio 询问店铺老板这幅画是什么，老板说：“天机不可泄露”。等Boctorio仔细端详了一会这幅画后，他惊讶的发现其中所蕴含的奥秘。向店铺老板道谢后，他拿着刚买的这幅画，就连忙赶回动物园。输入格式输入一个数 n(1≤n≤1000)，表示点的个数。接下来n行，每行两个整数 xi,yi(1≤xi,yi≤1e9),表示第i个点。数据保证没有重复的点输出格式输出用这些点所能表示出来的平行线段的对数。（两条不同的线段重合也算为平行）样例input60 01 01 13 13 35 4output10Solve:对(yi−yj)/(xi−xj) 用 gcd 约分后用 pair 存储利用 map 统计每个斜率的线段条数, 假设为 num, 那么斜率k 的贡献即为 num*(num−1)/2累加不同的斜率的贡献即可复杂度 O(n^2log(n^2))code:12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int x[1005], y[1005];int main()&#123; int n; cin &gt;&gt; n; set&lt;pair&lt;int, int&gt; &gt; se; map&lt;pair&lt;int, int&gt; ,int&gt; mp; for(int i = 0; i &lt; n; i ++) cin &gt;&gt; x[i] &gt;&gt; y[i]; for(int i = 0; i &lt; n; i ++) &#123; for(int j = i + 1; j &lt; n; j ++) &#123; int dx = x[j] - x[i]; int dy = y[j] - y[i]; int mid = __gcd(dx, dy); dx /= mid; dy /= mid; mp[&#123;dx, dy&#125;] ++; se.insert(&#123;dx, dy&#125;); &#125; &#125; int ans = 0; for(set&lt;pair&lt;int, int&gt; &gt; :: iterator it = se.begin(); it != se.end(); it ++) &#123; ans += (mp[*it] * (mp[*it] - 1)) / 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; /*先开一个集合和一个字典用来存储点数据 然后用gcd来找最大公约数，找到最小的分数，用 map存储约化后的斜率n * (n - 1) / 2*/官方code:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 2000;typedef long long ll;int x[N],y[N];int main()&#123; int n; cin&gt;&gt;n; map&lt;pair&lt;int,int&gt; ,int&gt; k; set&lt;pair&lt;long long,long long&gt;&gt; all; long long ans=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; int dx=x[j]-x[i]; int dy=y[j]-y[i]; if(dx&lt;0&amp;&amp;dy&lt;0)&#123; dx=-dx; dy=-dy; &#125; long long gc=__gcd(dx,dy); dx/=gc;dy/=gc; k[&#123;dx,dy&#125;]++; all.insert(&#123;dx,dy&#125;); &#125; &#125; for(auto v:all)&#123; ans+=(k[v]*(k[v]-1)/2); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;Area of polygonsProblem Description现在有a个边长为1的正方形，b个半径为1的圆，c个边长为1的等边三角形，现在你随机拿出一个图形，求这个图形面积的期望。输入格式第一行输入一个T,代表输入的组数。(1≤T≤100)接下来T行，每行三个数字a,b,c(1≤a,b,c≤1000)。输出格式输出T行，对于每一组输入，输出面积的期望，小数点后保留三位小数。样例input31 2 34 5 67 8 9output1.4301.4871.501提示圆周率为3.1415926535897Solve:初中数学题答案即为 a+bPI+c√3/4/(a+b+c)code:123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const float P = 3.1415926535897;int main()&#123; int n; cin &gt;&gt; n; while(n --) &#123; double a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; double ans = 0; ans = (a + b * P + c * sqrt(3) / 4) / (a + b + c); printf(&quot;%.3lf\n&quot;,ans); &#125; return 0;&#125;双色球Problem Description双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注。其中奖规则为：一等奖（6+1）二等奖（6+0）三等奖（5+1）四等奖（5+0、4+1）五等奖（4+0、3+1）六等奖（2+1、1+1、0+1）其中(a+b)即为有a个红色球，b个蓝色球与开奖某个数字相同（只与数字有关，与位置无关）。现在你有 n 张双色球彩票，以及本场彩票开奖结果，请你求出这 n 张彩票获得的最高奖。输入格式第一行输入一个 n ，表示 n 张彩票接下来 n 行，每行 7 个数字，表示每张彩票的选号，其中前六个位红色球，后一个为蓝色球。接下来一行，输入 7 个数字，表示开奖结果，其中前六个为红色球，后一个为蓝色球。输出格式输出所有彩票中能获得的最高等级奖，若无，则输出”0”。样例input52 17 21 28 30 32 102 12 17 29 30 31 159 10 19 25 26 30 126 8 18 29 30 31 1013 14 21 22 27 32 86 7 12 19 27 28 12output6input32 17 21 28 30 32 102 12 17 29 30 31 159 10 19 25 26 30 126 8 18 29 30 31 10output6提示彩票六个红色球数字均为从小到大排列Solve:只有 7 颗球，暴力模拟即可code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9;struct node&#123; int b[10];&#125;d[1000];int a[40];int main()&#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) &#123; for(int j = 0; j &lt; 7; j ++) &#123; cin &gt;&gt; d[i].b[j]; &#125; &#125; for(int i = 0; i &lt; 7; i ++) cin &gt;&gt; a[i]; int awd = 7, fin_awd = 7; for(int i = 0; i &lt; n; i ++) &#123; int flag = 0; int ans = 0; for(int j = 0; j &lt; 6; j ++) &#123; if(binary_search(a, a + 6, d[i].b[j])) &#123; ans ++; &#125; &#125; if(a[6] == d[i].b[6]) flag = 1; if(ans == 0 &amp;&amp; flag == 1) awd = 6; if(ans == 1 &amp;&amp; flag == 1) awd = 6; if(ans == 2 &amp;&amp; flag == 1) awd = 6; if(ans == 3 &amp;&amp; flag == 1) awd = 5; if(ans == 4 &amp;&amp; flag == 0) awd = 5; if(ans == 4 &amp;&amp; flag == 1) awd = 4; if(ans == 5 &amp;&amp; flag == 0) awd = 4; if(ans == 5 &amp;&amp; flag == 1) awd = 3; if(ans == 6 &amp;&amp; flag == 0) awd = 2; if(ans == 6 &amp;&amp; flag == 1) awd = 1; fin_awd = min(awd, fin_awd); &#125; cout &lt;&lt; fin_awd % 7 &lt;&lt; endl; return 0;&#125;官方code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;pair&lt;int,int&gt; solve(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; int num[34]; memset(num,0,sizeof(num)); int r=0; int bl=0; for(int i=0;i&lt;6;i++)&#123; num[a[i]]++; &#125; for(int i=0;i&lt;6;i++)&#123; if(num[b[i]]) r++; &#125; if(a[6]==b[6]) bl=1; return &#123;r,bl&#125;;&#125;int cal(pair&lt;int,int&gt; pii)&#123; if(pii.first==6&amp;&amp;pii.second==1) return 1; if(pii.first==6&amp;&amp;pii.second==0) return 2; if(pii.first==5&amp;&amp;pii.second==1) return 3; if((pii.first==5&amp;&amp;pii.second==0)||(pii.first==4&amp;&amp;pii.second==1)) return 4; if((pii.first==4&amp;&amp;pii.second==0)||(pii.first==3&amp;&amp;pii.second==1)) return 5; if((pii.first==2&amp;&amp;pii.second==1)||(pii.first==1&amp;&amp;pii.second==1)||(pii.first==0&amp;&amp;pii.second==1)) return 6; return 99999;&#125;const int N = 1e3+100;vector&lt;int&gt; a[N];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int x; for(int j=0;j&lt;7;j++)&#123; cin&gt;&gt;x; a[i].push_back(x); &#125; &#125; int ans=7; vector&lt;int&gt; b(7); for(int i=0;i&lt;7;i++) cin&gt;&gt;b[i]; for(int i=1;i&lt;=n;i++) &#123; ans=min(ans,cal(solve(a[i],b))); &#125; if(ans==7) ans=0; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;Remainder Minimization 2019Problem Description给你一个区间[L,R],在这个区间内找到两个不同的数字i,j，使得(i∗j)%2019的值最小。输入格式输入两个数 L,R,(1≤L\&lt;R≤1e9）输出格式如题样例input4 5output20input2020 2040output2Solve:当 L 和 R 的差值大于 2019 的时候，其中必定含有 2019 的倍数，此时答案为 0否则暴力枚举code:123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 2019;int main()&#123; int l, r; cin &gt;&gt; l &gt;&gt; r; int minn = 6666666; if((r - l) &gt; 2019) minn = 0; else &#123; for(int i = l; i &lt;= r; i ++) &#123; for(int j = i; j &lt;= r; j ++) &#123; if(i != j &amp;&amp; (i % mod) * (j % mod) % 2019 &lt; minn) &#123; minn = (i % mod) * (j % mod) % 2019; &#125; &#125; &#125; &#125; cout &lt;&lt; minn &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day3]]></title>
    <url>%2F2019%2F07%2F20%2FDay3%2F</url>
    <content type="text"><![CDATA[Day3今天学习的是 STL + 栈 + 队列栈和队列还好，以前接触过，STL就不行了，对我来说只是听说过，没用过全新的知识点一定要打好基础！！！因为学的比较慢，此次没有把题补完，下次补上未完待续~~~OJ链接：https://cn.vjudge.net/contest/312177Windows Message QueueProblem DescriptionMessage queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue.InputThere’s only one test case in the input. Each line is a command, “GET” or “PUT”, which means getting message or putting message. If the command is “PUT”, there’re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file.OutputFor each “GET” command, output the command getting from the message queue with the name and parameter in one line. If there’s no message in the queue, output “EMPTY QUEUE!”. There’s no output for “PUT” command.123456789101112Sample InputGETPUT msg1 10 5PUT msg2 10 4GETGETGETSample OutputEMPTY QUEUE!msg2 10msg1 10EMPTY QUEUE!code:待补~Train Problem IProblem DescriptionAs the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^).But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can’t leave until train B leaves.The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2. InputThe input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input.OutputThe output contains a string “No.” if you can’t exchange O2 to O1, or you should output a line contains “Yes.”, and then output your way in exchanging the order(you should output “in” for a train getting into the railway, and “out” for a train getting out of the railway). Print a line contains “FINISH” after each test case. More details in the Sample Output.12345678910111213141516171819202122Sample Input3 123 3213 123 312Sample OutputYes.inininoutoutoutFINISHNo.FINISHTip:For the first Sample Input, we let train 1 get in, then train 2 and train 3.So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1.In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3.Now we can let train 3 leave.But after that we can&apos;t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.So we output &quot;No.&quot;.code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; string id1, id2, res; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; cin &gt;&gt; id1 &gt;&gt; id2; stack&lt;char&gt; s; queue&lt;string&gt; q; int i, j; int flag = 0; for(int i = 0, j = 0; i &lt; n &amp;&amp; j &lt;= n;) &#123; if(s.empty() || s.top() != id2[i]) &#123; if(j == n) &#123; cout &lt;&lt; &quot;No.\nFINISH\n&quot;; flag = 1; break; &#125; s.push(id1[j]); j ++; q.push(&quot;in&quot;); &#125; else &#123; s.pop(); i ++; q.push(&quot;out&quot;); &#125; &#125; if(flag) continue; else &#123; cout &lt;&lt; &quot;Yes.\n&quot;; while(!q.empty()) &#123; cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); &#125; &#125; cout &lt;&lt; &quot;FINISH&quot; &lt;&lt; endl; &#125; return 0;&#125;RailsProblem DescriptionThere is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time.It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, …, N.The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, …, aN. Help him and write a program that decides whether it is possible to get the required order of coaches.You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.InputThe input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, …, N. The last line of the block contains just 0.The last block consists of just one line containing 0.OutputThe output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last null’’ block of the input.1234567891011121314Sample Input51 2 3 4 55 4 1 2 3066 5 4 3 2 100Sample OutputYesNoYescode:12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stack&gt;using namespace std;int a[1010];int main()&#123; int t; while(~scanf(&quot;%d&quot;,&amp;t) &amp;&amp; t) &#123; while(1) &#123; stack&lt;int&gt; s; scanf(&quot;%d&quot;,&amp;a[0]); if(!a[0]) &#123; puts(&quot;&quot;); break; &#125; for(int i = 1; i &lt; t; i ++) &#123; cin &gt;&gt; a[i]; &#125; int ans = 0; for(int i = 1; i &lt;= t; i ++) &#123; s.push(i); while(!s.empty() &amp;&amp; s.top() == a[ans]) &#123; s.pop(); ans ++; &#125; &#125; if(s.empty()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125;{A} + {B}Problem Description给你两个集合，要求{A} + {B}.注:同一个集合中不会有两个相同的元素.Input每组输入数据分为三行,第一行有两个数字n,m(0&lt;n,m&lt;=10000),分别表示集合A和集合B的元素个数.后两行分别表示集合A和集合B.每个元素为不超出int范围的整数,每个元素之间有一个空格隔开.Output针对每组数据输出一行数据,表示合并后的集合,要求从小到大输出,每个元素之间有一个空格隔开.12345678910Sample Input1 212 31 211 2Sample Output1 2 31 2code:1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int mod = 1e9;int main()&#123; int n, m, x, y; set&lt;int&gt; :: iterator it;//遍历器 while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m)) &#123; set&lt;int&gt; st; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%d&quot;,&amp;x); st.insert((x)); &#125; for(int i = 0; i &lt; m; i ++) &#123; scanf(&quot;%d&quot;,&amp;y); st.insert(y); &#125; it = st.begin(); cout &lt;&lt; *it; it ++; for(; it != st.end(); it ++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; *it; &#125; puts(&quot;&quot;); &#125; return 0;&#125;水果Problem Description夏天来了好开心啊,呵呵,好多好多水果Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.Input第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.Output对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.两组测试数据之间有一个空行.最后一组测试数据之后没有空行.1234567891011121314Sample Input15apple shandong 3pineapple guangdong 1sugarcane guangdong 1pineapple guangdong 3pineapple guangdong 1Sample Outputguangdong |----pineapple(5) |----sugarcane(1)shandong |----apple(3)code:12345678910111213141516171819202122232425262728293031323334353637// map的嵌套使用 #include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; map&lt;string, int&gt; count;&#125;;int main()&#123; int n, m; cin &gt;&gt; n; while(n --) &#123; map&lt;string, node&gt; mp; int x, num; string fruit, place; cin &gt;&gt; m; for(int i = 0; i &lt; m; i ++) &#123; cin &gt;&gt; fruit &gt;&gt; place &gt;&gt; num; mp[place].count[fruit] += num; &#125; map&lt;string, int&gt; :: iterator it1; map&lt;string, node&gt; :: iterator it2; for(it2 = mp.begin(); it2 != mp.end(); it2 ++) &#123; cout &lt;&lt; it2 -&gt; first &lt;&lt; endl; for(it1 = mp[it2 -&gt; first].count.begin(); it1 != mp[it2 -&gt; first].count.end(); it1 ++) &#123; cout &lt;&lt; &quot; |----&quot; &lt;&lt; it1 -&gt; first &lt;&lt; &quot;(&quot; &lt;&lt; it1 -&gt; second &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125; &#125; if(n) cout &lt;&lt; endl; &#125; return 0;&#125;Let the Balloon RiseProblem DescriptionContest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges’ favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.This year, they decide to leave this lovely job to you.InputInput contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) – the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.A test case with N = 0 terminates the input and this test case is not to be processed.OutputFor each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.123456789101112131415Sample Input5greenredblueredred3pinkorangepink0Sample Outputredpinkcode:12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxx = 10010;int main()&#123; int n; char name[20]; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if( n == 0) break; map&lt;string, int&gt; balloons; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; name; balloons[name] ++; &#125; map&lt;string, int&gt; :: iterator p, m; p = m = balloons.begin(); for(; p != balloons.end(); p ++) &#123; if(p -&gt; second &gt; m -&gt; second) m = p; &#125; cout &lt;&lt; m -&gt; first &lt;&lt; endl; &#125; return 0;&#125;不重复数字Problem Description给出N个数，要求把其中重复的去掉，只保留第一次出现的数。例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。Input输入第一行为正整数T，表示有T组数据。接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。Output对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。1234567891011121314151617181920Sample Input2111 2 18 3 3 19 2 3 6 5 461 2 3 4 5 6Sample Output1 2 18 3 19 6 5 41 2 3 4 5 6Hint对于30%的数据，1 &lt;= N &lt;= 100，给出的数不大于100，均为非负整数； 对于50%的数据，1 &lt;= N &lt;= 10000，给出的数不大于10000，均为非负整数； 对于100%的数据，1 &lt;= N &lt;= 50000，给出的数在32位有符号整数范围内。提示: 由于数据量很大，使用C++的同学请使用scanf和printf来进行输入输出操作，以免浪费不必要的时间。code:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int mod = 1e9;int main()&#123; int t, n, m; cin &gt;&gt; t; while(t --) &#123; scanf(&quot;%d&quot;,&amp;n); set&lt;int&gt; st; int a[50010]; int l = 0; for(int i = 0; i &lt; n; i ++) &#123; scanf(&quot;%d&quot;,&amp;m); if(st.count(m) == 0) &#123; st.insert(m); a[l ++] = m; &#125; &#125; for(int i = 0; i &lt; l - 1; i ++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; printf(&quot;%d\n&quot;, a[l - 1]); st.clear(); &#125; return 0;&#125;Andy’s First DictionaryProblem DescriptionAndy, 8, has a dream - he wants to produce his very own dictionary. This is not an easy task for him, as the number of words that he knows is, well, not quite enough. Instead of thinking up all the words himself, he has a briliant idea. From his bookshelf he would pick one of his favourite story books, from which he would copy out all the distinct words. By arranging the words inalphabetical order, he is done! Of course, it is a really time-consuming job, and this is where a computer program is helpful.You are asked to write a program that lists all the different words in the input text. In this problem, a word is defined as a consecutive sequence of alphabets, in upper and/or lower case. Words with only one letter are also to be considered. Furthermore, your program must be CaSe InSeNsItIvE. For example, words like “Apple”, “apple” or “APPLE” must be considered the same.InputThe input file is a text with no more than 5000 lines. An input line has at most 200 characters. Inputis terminated by EOF.OutputYour output should give a list of different words that appears in the input text, one in a line. Thewords should all be in lower case, sorted in alphabetical order. You can be sure that he number ofdistinct words in the text does not exceed 5000.123456789101112131415161718192021222324252627Sample InputAdventures in DisneylandTwo blondes were going to Disneyland when they came to a fork in theroad. The sign read: &quot;Disneyland Left.&quot;So they went home.Sample Outputaadventuresblondescamedisneylandforkgoinghomeinleftreadroadsignsothetheytotwowentwerewhencode:1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; set&lt;string&gt; se; while (cin &gt;&gt; s) &#123; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;) s[i] += 32; else if (s[i] &gt;= &apos;a&apos; &amp;&amp; s[i] &lt;= &apos;z&apos;) s[i] = s[i]; else s[i] = &apos; &apos;; &#125; string mi; stringstream mid(s); while (mid &gt;&gt; mi) &#123; se.insert(mi); &#125; &#125; for (set&lt;string&gt;::iterator it = se.begin(); it != se.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125;&#125;A and B and Compilation ErrorsProblem DescriptionA and B are preparing themselves for programming contests.B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.Initially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.Can you help B find out exactly what two errors he corrected?InputThe first line of the input contains integer n (3 ≤ n ≤ 105) — the initial number of compilation errors.The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 109) — the errors the compiler displayed for the first time.The third line contains n - 1 space-separated integers b1, b2, …, bn - 1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one.The fourth line contains n - 2 space-separated integers с1, с2, …, сn - 2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.OutputPrint two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.1234567891011121314151617181920ExamplesInput51 5 8 123 7123 7 5 15 1 7Output8123Input61 4 3 3 5 73 7 5 4 34 3 7 5Output13NoteIn the first test sample B first corrects the error number 8, then the error number 123.In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.code:123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx = 1e9;int main()&#123; int t, x, a = 0, b = 0, c = 0; scanf(&quot;%d&quot;,&amp;t); for(int i = 0; i &lt; t; i ++) &#123; cin &gt;&gt; x; a += x; &#125; for(int i = 0; i &lt; t - 1; i ++) &#123; cin &gt;&gt; x; b += x; &#125; for(int i = 0; i &lt; t - 2; i ++) &#123; cin &gt;&gt; x; c += x; &#125; printf(&quot;%d\n%d\n&quot;,a - b, b - c); return 0;&#125;排列2Problem DescriptionRay又对数字的列产生了兴趣：现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。Input每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。Output对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。每组输出数据间空一行，最后一组数据后面没有空行。123456789101112131415161718Sample Input1 2 3 41 1 2 30 1 2 30 0 0 0Sample Output1234 1243 1324 1342 1423 14322134 2143 2314 2341 2413 24313124 3142 3214 3241 3412 34214123 4132 4213 4231 4312 43211123 1132 1213 1231 1312 13212113 2131 23113112 3121 32111023 1032 1203 1230 1302 13202013 2031 2103 2130 2301 23103012 3021 3102 3120 3201 3210code:12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int a[4];int main()&#123; int t = 0, tmp; while(scanf(&quot;%d %d %d %d&quot;,&amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]) &amp;&amp; a[0] + a[1] + a[2] + a[3]) &#123; if(t) puts(&quot;&quot;); t = 1; int flag = 1; do &#123; if(a[0] == 0) continue; if(flag) &#123; cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3]; flag = 0; &#125; else if(tmp == a[0]) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3]; &#125; else &#123; puts(&quot;&quot;); cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3]; &#125; tmp = a[0]; &#125; while(next_permutation(a, a + 4)); puts(&quot;&quot;); &#125; return 0;&#125;Ignatius and the Princess IIProblem DescriptionNow our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, “I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.” Ignatius says confidently, “OK, at last, I will save the Princess.”“Now I will show you the first problem.” feng5166 says, “Given a sequence of number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it’s easy to see the second smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It’s easy, isn’t is? Hahahahaha……”Can you help Ignatius to solve this problem?InputThe input contains several test cases. Each test case consists of two numbers, N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a sequence satisfied the BEelzebub’s demand. The input is terminated by the end of file.OutputFor each test case, you only have to output the sequence satisfied the BEelzebub’s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number.123456Sample Input6 411 8Sample Output1 2 3 5 6 41 2 3 4 5 6 7 9 8 11 10code:123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx = 1e9;int a[1010];int main()&#123; int n, m; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m)) &#123; for(int i = 1; i &lt;= n; i ++) &#123; a[i] = i; &#125; for(int i = 1; i &lt; m; i ++) &#123; next_permutation(a + 1, a + n + 1); &#125; cout &lt;&lt; a[1]; for(int i = 2; i &lt;= n; i ++) &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; a[i]; &#125; puts(&quot;&quot;); &#125; return 0;&#125;ACboy needs your help again!Problem DescriptionACboy was kidnapped!!he miss his mother very much and is very scare now.You can’t image how dark the room he was put into is, so poor :(.As a smart ACMer, you want to get ACboy out of the monster’s labyrinth.But when you arrive at the gate of the maze, the monste say :” I have heard that you are very clever, but if can’t solve my problems, you will die with ACboy.”The problems of the monster is shown on the wall:Each problem’s first line is a integer N(the number of commands), and a word “FIFO” or “FILO”.(you are very happy because you know “FIFO” stands for “First In First Out”, and “FILO” means “First In Last Out”).and the following N lines, each line is “IN M” or “OUT”, (M represent a integer).and the answer of a problem is a passowrd of a door, so if you want to rescue ACboy, answer the problem carefully!InputThe input contains multiple test cases.The first line has one integer,represent the number oftest cases.And the input of each subproblem are described above.OutputFor each command “OUT”, you should output a integer depend on the word is “FIFO” or “FILO”, or a word “None” if you don’t have any integer.12345678910111213141516171819202122232425262728293031323334Sample Input44 FIFOIN 1IN 2OUTOUT4 FILOIN 1IN 2OUTOUT5 FIFOIN 1IN 2OUTOUTOUT5 FILOIN 1IN 2OUTIN 3OUTSample Output122112None23code:待补~]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day2]]></title>
    <url>%2F2019%2F07%2F19%2FDay2%2F</url>
    <content type="text"><![CDATA[Day2今天学习的是GCD + 素筛 + 快速幂因为以前有过基础，学的还行OJ链接：https://cn.vjudge.net/contest/312021Pseudoprime numbersProblem DescriptionFermat’s theorem states that for any prime number p and for any integer a &gt; 1, ap = a (mod p). That is, if we raise a to the pth power and divide by p,the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a.(And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)Given 2 &lt; p ≤ 1000000000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime.InputInput contains several test cases followed by a line containing “0 0”. Each test case consists of a line containing p and a.OutputFor each test case, output “yes” if p is a base-a pseudoprime; otherwise output “no”.123456789101112131415Sample Input3 210 3341 2341 31105 21105 30 0Sample Outputnonoyesnoyesyescode:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;ll quick_pow(ll a, ll n)&#123; ll res = 1; ll m = n; while(m) &#123; if(m &amp; 1) res = res * a % n; a = a * a % n; m &gt;&gt;= 1; &#125; return res;&#125;bool prime(int n)&#123; for(int i = 2;i * i &lt; n; i ++) &#123; if(n % i == 0) return false; &#125; return true;&#125;int main()&#123; int n, m; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m) &amp;&amp; n) &#123; if(prime(n)) puts(&quot;no&quot;); else if(quick_pow(m, n) == m) puts(&quot;yes&quot;); else puts(&quot;no&quot;); &#125;// 求出若p不是素数并且p^a是否等于a，若等于则输出yes,否则输出no return 0;&#125;Raising Modulo NumbersProblem DescriptionPeople are different. Some secretly read magazines full of interesting girls’ pictures, others create an A-bomb in their cellar,others like using Windows, and some like difficult mathematical games. Latest marketing research shows, that this market segment was so far underestimated and that there is lack of such games. This kind of game was thus included into the KOKODáKH. The rules follow:Each player chooses two numbers Ai and Bi and writes them on a slip of paper. Others cannot see the numbers. In a given moment all players show their numbers to the others. The goal is to determine the sum of all expressions Ai Bifrom all players including oneself and determine the remainder after division by a given number M. The winner is the one whofirst determines the correct result. According to the players’ experience it is possible to increase the difficulty by choosing higher numbers.You should write a program that calculates the result and is able to find out who won the game.InputThe input consists of Z assignments. The number of them is given by the single positive integer Z appearing on the first line of input.Then the assignements follow. Each assignement begins with line containing an integer M (1 &lt;= M &lt;= 45000). The sum will be divided by this number.Next line contains number of players H (1 &lt;= H &lt;= 45000). Next exactly H lines follow. On each line,there are exactly two numbers Ai and Bi separated by space. Both numbers cannot be equal zero at the same time.OutputFor each assingnement there is the only one line of output. On this line, there is a number, the result of expression(A1B1+A2B2+ … +AHBH)mod M.123456789101112131415161718Sample Input31642 33 44 55 63612312374859 30293821713 18132Sample Output21319513code:123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;ll quick_pow(ll a, ll b, ll mod)&#123; ll res = 1; while(b) &#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; int t, n, M, a, b; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; M; cin &gt;&gt; n; ll ans = 0; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;&gt; a &gt;&gt; b; ans += quick_pow(a, b, M); &#125; cout &lt;&lt; ans % M &lt;&lt; endl; &#125; return 0;&#125;Wolf and RabbitProblem DescriptionThere is a hill with n holes around. The holes are signed from 0 to n-1. A rabbit must hide in one of the holes. A wolf searches the rabbit in anticlockwise order. The first hole he get into is the one signed with 0. Then he will get into the hole every m holes. For example, m=2 and n=6, the wolf will get into the holes which are signed 0,2,4,0.If the rabbit hides in the hole which signed 1,3 or 5, she will survive. So we call these holes the safe holes.InputThe input starts with a positive integer P which indicates the number of test cases. Then on the following P lines,each line consists 2 positive integer m and n(0&lt;m,n&lt;2147483648).OutputFor each input m n, if safe holes exist, you should output “YES”, else output “NO” in a single line.1234567Sample Input21 22 2Sample OutputNOYEScode:12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx=1e5;int gcd(int a, int b)&#123; return !b ? a : gcd(b, a % b); &#125;int main()&#123; int p, n, m; cin &gt;&gt; p; while(p --) &#123; cin &gt;&gt; n &gt;&gt; m; if(gcd(n, m) == 1) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; &#125; return 0;&#125;CakeProblem Description一次生日Party可能有p人或者q人参加,现准备有一个大蛋糕.问最少要将蛋糕切成多少块(每块大小不一定相等),才能使p人或者q人出席的任何一种情况,都能平均将蛋糕分食.Input每行有两个数p和q.Output输出最少要将蛋糕切成多少块.123456789Sample Input2 3Sample Output4Hint将蛋糕切成大小分别为1/3,1/3,1/6,1/6的四块即满足要求.当2个人来时，每人可以吃1/3+1/6=1/2 , 1/2块。当3个人来时，每人可以吃1/6+1/6=1/3 , 1/3, 1/3块。code:12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a, int b)&#123; return !b ? a : gcd(b, a % b);&#125;int main()&#123; int n, m ; while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m)) &#123; cout &lt;&lt; n + m - gcd(n, m) &lt;&lt; endl; &#125; return 0;&#125;/*如果实在看不懂提题意,记住规律就好了，下面是较为好理解的题解 将蛋糕切成几块，我想可以把它理解为切多少刀更加易懂。开始思考的是依照蛋糕的大小来计算，结果涉及到了浮点型数据处理，求余，求商等让人很乱，结果当然也不能ＡＣ，所以果断弃了。一个数ａ的因数ｂ，放在这道题中可以使人理解成，想要把蛋糕分成ａ块，先切ｂ刀，（一次切的长度为蛋糕的半径）再在剩余的ｂ份中，平均分成ａ／ｂ份，每份需要再切ａ／ｂ－１刀，其余蛋糕切ａ－ｂ刀，共切ａ刀。而如果另一个数ｃ与ａ有公因数ｂ，则设第一次切好后蛋糕摆放没有变，则需要先切ｂ刀，在平均每份切ｃ／ｂ－１刀，共再切ｃ－ｂ刀，而为了达到块数最小，尽量使用第一次切好的刀缝。第一次的ｂ刀已经不用切取。故最终需要切ａ＋ｃ－ｄ次，分成ａ＋ｃ－ｄ块。由此可见，为了得到最小块数，需要ｄ最大，是两个数的最大公约数。*/又见GCDProblem Description有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。Input第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。Output输出对应的c，每组测试数据占一行。1234567Sample Input26 212 4Sample Output48code:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx=1e5;int gcd(int a, int b)&#123; return !b ? a : gcd(b, a % b); &#125;int main()&#123; int n; int a, b; int ans; cin &gt;&gt; n; while(n --) &#123; cin &gt;&gt; a &gt;&gt; b; int i; for(i = 1;;i ++) &#123; if(b == gcd(a, i) &amp;&amp; b != i) break; &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125;最小公倍数Problem Description给定两个正整数，计算这两个数的最小公倍数。Input输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.Output对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。1234Sample Input10 14Sample Output70code:12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx=1e5;int gcd(int a, int b)&#123; return !b ? a : gcd(b, a % b);&#125;int main()&#123; int a, b; while(scanf(&quot;%d %d&quot;,&amp;a, &amp;b)!=EOF) &#123; cout &lt;&lt; a * b / gcd(a, b) &lt;&lt; endl; &#125; return 0;&#125;素数判定Problem Description对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。Input输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。Output对于每个给定范围内的取值，如果表达式的值都为素数，则输出”OK”,否则请输出“Sorry”,每组输出占一行。12345Sample Input0 10 0Sample OutputOKcode:12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx=1e5;int main()&#123; int x, y; while(scanf(&quot;%d %d&quot;,&amp;x, &amp;y)!=EOF) &#123; if(x == 0 &amp;&amp; y == 0) break; int flag = 0; int ans; for(int n = x; n &lt;= y; n ++) &#123; ans = n * n + n + 41; for(int i = 2; i &lt;= sqrt(ans); i ++) &#123; if(ans % i == 0) flag = 1; &#125; &#125; if(flag) cout &lt;&lt; &quot;Sorry&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl; &#125; return 0;&#125;分拆素数和Problem Description把一个偶数拆成两个不同素数的和，有几种拆法呢？Input输入包含一些正的偶数，其值不会超过10000，个数不会超过500，若遇0，则结束。Output对应每个偶数，输出其拆成不同素数的个数，每个结果占一行。1234567Sample Input30260Sample Output32code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int maxx = 10001;bool a[maxx];void isprim()&#123; int i, j; memset(a, true, sizeof(a)); for(i = 3; i &lt; maxx; i ++) &#123; for(j = 2; j &lt; i; j ++) &#123; if(i % j == 0) a[i] = false; &#125; &#125;&#125;int main()&#123; int n; isprim(); a[0] = a[1] = false; a[2] = true; while(scanf(&quot;%d&quot;, &amp;n)!=EOF) &#123; if(n == 0) break; int ans = 0; for(int i = 2; i &lt; n / 2; i ++) &#123; if(a[i] &amp;&amp; a[n - i]) ans ++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; //2 3 5 7 11 13 17 19 23 29 return 0;&#125;美素数Problem Description小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。给定一个区间，你能计算出这个区间内有多少个美素数吗？Input第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。Output对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。每组数据占一行，具体输出格式参见样例。123456789Sample Input31 1002 23 19Sample OutputCase #1: 14Case #2: 1Case #3: 4code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//美素数，双重打表 #include&lt;bits/stdc++.h&gt;using namespace std;#define mod 1000000+5bool a[mod];int ans[mod];void isprime()&#123; int n, m; memset(a, true, sizeof(a)); a[0] = a[1]= false; for(int i = 2; i &lt; mod; i ++) &#123; for(int j = 2; j * i &lt; mod; j ++) &#123; a[i * j] = false; &#125; &#125;&#125;int SUM(int n)&#123; int sum = 0; while(n) &#123; sum += n % 10; n /= 10; &#125; return sum;&#125;int main()&#123; int t, n, m; isprime(); memset(ans, 0, sizeof(ans)); int shu = 1, num = 0; for(int i = 2; i &lt; mod; i ++) &#123; if(a[i] &amp;&amp; a[SUM(i)]) num ++; ans[i] = num; &#125; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; n &gt;&gt; m; printf(&quot;Case #%d: %d\n&quot;,shu ++, ans[m] - ans[n - 1]); &#125; return 0;&#125;Key SetProblem Descriptionsoda has a set Swith n integers {1,2,…,n}. A set is called key set if the sum of integers in the set is an even number. He wants to know how many nonempty subsets of Sare key set.InputThere are multiple test cases. The first line of input contains an integer T(1≤T≤10^5),indicating the number of test cases. For each test case: The first line contains an integer n(1≤n≤109), the number of integers in the set.OutputFor each test case, output the number of key sets modulo 1000000007.1234567891011Sample Input41234Sample Output0137code:12345678910111213141516171819202122232425262728293031323334//规律题#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const int mod = 1000000007;ll quick_pow(ll a, ll n)&#123; ll res = 1; while(n) &#123; if(n &amp; 1) res = res * a % mod; a = a * a % mod; n &gt;&gt;= 1; &#125; return res % mod;&#125;int main()&#123; int t, n; cin &gt;&gt; t; while(t --) &#123; cin &gt;&gt; n; cout &lt;&lt; quick_pow(2, n - 1) - 1 &lt;&lt; endl; &#125; return 0;&#125;//2 ^ (n - 1) - 1人见人爱A^BProblem Description求A^B的最后三位数表示的整数。说明：A^B的含义是“A的B次方”Input输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。Output对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。123456789Sample Input2 312 66789 100000 0Sample Output89841code:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;typedef long long ll;ll quick_pow(ll a, ll n)&#123; ll res = 1; while(n) &#123; if(n &amp; 1) res = res * a % mod; a = a * a % mod; n &gt;&gt;= 1; &#125; return res % mod;&#125;int main()&#123; int x, y; while(scanf(&quot;%d %d&quot;,&amp;x, &amp;y)!=EOF) &#123; if(x == 0 &amp;&amp; y == 0) break; cout &lt;&lt; quick_pow(x, y) % 1000 &lt;&lt; endl; &#125; return 0;&#125;Rightmost DigitProblem DescriptionGiven a positive integer N, you should output the most right digit of N^N.InputThe input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.Each test case contains a single positive integer N(1&lt;=N&lt;=1,000,000,000).OutputFor each test case, you should output the rightmost digit of N^N.1234567891011Sample Input234Sample Output76HintIn the first case, 3 * 3 * 3 = 27, so the rightmost digit is 7.In the second case, 4 * 4 * 4 * 4 = 256, so the rightmost digit is 6.code:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int mod = 1e9;typedef long long ll;ll quick_pow(ll x, ll n)&#123; ll res = 1; while(n) &#123; if(n &amp; 1) res = res * x % mod; x = x * x % mod; n &gt;&gt;= 1; &#125; return res % mod;&#125;int main()&#123; int n, m; cin &gt;&gt; n; while(n --) &#123; cin &gt;&gt; m; cout &lt;&lt; quick_pow(m, m) % 10 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day1]]></title>
    <url>%2F2019%2F07%2F18%2F40%E5%A4%A9acm%E9%9B%86%E8%AE%ADDay1%2F</url>
    <content type="text"><![CDATA[Day1今天学习的是sort + 结构体 + 简单数学 + 暴力比较菜，学习的比较慢，勉强能掌握OJ链接：https://cn.vjudge.net/contest/312050从这个OJ开始，往后的OJ链接只需要在网上输入每个题的名称就能找到对应的OJ前m大的数Problem Description还记得Gardon给小希布置的那个作业么？（上次比赛的1005）其实小希已经找回了原来的那张数表，现在她想确认一下她的答案是否正确，但是整个的答案是很庞大的表，小希只想让你把答案中最大的M个数告诉她就可以了。给定一个包含N(N&lt;=3000)个正整数的序列，每个数不超过5000，对它们两两相加得到的N*(N-1)/2个和，求出其中前M大的数(M&lt;=1000)并按从大到小的顺序排列。Input输入可能包含多组数据，其中每组数据包括两行：第一行两个数N和M，第二行N个数，表示该序列。Output对于输入的每组数据，输出M个数，表示结果。输出应当按照从大到小的顺序排列。Sample Input12344 41 2 3 44 55 3 6 4Sample Output127 6 5 511 10 9 9 8Solve:直接开大数组，暴力code:12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int cmp(int a, int b)&#123; return a b;&#125;int n, m;int a[3001];int b[5000000];int main()&#123; while(scanf(&quot;%d %d&quot;,&amp;n, &amp;m)!=EOF) &#123; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;a[i]; &#125; int t = 0; sort(a, a + n, cmp); int ans = 0; for(int i = ans + 1; i &lt; n; i ++) &#123; b[t ++] = a[i] + a[ans]; if(i == n - 1 &amp;&amp; ans != n ) &#123; i = ans + 1; ans ++; &#125; &#125; sort(b, b + t, cmp); for(int i = 0; i &lt; m; i ++) &#123; if(i == 0) cout &lt;&lt; b[0]; else cout &lt;&lt; &apos; &apos; &lt;&lt; b[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;稳定排序Problem Description大家都知道，快速排序是不稳定的排序方法。如果对于数组中出现的任意a[i],aj,其中a[i]==a[j]，在进行排序以后a[i]一定出现在a[j]之前，则认为该排序是稳定的。某高校招生办得到一份成绩列表，上面记录了考生名字和考生成绩。并且对其使用了某排序算法按成绩进行递减排序。现在请你判断一下该排序算法是否正确，如果正确的话，则判断该排序算法是否为稳定的。Input本题目包含多组输入，请处理到文件结束。对于每组数据，第一行有一个正整数N(0&lt;N&lt;300)，代表成绩列表中的考生数目。接下来有N行，每一行有一个字符串代表考生名字(长度不超过50，仅包含’a’~’z’),和一个整数代表考生分数(小于500)。其中名字和成绩用一个空格隔开。再接下来又有N行，是上述列表经过某排序算法以后生成的一个序列。格式同上。Output对于每组数据，如果算法是正确并且稳定的，就在一行里面输出”Right”。如果算法是正确的但不是稳定的，就在一行里面输出”Not Stable”，并且在下面输出正确稳定排序的列表，格式同输入。如果该算法是错误的，就在一行里面输出”Error”,并且在下面输出正确稳定排序的列表，格式同输入。注意，本题目不考虑该排序算法是错误的，但结果是正确的这样的意外情况。Sample Input1234567891011121314151617181920213aa 10bb 10cc 20cc 20bb 10aa 103aa 10bb 10cc 20cc 20aa 10bb 103aa 10bb 10cc 20aa 10bb 10cc 20Sample Output123456789Not Stablecc 20aa 10bb 10RightErrorcc 20aa 10bb 10Solve: 看清题意,慢慢理清思路code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string name; int sorce, id;&#125;stu[301], stu_1[301];//比较函数，若分数相同，则先出现的标记并按递增的方式排序 int cmp1(node a,node b)&#123; if(a.sorce == b.sorce) return a.id &lt; b.id; return a.sorce b.sorce;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;stu[i].name &gt;stu[i].sorce; stu[i].id = i; &#125; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;stu_1[i].name &gt;stu_1[i].sorce; &#125; //正确排序首先给出的序列 sort(stu, stu + n, cmp1); int flag = 0; //做标记 for(int i = 0; i &lt; n - 1; i ++) &#123; //这个是经过体面意思排序过的，直接通过分数的排序判断是否稳定 if(stu_1[i].sorce &lt; stu_1[i + 1].sorce) &#123; flag = 1;//表示错误 break; &#125; &#125; if(flag) &#123; puts(&quot;Error&quot;); for(int i = 0; i &lt; n; i ++) &#123; cout &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].sorce &lt;&lt; endl; &#125; &#125; else &#123; //判断是否稳定 for(int i = 0; i &lt; n; i ++) &#123; if(stu[i].name != stu_1[i].name) &#123; flag = 1;//不稳定 break; &#125; &#125; if(flag) &#123; puts(&quot;Not Stable&quot;); for(int i = 0; i &lt; n; i ++) &#123; cout &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].sorce &lt;&lt; endl; &#125; &#125; else &#123; puts(&quot;Right&quot;); &#125; &#125; &#125; return 0;&#125;开门人和关门人Problem Description每天第一个到机房的人要把门打开，最后一个离开的人要把门关好。现有一堆杂乱的机房签到、签离记录，请根据记录找出当天开门和关门的人。Input测试输入的第一行给出记录的总天数N ( 0 )。下面列出了N天的记录。每天的记录在第一行给出记录的条目数M ( 0 )，下面是M行，每行的格式为证件号码 签到时间 签离时间其中时间按“小时:分钟:秒钟”（各占2位）给出，证件号码是长度不超过15的字符串。Output对每一天的记录输出1行，即当天开门和关门人的证件号码，中间用1空格分隔。注意：在裁判的标准测试输入中，所有记录保证完整，每个人的签到时间在签离时间之前，且没有多人同时签到或者签离的情况。Sample Input1234567891031ME3021112225321 00:00:00 23:59:592EE301218 08:05:35 20:56:35MA301134 12:35:45 21:40:423CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40Sample Output123ME3021112225321 ME3021112225321EE301218 MA301134SC3021234 CS301133Solve: 注意时间的转化code:123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; char name[20]; int s_hour,s_min,s_sec; int e_hour,e_min,e_sec; int s, e;&#125;a[1000];int cmp1(node a, node b)&#123; return a.s &lt; b.s;&#125;int cmp2(node a, node b)&#123; return a.e b.e;&#125;int main()&#123; int n, m; cin &gt;n; while(n --) &#123; cin &gt;m; for(int i = 0; i &lt; m; i ++) &#123; scanf(&quot;%s %d:%d:%d %d:%d:%d&quot;,&amp;a[i].name, &amp;a[i].s_hour,&amp;a[i].s_min,&amp;a[i].s_sec, &amp;a[i].e_hour, &amp;a[i].e_min, &amp;a[i].e_sec); a[i].s = a[i].s_hour * 3600 + a[i].s_min * 60 + a[i].s_sec; a[i].e = a[i].e_hour * 3600 + a[i].e_min * 60 + a[i].e_sec; &#125; sort(a, a + m, cmp1); cout &lt;&lt; a[0].name &lt;&lt; &apos; &apos;; sort(a, a + m, cmp2); cout &lt;&lt; a[0].name &lt;&lt; endl; &#125; return 0;&#125;EXCEL排序Problem DescriptionExcel可以对一组纪录按任意指定列排序。现请你编写程序实现类似功能。Input测试输入包含若干测试用例。每个测试用例的第1行包含两个整数 N (&lt;=100000) 和 C，其中 N 是纪录的条数，C 是指定排序的列号。以下有 N行，每行包含一条学生纪录。每条学生纪录由学号（6位数字，同组测试中没有重复的学号）、姓名（不超过8位且不包含空格的字符串）、成绩（闭区间[0, 100]内的整数）组成，每个项目间用1个空格隔开。当读到 N=0 时，全部输入结束，相应的结果不要输出。Output对每个测试用例，首先输出1行“Case i:”，其中 i 是测试用例的编号（从1开始）。随后在 N 行中输出按要求排序后的结果，即：当 C=1 时，按学号递增排序；当 C=2时，按姓名的非递减字典序排序；当 C=3时，按成绩的非递减排序。当若干学生具有相同姓名或者相同成绩时，则按他们的学号递增排序。Sample Input1234567891011121314153 1000007 James 85000010 Amy 90000001 Zoe 604 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 984 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 900 0Sample Output1234567891011121314Case 1:000001 Zoe 60000007 James 85000010 Amy 90Case 2:000010 Amy 90000002 James 98000007 James 85000001 Zoe 60Case 3:000001 Zoe 60000007 James 85000002 James 90000010 Amy 90Solve:仔细读题，看清题意在写code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string number; string name; int sorce;&#125;stu[100001];bool cmp1(node x, node y)&#123; return x.number &lt; y.number;&#125;bool cmp2(node x, node y)&#123; if(x.name == y.name) return x.number &lt; y.number; return x.name &lt; y.name;&#125;bool cmp3(node x, node y)&#123; if(x.sorce == y.sorce) return x.number &lt; y.number; return x.sorce &lt; y.sorce;&#125;int main()&#123; int n, c; int t = 1; while(scanf(&quot;%d %d&quot;,&amp;n, &amp;c)!=EOF) &#123; if(n == 0 &amp;&amp; c == 0) break; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;stu[i].number &gt;stu[i].name &gt;stu[i].sorce; &#125; if(c == 1) sort(stu, stu + n, cmp1);// if(c == 1) sort(stu.number.begin(), stu.number.end()); string特定的排序方式 else if(c == 2) sort(stu, stu + n, cmp2); else if(c == 3) sort(stu, stu + n, cmp3); printf(&quot;Case %d:\n&quot;,t ++); for(int i = 0; i &lt; n; i ++) &#123; cout &lt;&lt; stu[i].number &lt;&lt; &apos; &apos; &lt;&lt; stu[i].name&lt;&lt; &apos; &apos; &lt;&lt; stu[i].sorce &lt;&lt; endl; &#125; &#125; return 0;&#125;统计同成绩学生人数Problem Description读入N名学生的成绩，将获得某一给定分数的学生人数输出。Input测试输入包含若干测试用例，每个测试用例的格式为第1行：N第2行：N名学生的成绩，相邻两数字用一个空格间隔。第3行：给定分数当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。Output对每个测试用例，将获得给定分数的学生人数输出。Sample Input12345678910380 60 9060285 660560 75 90 55 75750Sample Output123102Solve:简单题code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; int a[1001]; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; int ans = 0; if(n == 0) break; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;a[i]; &#125; cin &gt;m; for(int i = 0; i &lt; n ; i ++) &#123; if(a[i] == m) ans ++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;What Is Your Grade?Problem Description“Point, point, life of student!”This is a ballad（歌谣）well known in colleges, and you must care about your score in this exam too. How many points can you get? Now, I told you the rules which are used in this course.There are 5 problems in this final exam. And I will give you 100 points if you can solve all 5 problems; of course, it is fairly difficulty for many of you. If you can solve 4 problems, you can also get a high score 95 or 90 (you can get the former(前者) only when your rank is in the first half of all students who solve 4 problems). Analogically（以此类推）, you can get 85、80、75、70、65、60. But you will not pass this exam if you solve nothing problem, and I will mark your score with 50.Note, only 1 student will get the score 95 when 3 students have solved 4 problems.I wish you all can pass the exam!Come on!InputInput contains multiple test cases. Each test case contains an integer N (1&lt;=N&lt;=100, the number of students) in a line first, and then N lines follow. Each line contains P (0&lt;=P&lt;=5 number of problems that have been solved) and T（consumed time）. You can assume that all data are different when 0&lt;p.A test case starting with a negative integer terminates the input and this test case should not to be processed.OutputOutput the scores of N students in N lines for each case, and there is a blank line after each case.Sample Input1234567845 06:30:174 07:31:274 08:12:124 05:23:1315 06:30:17-1Sample Output123456100909095100Solve:仔细理解题意，认真写code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//第一种//#include &lt;iostream&gt;//#include&lt;cstdio&gt;//#include&lt;cstring&gt;//#include&lt;algorithm&gt;//using namespace std;//struct node//&#123;// int x;// char s[10];//&#125;a[101];//int main()//&#123;// int n;// while(scanf(&quot;%d&quot;,&amp;n),n!=-1)// &#123;// for(int i=0;i&lt;n;i++)// scanf(&quot;%d %s&quot;,&amp;a[i].x,a[i].s);// int t[5]=&#123;0&#125;;// for(int i=4;i&gt;0;i--)//做出相同题数的人的个数// &#123;// for(int j=0;j&lt;n;j++)// &#123;// if(a[j].x==i) t[i]++;// &#125;// &#125;// for(int i=0;i&lt;n;i++)// &#123;// if(a[i].x==5) printf(&quot;100\n&quot;);// else if (a[i].x==0) printf(&quot;50\n&quot;);// else// &#123;// int k=0;// for(int j=0;j&lt;n;j++)// &#123;// if(a[j].x==a[i].x&amp;&amp;strcmp(a[j].s,a[i].s)&lt;0)////头文件是string,实质就是a[j].s&lt;a[i].s// k++;// &#125;// if(k&gt;=t[a[i].x]/2)////相同题数用时短的人数做出相同题数的总人数一半// printf(&quot;%d\n&quot;,100-(5-a[i].x)*10);// else// printf(&quot;%d\n&quot;,100-(5-a[i].x)*10+5);// &#125;// &#125;// printf(&quot;\n&quot;);// &#125;// return 0;//&#125;//第二种#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;struct ssq&#123; int x; char t[20]; int fs;&#125;sq[1005];int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n&gt;0) &#123; int s[10],ss[10]; memset(s,0,sizeof(s)); memset(ss,0,sizeof(ss)); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d %s&quot;,&amp;sq[i].x,sq[i].t); s[sq[i].x]++;//记录做完题数对应数量人数 sq[i].fs=0;//分数归0 &#125; for(int i=0;i&lt;n;i++)//遍历结构体 &#123; if(sq[i].x==5)//特殊处理5题 sq[i].fs=100; else if(sq[i].x==0)//特殊处理0题 sq[i].fs=50; else &#123; if(s[sq[i].x]==1)//特殊处理做对1题 sq[i].fs=(sq[i].x*10+55); else if(ss[sq[i].x]&lt;s[sq[i].x]/2&amp;&amp;sq[i].fs==0)//找出本题数中最小耗时 &#123; int v=i;//记录位置当前 for(int j=0;j&lt;n;j++) &#123; if(sq[j].fs==0&amp;&amp;sq[j].x==sq[v].x&amp;&amp;strcmp(sq[j].t,sq[v].t)&lt;0)//更改最小耗时位置 v=j; &#125; ss[sq[i].x]++;//记录已经找出的最小耗时人数 sq[v].fs=55+sq[v].x*10;//更改分数 &#125; &#125; &#125; for(int i=0;i&lt;n;i++) &#123; if(sq[i].fs!=0) printf(&quot;%d\n&quot;,sq[i].fs); else printf(&quot;%d\n&quot;,sq[i].x*10+50);//没有分值的赋基础分值 &#125; printf(&quot;\n&quot;); &#125; return 0;&#125;Magical BamboosProblem DescriptionIn a magical forest, there exists N bamboos that don’t quite get cut down the way you would expect.Originally, the height of the ith bamboo is equal to hi. In one move, you can push down a bamboo and decrease its height by one, but this move magically causes all the other bamboos to increase in height by one.If you can do as many moves as you like, is it possible to make all the bamboos have the same height?InputThe first line of input is T – the number of test cases.The first line of each test case contains an integer N (1 ≤ N ≤ 105) - the number of bamboos.The second line contains N space-separated integers hi (1 ≤ hi ≤ 105) - the original heights of the bamboos.OutputFor each test case, output on a single line “yes” (without quotes), if you can make all the bamboos have the same height, and “no” otherwise.Input12345232 4 221 2Output12yesnoSolve:找规律code:1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000007];int main()&#123; int n, m; scanf(&quot;%d&quot;,&amp;n); while(n --) &#123; scanf(&quot;%d&quot;,&amp;m); int t = 0; for(int i = 0; i &lt; m; i ++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(int i = 0; i &lt; m - 1; i ++) &#123; if((a[i + 1] - a[i]) % 2 != 0) &#123; t = 1; break; &#125; &#125; if(t == 1) printf(&quot;no\n&quot;); else printf(&quot;yes\n&quot;); &#125; return 0;&#125;Bear and Three BallsProblem DescriptionLimak is a little polar bear. He has n balls, the i-th ball has size ti.Limak wants to give one ball to each of his three friends. Giving gifts isn’t easy — there are two rules Limak must obey to make friends happy:No two friends can get balls of the same size.No two friends can get balls of sizes that differ by more than 2.For example, Limak can choose balls with sizes 4, 5 and 3, or balls with sizes 90, 91 and 92. But he can’t choose balls with sizes 5, 5 and 6 (two friends would get balls of the same size), and he can’t choose balls with sizes 30, 31 and 33 (because sizes 30 and 33 differ by more than 2).Your task is to check whether Limak can choose three balls that satisfy conditions above.InputThe first line of the input contains one integer n (3 ≤ n ≤ 50) — the number of balls Limak has.The second line contains n integers t1, t2, …, tn (1 ≤ ti ≤ 1000) where ti denotes the size of the i-th ball.OutputPrint “YES” (without quotes) if Limak can choose three balls of distinct sizes, such that any two of them differ by no more than 2. Otherwise, print “NO” (without quotes).Examples123456789101112131415Input 418 55 16 17Output YESInput 640 41 43 44 44 44Output NOInput 85 972 3 4 1 4 970 971Output YES123456NoteIn the first sample, there are 4 balls and Limak is able to choose three of them to satisfy the rules. He must must choose balls with sizes 18, 16 and 17.In the second sample, there is no way to give gifts to three friends without breaking the rules.In the third sample, there is even more than one way to choose balls:Choose balls with sizes 3, 4 and 5. Choose balls with sizes 972, 970, 971.Solve:找规律code:123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; int a[100001], b[100001]; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; int ans = 0; int t = 1; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;a[i]; &#125; sort(a, a + n); for(int i = 0; i &lt; n; i ++) &#123; if(binary_search(a, a + n, a[i] + 1) &amp;&amp; binary_search(a, a + n, a[i] + 2)) &#123; ans = 1; break; &#125; &#125; if(ans == 1) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;今年暑假不ACProblem Description12345678“今年暑假不AC？” “是的。” “那你干什么呢？” “看世界杯呀，笨蛋！” “@#$%^&amp;*%...” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。 作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。1234567891011121314151617Sample Input121 33 40 73 815 1915 2010 158 186 125 104 142 90Sample Output5Solve:头尾对接code:1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int start, end;&#125;g[101];int cmp(node x, node y)&#123; return x.end &lt; y.end;&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; if(n == 0) break; int ans = 1; for(int i = 0; i &lt; n; i ++) &#123; cin &gt;g[i].start &gt;g[i].end; &#125; sort(g, g + n, cmp); int s = g[0].end; for(int i = 1;i &lt; n; i ++) &#123; if(g[i].start &gt;= s) &#123; ans ++; s = g[i].end; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;The sum problemProblem DescriptionGiven a sequence 1,2,3,……N, your job is to calculate all the possible sub-sequences that the sum of the sub-sequence is M.InputInput contains multiple test cases. each case contains two integers N, M( 1 &lt;= N, M &lt;= 1000000000).input ends with N = M = 0.OutputFor each test case, print all the possible sub-sequence that its sum is M.The format is show in the sample below.print a blank line after each test case.123456789101112Sample Input20 1050 300 0Sample Output[1,4][10,10][4,8][6,9][9,11][30,30]Solve:找规律，数学思维code:1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n, m; while(scanf(&quot;%d %d&quot;,&amp;n, &amp;m)!=EOF) &#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = sqrt(2 * m); i &gt;= 1; i --) &#123; //s = a1 * i + i * (i - 1) / 2; int a1 = (m - i * (i - 1) / 2) / i; if((a1 * i) + i * (i - 1) / 2 == m) printf(&quot;[%d,%d]\n&quot;,a1, a1 + i - 1); &#125; puts(&quot;&quot;); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>集训</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>ACM</tag>
        <tag>算法集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[资源收集]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[特别说明写下这个页面的目的只是为了提供一些好的资源以供今后的学习做一些铺垫~~~以后将会持续更新发张好看的图片镇楼！！优化网站：https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_129大佬博客链接https://www.itrhx.com/2019/02/10/A18-Free-CDN-jsDeliver+Github/]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL简介]]></title>
    <url>%2F2019%2F07%2F12%2FMySQL%2F</url>
    <content type="text"><![CDATA[什么是数据库？？数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。1234每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：1.数据以表格的形式出现2.每行为各种记录名称3.每列为记录名称所对应的数据域4.许多的行和列组成一张表单5.若干的表单组成databaseRDBMS术语12345678910数据库: 数据库是一些关联表的集合。数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。基础知识12345表头(header): 每一列的名称;列(col): 具有相同数据类型的数据的集合;行(row): 每一行用来描述某条记录的具体信息;值(value): 行的具体信息, 每个值必须与该列的数据类型相同;键(key): 键的值在当前列中具有唯一性。MySQL简介MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。相关内容：1234567MySQL 是开源的，所以你不需要支付额外的费用。MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。MySQL 使用标准的 SQL 数据语言形式。MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request]]></title>
    <url>%2F2019%2F07%2F06%2Frequest%2F</url>
    <content type="text"><![CDATA[前提摘要想写下这一篇的原因还是起源于在网上下载图片的时候一张一张下载的太慢而且麻烦，所以就想着写一个东西， 能够快速批量下载。于是，就有了爬虫的想法，当然，以我现有水平只能够用request去爬取，爬虫的相关内容会在以后慢慢更新的一句话，我用爬虫就是用来下载资源的~后面会更新相关内容来完善。。。。注意:以下内容都是以python3为基础实现简单介绍网络爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。 服务器的交互方式http中与服务器定义的几种基本交互方式，get、post、delete、put、head和options。get请求常用于查询获取资源信息，常见表现形式url传递参数数据， 以？开始&amp;分隔参数值。post请求向服务器提交数据。put请求向服务器端发送信息修改数据。delete请求向服务器发送信息删除数据。基础先要了解request是一个模块，在python中就是一个库，用来抓取网上资源的 下载requests模块 若是安装过python3，则命令端输入`pip install requests`即可 用法先导入`requests`模块(这个模块名称为requests)只不过平时都说是request了，这一点不能弄错 import requests 与请求网址交互 1234requests.get(&quot;url&quot;)requests.post(&quot;url&quot;)requests.put(&quot;url&quot;)request.delete(&quot;url&quot;) 说一下常用的GET请求： 两种方法： 1.直接传: 例如：requests.get(&quot;http://www.baidu.com&quot;) 2.间接传: 例如：url = &quot;http://www.baidu.com&quot; requests.get(url=url) 间接传的好处是可以添加其他参数 常用属性和方法1234567url #打印返回地址text #以文本方式返回html源码content #以字节流返回html源码cookies #返回cookies信息status_code #打印状态码headers #返回html头信息encoding #处理字符集get请求回复对象所包含的属性：12345678resp = requests.get()resp.text 获取网站源码（字符串类型）resp.encoding 访问或定制编码方式,如一般所得网页源码出现乱码的情况下可以设置：resp.encoding=&apos;gb2312&apos;resp.url 获取请求的urlresp.content 获取网站源码，但响应的是字节类型resp.status_code 响应的状态码resp.headers 响应的头信息resp.json() 获取json数据]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优美文章]]></title>
    <url>%2F2019%2F07%2F04%2F%E4%BC%98%E7%BE%8E%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[摘要每一个人都不是超人，都不可能会有无穷的精力，但还是需要我们努力的奔跑！基于此，于考试的紧张期间写下一些感悟文章来反思自己，生活不需要一致的工作和学习，偶尔也需要一些放松。活在当下，立足当下，去努力，去超越。这个世界很大，你不打算去看看嘛？最后，奉上座右铭：我并不想着去超越谁，只是想比昨天的自己强一点点······以下内容从网上摘抄而来，并非自己写的。你的人品，决定你的前途文／李思圆1 我在老家有两个朋友老王和老张。老王5年前跟老张借了5万块，说是做装修生意急用，并承诺两年内还清。老张二话没说，把钱借给了老王。出于信任，也没让他写借条。但两年后，老王只字不提还钱的事，倒是全款买了一辆新车。 老张问他要钱，老王推三阻四。一会儿说有事不在家，一会儿电话又打不通，甚至故意玩消失。最终两家人闹掰了，老张没要回钱，吃了一个哑巴亏。村里人都知道这件事，虽然大家嘴上没说，但心里都觉得老王不厚道。又过了两年，村里上百户人搬迁，都需要装修新房。老王心想，乡亲们一定会找他。可奇怪的是，即便他的报价低了很多，许多村民也不买账。原来，他的坏口碑一传十，十传百，没过几年，装修生意彻底做不下去了。有时候，一个人或许可以靠不讲信用获取一些暂时的利益，但那绝不是正道。想要站得稳，走得远，笑到最后，还得靠人品做支撑。2前些日子我朋友的公司搞竞聘，有个工作能力非常强的男同事落选了。后来男同事得知，他是被总经理撤下来了。总经理对他说：小伙子，既要学会做事，更要学会做人。后来这个男同事负气辞职，总经理才道出真相。原来有次这个男同事坐电梯时，一个外卖小哥背着一个很重的外卖包，风尘仆仆地想进来。电梯里是有空间的，只要这个男同事往后退几步就行，但他就是故意不让。一边快速按关门键，一边说，几步路而已，也要坐电梯。这件事被总经理知道了，就把他拉入了黑名单。一个学不会尊重别人的人，心性就出了问题。这样的人，谁敢重用？也许一个人的前途，跟自身的智商、实力和运气等有关，可拼到最后，人品才是最终的把关口。3曾听一位读者说起，他曾供职的私企因经营不善大规模裁员。当时许多被裁的员工闹情绪，有人故意销毁重要文件，有人把客户的联络方式偷偷拷贝走，还有人四处造谣说老板的坏话。这位读者丢了工作也不开心。但在最后一个月，他对工作依然没有敷衍了事。在交接工作时，他还把需要特别注意的事项一一罗列出来。老板被他的所作所为感动，通过熟人把他介绍到另外一家公司工作。这位读者因为踏实肯干，很快就走上了管理岗位，薪水待遇也提高很多。人品就是一个人的根基。为人善良、懂得体谅、不去做小人之事，这样的人，会格外得到好运的眷顾、贵人的扶持和机会的偏爱。4有人说，能力和学历才是好工作的敲门砖，情商和智商才是好职位的守护神。但其实无论在哪行哪业，都不缺高手。前途一片光明的人，一定不是颠倒黑白、动歪脑筋的人，而是那些在同等条件下，人品过关的人。也许你反应快、人脉广、办法多，但这些也只是你的加分项。为人诚实，待人和善，有底线有原则，不做有损他人的事，这些却是你的必选项。一个人能力差一点，灵性少一点，实力欠一点，都可以花时间和精力慢慢去补足，但人品差却是致命的缺陷。好人品，是做人的良心，是为人的修养。没有了好人品，其他都免谈。一个人走得远不远、久不久、稳不稳，人品才是最关键的因素。小结学会做人，学会做事，掌握好人生的必选项，添加加分项，我们会更好的适应这个世界]]></content>
      <categories>
        <category>总结</category>
        <category>想法</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map与vector的用法]]></title>
    <url>%2F2019%2F07%2F02%2Fmap%E4%B8%8Evector%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[vector向量 相当于一个数组在内存中分配一块连续的内存空间进行存储。支持不指定vector大小的存储。STL内部实现时，首先分配一个非常大的内存空间预备进行存储，即capacituy（）函数返回的大小，当超过此分配的空间时再整体重新放分配一块内存存储，这给人以vector可以不指定vector即一个连续内存的大小的感觉。通常此默认的内存分配能完成大部分情况下的存储。map映照容器的元素数据是一个键值和一个映照数据组成的，键值与映照数据之间具有一一映照的关系。map映照容器的数据结构是采用红黑树来实现的，插入键值的元素不允许重复，比较函数只对元素的键值进行比较，元素的各项数据可通过键值检索出来。使用map容器需要头文件包含语句“#include”，map文件也包含了对multimap多重映照容器的定义。mapMap是c++的一个标准容器，它提供了很好一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果，总结了一些map基本简单实用的操作！map最基本的构造函数；123map&lt;string , int &gt;mapstring; map&lt;int ,string &gt;mapint;map&lt;sring, char&gt;mapstring; map&lt; char ,string&gt;mapchar;map&lt;char ,int&gt;mapchar; map&lt;int ,char &gt;mapint；map添加数据；1234map&lt;int ,string&gt; maplive; 1.maplive.insert(pair&lt;int,string&gt;(102,&quot;aclive&quot;));2.maplive.insert(map&lt;int,string&gt;::value_type(321,&quot;hai&quot;));3, maplive[112]=&quot;April&quot;;//map中最简单最常用的插入添加！map中元素的查找：123456find()函数返回一个迭代器指向键值为key的元素，如果没找到就返回指向map尾部的迭代器。 map&lt;int ,string &gt;::iterator l_it;; l_it=maplive.find(112);if(l_it==maplive.end()) cout&lt;&lt;&quot;we do not find 112&quot;&lt;&lt;endl;else cout&lt;&lt;&quot;wo find 112&quot;&lt;&lt;endl;map中元素的删除：123456如果删除112；map&lt;int ,string &gt;::iterator l_it;;l_it=maplive.find(112);if(l_it==maplive.end()) cout&lt;&lt;&quot;we do not find 112&quot;&lt;&lt;endl;else maplive.erase(l_it); //delete 112;map中 swap的用法：12345678910111213141516171819202122232425262728293031323334353637 Map中的swap不是一个容器中的元素交换，而是两个容器交换； For example： #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) &#123; map &lt;int, int&gt; m1, m2, m3; map &lt;int, int&gt;::iterator m1_Iter; m1.insert ( pair &lt;int, int&gt; ( 1, 10 ) ); m1.insert ( pair &lt;int, int&gt; ( 2, 20 ) ); m1.insert ( pair &lt;int, int&gt; ( 3, 30 ) ); m2.insert ( pair &lt;int, int&gt; ( 10, 100 ) ); m2.insert ( pair &lt;int, int&gt; ( 20, 200 ) ); m3.insert ( pair &lt;int, int&gt; ( 30, 300 ) ); cout &lt;&lt; &quot;The original map m1 is:&quot;; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter-&gt;second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl; // This is the member function version of swap //m2 is said to be the argument map; m1 the target map m1.swap( m2 ); cout &lt;&lt; &quot;After swapping with m2, map m1 is:&quot;; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;After swapping with m2, map m2 is:&quot;; for ( m1_Iter = m2.begin( ); m1_Iter != m2.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl; // This is the specialized template version of swap swap( m1, m3 ); cout &lt;&lt; &quot;After swapping with m3, map m1 is:&quot;; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; &quot; &quot; &lt;&lt; m1_Iter -&gt; second; cout &lt;&lt; &quot;.&quot; &lt;&lt; endl;&#125;map的sort问题：123456789101112131415161718192021222324252627 Map中的元素是自动按key升序排序,所以不能对map用sort函数： For example： #include &lt;map&gt; #include &lt;iostream&gt; using namespace std; int main( ) &#123; map &lt;int, int&gt; m1; map &lt;int, int&gt;::iterator m1_Iter; m1.insert ( pair &lt;int, int&gt; ( 1, 20 ) ); m1.insert ( pair &lt;int, int&gt; ( 4, 40 ) ); m1.insert ( pair &lt;int, int&gt; ( 3, 60 ) ); m1.insert ( pair &lt;int, int&gt; ( 2, 50 ) ); m1.insert ( pair &lt;int, int&gt; ( 6, 40 ) ); m1.insert ( pair &lt;int, int&gt; ( 7, 30 ) ); cout &lt;&lt; &quot;The original map m1 is:&quot;&lt;&lt;endl; for ( m1_Iter = m1.begin( ); m1_Iter != m1.end( ); m1_Iter++ ) cout &lt;&lt; m1_Iter-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;m1_Iter-&gt;second&lt;&lt;endl; &#125; The original map m1 is: 1 20 2 50 3 60 4 40 6 40 7 30map的基本操作函数：1234567891011121314151617181920C++ Maps是一种关联式容器，包含“关键字/值”对begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数总结：优点：(1) 不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作。通常体现在push_back() pop_back()(2) 随机访问方便，即支持[ ]操作符和vector.at()(3) 节省空间。缺点：(1) 在内部进行插入删除操作效率低。(2) 只能在vector的最后进行push和pop，不能在vector的头进行push和pop。(3) 当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放vector标准库Vector类型使用需要的头文件：#includeVector：Vector 是一个类模板。不是一种数据类型。 Vector是一种数据类型。定义和初始化Vectorv1; //默认构造函数v1为空Vectorv2(v1);//v2是v1的一个副本Vectorv3(n,i);//v3包含n个值为i的元素Vectorv4(n); //v4含有n个值为0的元素值初始化1&gt; 如果没有指定元素初始化式，标准库自行提供一个初始化值进行值初始化。2&gt; 如果保存的式含有构造函数的类类型的元素，标准库使用该类型的构造函数初始化。3&gt; 如果保存的式没有构造函数的类类型的元素，标准库产生一个带初始值的对象，使用这个对象进行值初始化。Vector对象最重要的几种操作v.push_back(t) 在数组的最后添加一个值为t的数据v.size() 当前使用数据的大小v.empty() 判断vector是否为空v[n] 返回v中位置为n的元素v1=v2 把v1的元素替换为v2元素的副本v1==v2 判断v1与v2是否相等！=、&lt;、&lt;=、&gt;、&gt;= 保持这些操作符惯有含义vector容器类型vector容器是一个模板类，可以存放任何类型的对象（但必须是同一类对象）。vector对象可以在运行时高效地添加元素，并且vector中元素是连续存储的。vector的构造函数原型：templateexplicit vector(); // 默认构造函数，vector对象为空explicit vector(size_type n, const T&amp; v = T()); // 创建有n个元素的vector对象vector(const vector&amp; x);vector(const_iterator first, const_iterator last);注：vector容器内存放的所有对象都是经过初始化的。如果没有指定存储对象的初始值，那么对于内置类型将用0初始化，对于类类型将调用其默认构造函数进行初始化（如果有其它构造函数而没有默认构造函数，那么此时必须提供元素初始值才能放入容器中）。举例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849vector&lt;string&gt; v1; // 创建空容器，其对象类型为string类vector&lt;string&gt; v2(10); // 创建有10个具有初始值（即空串）的string类对象的容器vector&lt;string&gt; v3(5, &quot;hello&quot;); // 创建有5个值为“hello”的string类对象的容器vector&lt;string&gt; v4(v3.begin(), v3.end()); // v4是与v3相同的容器（完全复制）vector的操作（下面的函数都是成员函数）bool empty() const; // 如果为容器为空，返回true；否则返回falsesize_type max_size() const; // 返回容器能容纳的最大元素个数size_type size() const; // 返回容器中元素个数size_type capacity() const; // 容器能够存储的元素个数，有：capacity() &gt;= size()void reserve(size_type n); // 确保capacity() &gt;= nvoid resize(size_type n, T x = T()); // 确保返回后，有：size() == n；如果之前size()&lt;n，那么用元素x的值补全。reference front(); // 返回容器中第一个元素的引用（容器必须非空）const_reference front() const;reference back(); // 返回容器中最后一个元素的引用（容器必须非空）const_reference back() const;reference operator[](size_type pos); // 返回下标为pos的元素的引用（下标从0开始；如果下标不正确，则属于未定义行为。const_reference operator[](size_type pos) const;reference at(size_type pos); // 返回下标为pos的元素的引用；如果下标不正确，则抛出异常out_of_rangeconst_reference at(size_type pos) const;void push_back(const T&amp; x); // 向容器末尾添加一个元素void pop_back(); // 弹出容器中最后一个元素（容器必须非空）// 注：下面的插入和删除操作将发生元素的移动（为了保持连续存储的性质），所以之前的迭代器可能失效iterator insert(iterator it, const T&amp; x = T()); // 在插入点元素之前插入元素（或者说在插入点插入元素）void insert(iterator it, size_type n, const T&amp; x); // 注意迭代器可能不再有效（可能重新分配空间）void insert(iterator it, const_iterator first, const_iterator last);iterator erase(iterator it); // 删除指定元素，并返回删除元素后一个元素的位置（如果无元素，返回end()）iterator erase(iterator first, iterator last); // 注意：删除元素后，删除点之后的元素对应的迭代器不再有效。void clear() const; // 清空容器，相当于调用erase( begin(), end())void assign(size_type n, const T&amp; x = T()); // 赋值，用指定元素序列替换容器内所有元素void assign(const_iterator first, const_iterator last);const_iterator begin() const; // 迭代序列iterator begin();const_iterator end() const;iterator end();const_reverse_iterator rbegin() const;reverse_iterator rbegin();const_reverse_iterator rend() const;reverse_iterator rend();vector对象的比较（非成员函数）针对vector对象的比较有六个比较运算符：operator==、operator!=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=。其中，对于operator==和operator!=，如果vector对象拥有相同的元素个数，并且对应位置的元素全部相等，则两个vector对象相等；否则不等。对于operator&lt;、operator&lt;=、operator&gt;、operator&gt;=，采用字典排序策略比较。注：其实只需要实现operator==和operator!=就可以了，其它可以根据这两个实现。因为，operator!= (lhs, rhs) 就是 !(lhs == rhs)，operator&lt;=(lhs, rhs) 就是 !(rhs &lt; lhs)，operator&gt;(lhs, rhs) 就是 (rhs &lt; lhs)，operator&gt;=（lhs, rhs) 就是 !(lhs, rhs)。vector类的迭代器vector类的迭代器除了支持通用的前缀自增运算符外，还支持算术运算：it + n、it - n、it2 - it1。注意it2 - it1返回值为difference_type（signed类型）。注意，任何改变容器大小的操作都可能造成以前的迭代器失效。应用示例1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; v(5, &quot;hello&quot;); vector&lt;string&gt; v2(v.begin(), v.end()); assert(v == v2); cout&lt;&lt;&quot;&gt; Before operation&quot;&lt;&lt;endl; for(vector&lt;string&gt;::const_iterator it = v.begin(); it &lt; v.end(); ++it) cout&lt;&lt;*it&lt;&lt;endl; v.insert(v.begin() + 3, 4, &quot;hello, world&quot;); cout&lt;&lt;&quot;&gt; After insert&quot;&lt;&lt;endl; for(vector&lt;string&gt;::size_type i = 0; i &lt; v.size(); ++i) cout&lt;&lt;v[i]&lt;&lt;endl; vector&lt;string&gt;::iterator it = v.erase(v.begin() + 3, v.begin() + 6); assert(*it == &quot;hello, world&quot;); cout&lt;&lt;&quot;&gt; After erase&quot;&lt;&lt;endl; for(vector&lt;string&gt;::size_type i = 0; i != v.size(); ++i) cout&lt;&lt;v[i]&lt;&lt;endl; assert(v.begin() + v.size() == v.end()); assert(v.end() - v.size() == v.begin()); assert(v.begin() - v.end() == -vector&lt;string&gt;::difference_type(v.size()));return 0;&#125;程序说明：上面程序中用了三个循环输出容器中的元素，每个循环的遍历方式是不一样的。特别需要说明的是，第二个循环在条件判断中使用了size() 函数，而不是在循环之前先保存在变量中再使用。之所以这样做，有两个原因：其一，如果将来在修改程序时，在循环中修改了容器元素个数，这个循环仍然能很好地工作，而如果先保存size()函数值就不正确了；其二，由于这些小函数（其实现只需要一条返回语句）基本上都被声明为inline，所以不需要考虑效率问题。c++编程语言中有一种叫做Vector的应用方法，它的作用在实际编程中是非常重要的。下面简单介绍一下C++ Vector的相关应用技巧及基本内容。基本用法(1)vector&lt; 类型 &gt; 标识符 ;(2)vector&lt; 类型 &gt; 标识符(最大容量) ；(3)vector&lt; 类型 &gt; 标识符（最大容量，初始所有值）；(4) int i[4] = {12,3,4,5};vector&lt; 类型 &gt; vi(i , i+2); //得到i索引值为3以后的值 ；(5)vector&lt; vector&gt; //vi 定义2维的容器；记得一定要有空格，不然会报错vector&lt; int &gt; line// 在使用的时候一定要首先将vi个行进行初始化;for(int i = 0 ; i &lt; 10 ; i ++){vector.push_back(line);}/// 个人认为使用vector定义二维数组很好，因为是长度可以不预先确定。(6)C++ Vector排序123456vector&lt; int &gt; vi ;vi.push_back(1);vi.push_back(3);vi.push_back(0);sort(vi.begin() , vi.end()); /// /小到大reverse(vi.begin(),vi.end()) /// 从大道小(7)顺序访问1234567891011121314vector &lt; int &gt; vi ;for( int i = 0 ; i &lt; 10 ; i ++)&#123; vector.push_back(i);&#125;for(int i = 0 ; i &lt; 10 ; i ++) /// 第一种调用方法&#123; cout &lt;&lt;vector[i] &lt;&lt;&quot; &quot; ;&#125;for(vector&lt;int&gt;::iterator it = vi.begin() ; it !=vi.end() ; it++; ///第二种调用方法&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot; ;&#125;(8)寻找1234567vector &lt; int &gt; vi ;for( int i = 0 ; i &lt; 10 ; i ++)&#123; vector.push_back(i);&#125; vector &lt; int &gt;::interator it = find(vi.begin() , vi.end,3) ; cout &lt;&lt; *it &lt;&lt; endl ; ///返回容器内找到值的位置。(9)使用数组对C++ Vector进行初始化12345678int i[10] =&#123;1,2,3,4,5,6,7,78,8&#125; ;///第一种vector&lt;int&gt; vi(i+1,i+3); ///从第2个元素到第三个元素for(vector &lt;int&gt;::interator it = vi.begin() ; it != vi.end() ; it++;&#123; cout &lt;&lt; *it &lt;&lt;&quot; &quot; ;&#125;(10) 结构体类型1234567891011121314151617struct temp&#123; public : string str ; public : int id ;&#125;tmpint main()&#123; vector &lt;temp&gt; t ; temp w1 ; w1.str = &quot;Hellowor&quot; ; w1.id = 1 ; t.push_back(t1); cout &lt;&lt; w1.str &lt;&lt; &quot;,&quot; &lt;&lt;w1.id &lt;&lt;endl ; return 0 ;&#125;比较]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图]]></title>
    <url>%2F2019%2F06%2F29%2F%E4%BA%8C%E5%88%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[概念介绍：二分图二分图又称作二部图，又称作偶图，是图论中的一种特殊模型顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(iin A,j in B)，则称图G为一个二分图。简单来说，就是顶点集 V 可分割为两个互不相交的子集，且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。当图中的顶点分为两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连时，此时是一特殊的二分图，称为完全二分图。充要条件是：图 G 中至少存在两个点，且图中所有回路的长度均为偶数。匹配在给定一个二分图 G，在 G 的一个子图 M 中，若 M 的边集中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。简单来说，匹配就是一个二分图中边的集合，其中任意两条边都没有公共顶点。如图，红边就是一个匹配最大匹配给定二分图 G 中的所有匹配，所含匹配边数最多的匹配，称为这个图的最大匹配，选择最大匹配的问题即为图的最大匹配问题如图，红边就是一个最大匹配完全匹配一个匹配中，图中每个顶点都与图中某条边相关联，则称此匹配为完全匹配，即一个图的某个匹配中，所有的顶点都是匹配点，就是一个完全匹配。显然，由于完全匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突，因此完全匹配一定是最大匹配。但要注意的是，并非每个图都存在完全匹配。简单来说，对于一个二分图，左点集中的每一个点都与右点集的一个点匹配，或者右点集中的每一个点都与左点集的一个点匹配。完美匹配对于一个二分图，左点集与右点集的点数相同，若存在一个匹配，包含左点集、右点集的所有顶点，则称为完美匹配。简单来说，对于一个二分图，左点集中的每一个点都与右点集的一个点匹配，并且右点集中的每一个点都与左点集的一个点匹配。如下图，红线所连接的匹配，不仅是一个完全匹配，还是一个完美匹配最大匹配问题举例来说，如下图所示，若存在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢？这就是完全匹配问题。而最多有多少互相喜欢的男孩/女孩可以配对？这就是最大匹配问题。最优匹配带权二分图的权值最大的完全匹配称为最佳匹配，要注意的是，二分图的最优匹配不一定是二分图的最大权匹配。实质上最优匹配问题就是求边权和最大的最大匹配问题。求解技巧：可以添加一些权值为 0 的边，使得最优匹配和最大权匹配统一起来。交替路从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路增广路从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。其实，如果交替路以非匹配点结束的，那么这条交替路就是一条增广路我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的1.匈牙利算法基本思想：通过寻找增广路，把增广路中的匹配边和非匹配边的身份交换，这样就会多出一条匹配边，直到找不到增广路为止。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define MAXN 9999using namespace std;int nx,ny;//nx表示二分图左边顶点的个数，ny表示二分图右边顶点的个数int m;//m代表边的条数int cx[MAXN],cy[MAXN];//如果有cx[i]=j，则必有cy[j]=i，说明i点和j点能够匹配int x,y;//x点到y点有边int e[MAXN][MAXN];//邻接矩阵int visited[MAXN];//标记数组，标记的永远是二分图右边的顶点int ret;//最后结果int point(int u)//这个函数的作用是寻找增广路和更新cx，xy数组，如果找到了增广路，函数返回1，找不到，函数返回0。&#123; for(int v=1;v&lt;=ny;v++)//依次遍历右边的所有顶点 &#123; if(e[u][v]&amp;&amp;!visited[v])//条件一：左边的u顶点和右边的v顶点有连通边，条件二：右边的v顶点在没有被访问过，这两个条件必须同时满足 &#123; visited[v]=1;//将v顶点标记为访问过的 if(cy[v]==-1||point(cy[v]))//条件一：右边的v顶点没有左边对应的匹配的点，条件二：以v顶点在左边的匹配点为起点能够找到一条增广路（如果能够到达条件二，说明v顶点在左边一定有对应的匹配点）。 &#123; cx[u]=v;//更新cx，cy数组 cy[v]=u; return 1; &#125; &#125; &#125; return 0;//如果程序到达了这里，说明对右边所有的顶点都访问完了，没有满足条件的。&#125;int main()&#123; while (cin&gt;&gt;m&gt;&gt;nx&gt;&gt;ny) &#123; memset(cx,-1,sizeof(cx));//初始化cx，cy数组的值为-1 memset(cy,-1,sizeof(cy)); memset(e,0,sizeof(e));//初始化邻接矩阵 ret=0; while (m--)//输入边的信息和更新邻接矩阵 &#123; cin&gt;&gt;x&gt;&gt;y; e[x][y]=1; &#125; for(int i=1;i&lt;=nx;i++)//对二分图左边的所有顶点进行遍历 &#123; if(cx[i]==-1)//如果左边的i顶点还没有匹配的点，就对i顶点进行匹配 &#123; memset(visited,0,sizeof(visited));//每次进行point时，都要对visited数组进行初始化 ret+=point(i);//point函数传入的参数永远是二分图左边的点 &#125; &#125; cout&lt;&lt;ret&lt;&lt;endl; &#125;&#125;2.KM算法KM算法写的比较好的文章https://www.cnblogs.com/wenruo/p/5264235.htmlhttps://www.cnblogs.com/logosG/p/logos.html?tdsourcetag=s_pcqq_aiomsg123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;limits.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cassert&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;ctime&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;list&gt;#include&lt;set&gt;#define INT 9654234#define mod 1000000007typedef long long ll;using namespace std;const int MAXN = 305;int N;int ex_gir[MAXN];//每个妹子的期望值int ex_boy[MAXN];//每个男生的期望值bool vis_gir[MAXN];//记录每一轮匹配过的女生bool vis_boy[MAXN];//记录每一轮匹配过的男生 每进行新的一轮，都要重新初始化这两个数组int match[MAXN];//match[i]代表和i男生匹配的女生的编号int slack[MAXN];//slack[i]代表i男生如果要获得女生的芳心，至少需要增加的期待值int love[MAXN][MAXN];//记录每个妹子和男生的好感度bool dfs(int gir)//dfs函数求的是编号为gir的女孩能否匹配到男生，如果能，返回true，否则，返回false&#123; vis_gir[gir]=true;//标记 for(int i=1;i&lt;=N;i++) &#123; if(vis_boy[i])//我们规定每次匹配对于某个男生只访问一遍，如果先前访问过了，就换个男生 continue ; int gap=ex_gir[gir]+ex_boy[i]-love[gir][i]; if(gap==0)//如果这个条件满足，说明编号为gir女孩和编号为i的男孩可能能够匹配成功 &#123; vis_boy[i]=true;//标记 if(match[i]==-1||dfs(match[i]))//如果这两个条件满足其中一个，说明编号为gir女孩和编号为i的男孩匹配成功 &#123; match[i]=gir; return true; &#125; &#125; else slack[i]=min(slack[i],gap);//如果gap不等于0，说明当前状态编号为gir女孩和编号为i的男孩不可能匹配成功，更新slack[i]。 &#125; return false;&#125;int km()&#123; memset(match,-1,sizeof(match)); memset(ex_boy,0,sizeof(ex_boy)); for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) ex_gir[i]=max(love[i][j],ex_gir[i]);//初始化ex_gir数组 for(int i=1;i&lt;=N;i++) &#123; fill(slack,slack+N+1,INT); while (1)//这个while循环结束的条件是直到让编号为i的女生找到可以匹配的男生后 &#123; memset(vis_gir,false,sizeof(vis_gir)); memset(vis_boy,false,sizeof(vis_gir)); if(dfs(i))//如果这个条件满足，说明编号为i的女生找到了匹配的男生，换下一个女生,如果这个条件不满足，说明这个女生没有匹配到男生，让这个女生降低期望值后继续匹配 break ; int t=INT; for(int j=1;j&lt;=N;j++)//寻找在这一轮匹配中没有匹配到的男生如果要获得女生芳心所需要增加的期待值的最小值 if(!vis_boy[j]) t=min(t,slack[j]); for(int i=1;i&lt;=N;i++)//让在这一轮匹配中匹配过的女生的期待值减小，匹配过的男生的期待值增加 &#123; if(vis_gir[i]) ex_gir[i]-=t; if(vis_boy[i]) ex_boy[i]+=t; else slack[i]-=t;//因为有些女生的期待值减小了，所以这一轮没有被匹配过的男生得到女生的芳心所需要增加的期待值就变小了，所以slack数组中的相应的值要变小 &#125; &#125; &#125; int res=0;//计算好感和 for(int i=1;i&lt;=N;i++) res+=love[match[i]][i]; return res;&#125;int main()&#123; cin&gt;&gt;N; for(int i=1;i&lt;=N;i++) for(int j=1;j&lt;=N;j++) cin&gt;&gt;love[i][j]; cout&lt;&lt;km()&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>图论</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath语法]]></title>
    <url>%2F2019%2F06%2F27%2Fxpath%2F</url>
    <content type="text"><![CDATA[xpath基本语法XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，有不同类型的节点，包括元素节点，属性节点和文本节点，提供在数据结构树中找寻节点的能力。起初 XPath 的提出的初衷是将其作为一个通用的、介于XPointer与XSLT间的语法模型。但是 XPath 很快的被开发者采用来当作小型查询语言。简单来说我们通过Xpath可以获取XML中的指定元素和指定节点的值。在网络爬虫中我们通过会把爬虫获取的HTML数据转换成XML结构，然后通过XPath解析，获取我们想要的结果。样例：123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt; &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;book&gt; &lt;title lang=&quot;eng&quot;&gt;Learning XML&lt;/title&gt; &lt;price&gt;39.95&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt;1.选取节点表达式描述nodename选取此节点的所有子节点/从根节点选取//从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置.选取当前节点..选取当前节点的父节点@选取属性2. 路径表达式路径表达式结果bookstore选取 bookstore 元素的所有子节点。/bookstore选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！bookstore/book选取属于 bookstore 的子元素的所有 book 元素。//book选取所有 book 子元素，而不管它们在文档中的位置。bookstore//book选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。//@lang选取名为 lang 的所有属性。3.谓词(Predicates)谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。路径表达式结果/bookstore/book[1]选取属于 bookstore 子元素的第一个 book 元素。/bookstore/book[last()]选取属于 bookstore 子元素的最后一个 book 元素。/bookstore/book[last()-1]选取属于 bookstore 子元素的倒数第二个 book 元素。/bookstore/book[position()&lt;3]选取最前面的两个属于 bookstore 元素的子元素的 book 元素。//title[@lang]选取所有拥有名为 lang 的属性的 title 元素。//title[@lang=’eng’]选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。/bookstore/book[price&gt;35.00]选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。/bookstore/book[price&gt;35.00]/title选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。4.选取未知节点XPath 通配符可用来选取未知的 XML 元素。通配符描述*匹配任何元素节点。@*匹配任何属性节点。node()匹配任何类型的节点。实例路径表达式结果/bookstore/*选取 bookstore 元素的所有子元素。//*选取文档中的所有元素。//title[@*]选取所有带有属性的 title 元素。5.选取若干路径通过在路径表达式中使用“|”运算符，您可以选取若干个路径。实例：路径表达式结果//book/title \//book/price选取 book 元素的所有 title 和 price 元素。//title \// price选取文档中的所有 title 和 price 元素。/bookstore/book/title \//price选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。]]></content>
      <categories>
        <category>Python</category>
        <category>xpath</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列栈和队列都是比较常用的数据结构。栈的应用非常的广泛，比如说，递归函数的实现就是借助于栈保存相关的数据。操作系统中每个线程也会使用栈来保存函数调用涉及到的一些参数和其他变量等。栈最大的一个特点就是先进后出(FILO—First-In/Last-Out)。队列和栈不同的是，队列是一种先进先出(FIFO—first in first out)的数据结构。1.栈头文件: #include&lt;stack&gt;栈是后进先出(Last In Fisrt Out)的一种特殊的线性表。栈可以存储多种类型数据，包括但不限于int char string double以及pair等等。栈的基本操作如下:12345678910111213stack&lt;int&gt;S; //定义栈S.push(x); //入栈——入栈是把元素压入栈底；S.pop(); //出栈——出栈是删除栈顶元素；S.top(); //取栈顶元素——取栈顶元素只返回元素，不删除；S.empty(); //判断栈是否为空——的判空一般都和 while 循环配套使用，比如下面代码输出栈内所有元素，并清空栈。若为空，则返回trueS.size(); //获取栈的大小——获取栈的大小返回栈內元素数量；注: empty的一般用法:while(!S.empty())&#123; cout&lt;&lt;S.top()&lt;&lt;endl; S.pop();&#125;2.队列头文件是#include&lt;queue&gt;注意：一般用到优先队列的时候都会用到结构体结构体：struct 结构体名称{ }自定义命名; eg:struct node{}student;在运用结构体的时候一般在输入的时候，可以直接带着结构体的方式输入优先队列：用的时候为priority_queue详解链接：https://blog.csdn.net/c20182030/article/details/70757660friend bool operator==(const Sales_item&amp;, const Sales_item&amp;);的用法：1234这个函数是友元函数，返回的是bool值operator是用于运算符重载的，判断两个Sales_item类型的数据时否相等， operator是C++的关键字，它和运算符一起使用，表示一个运算符函数，理解时应将operator=整体上视为一个函数名。这是C++扩展运算符功能的方法，虽然样子古怪，但也可以理解：一方面要使运算符的使用方法与其原来一致，另一方面扩展其功能只能通过函数的方式（c++中，“功能”都是由函数实现的)。1234operator是重载的意思operator _运算符号_ （参数）所谓运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。自定义类的赋值运算符重载函数的作用与内置赋值运算符的作用类似，但是要要注意的是，它与拷贝构造函数与析构函数一样，要注意深拷贝浅拷贝的问题，在没有深拷贝浅拷贝的情况下，如果没有指定默认的赋值运算符重载函数，那么系统将会自动提供一个赋值运算符重载函数。]]></content>
      <categories>
        <category>图论</category>
        <category>线性结构</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM题解]]></title>
    <url>%2F2019%2F06%2F25%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[将题解和题目集区分开主要是为了确保先思考，想方法，最后再对照题解主要还是为了养成独立思考的好习惯对应于习题集https://weakdouqing.github.io/2019/05/22/%E9%A2%98%E7%9B%AE%E9%9B%86/1.The Triangle12345678910111213141516171819202122232425262728293031323334353637题解：#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[101][101];int dp[101][101];int main()&#123; int n, m; int i, j; while(scanf(&quot;%d&quot;,&amp;m)!=EOF) &#123; memset(dp,0,sizeof(dp)); for(i=1;i&lt;=m;i++) &#123; for(j=1;j&lt;=i;j++) &#123; scanf(&quot;%d&quot;,&amp;a[i][j]); &#125; &#125; for(j=1;j&lt;=m;j++) dp[m][j] = a[m][j]; for(i=m-1;i&gt;=1;i--) &#123; for(j=1;j&lt;=i;j++) &#123; dp[i][j] = max(dp[i+1][j],dp[i+1][j+1]) + a[i][j]; &#125; &#125; cout&lt;&lt;dp[1][1]&lt;&lt;endl; &#125; return 0; &#125;2.区间完美数1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;long long a,b,c,d;long long lcm(long long a,long long b)&#123; return a*b/__gcd(a,b);&#125;long long solve(long long x)&#123; return x-x/c-x/d+x/lcm(c,d);&#125;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; cout&lt;&lt;solve(b)-solve(a-1)&lt;&lt;endl; return 0;&#125;3.最短路dijkstra算法写的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define INF 0x3fffffffusing namespace std;const int maxx=1e5; int map[110][110], dis[110], vis[110];void dijkstra(int n, int x)&#123; int p, minn; //将所有的两点间的距离存储，并将所有点设置为未访问 for(int i = 1; i &lt;= n; i ++) &#123; dis[i] = map[1][i]; vis[i] = 0; &#125; vis[x] = 1; //遍历所有点，找到最小路径 for(int i = 1; i &lt;= n; i ++) &#123; minn = INF; for(int j = 1; j &lt;= n; j ++) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; minn) &#123; p = j; minn = dis[j]; &#125; &#125; vis[p] = 1; for(int j = 1; j &lt;= n; j ++) &#123; if(!vis[j] &amp;&amp; dis[p] + map[p][j] &lt; dis[j]) &#123; dis[j] = dis[p] + map[p][j]; &#125; &#125; &#125; &#125;int main()&#123; int n, m, i, j, a, b, t; //初始化距离值为无穷 while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m)!=EOF) &#123; if(n == 0 &amp;&amp; m == 0) break; for(i = 1; i &lt;= n; i ++) &#123; for(j = 1; j &lt;= n; j ++) &#123; map[i][j] = INF; &#125; &#125; //设置两点之间的权值 for(i = 1; i &lt;= m; i ++) &#123; scanf(&quot;%d %d %d&quot;,&amp;a, &amp;b, &amp;t); map[a][b] = map[b][a] = t; &#125; dijkstra(n, 1); printf(&quot;%d\n&quot;,dis[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Question Solution</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题优化(二)]]></title>
    <url>%2F2019%2F06%2F24%2Fnext%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[Next主题优化(二)继上一次的优化没完成的部分，此次继续添加一些优化内容若是想要更多内容，可以自行百度/Google一下，继续更新内容1.字数统计和阅读时长1.安装插件npm install hexo-symbols-count-time –save2.修改站点配置文件找到合适的地方添加下面的代码1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true3.修改主题配置文件123456789101112# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 2752.给文章添加阴影效果打开themes/next/source/css/_custom/custom.styl，添加下面的代码：12345678// 为文章添加阴影效果.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;3.添加宠物1.安装依赖包安装依赖包,在站点根目录，打开Git Bash ，安装hexo-helper-live2d在站点配置文件或者主题配置文件添加以下内容1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true2.安装想要的宠物文件npm install {packagename}Eg:如果安装下面图示的宠物/1.png)如效果图所示的宠物名为haruto， 则为 npm install live2d-widget-model-haruto,其他宠物包点击live2d-widget-models。如果需要修改宠物的位置，可以在display下添加1234# 水平位置hOffset: 0# 垂直位置vOffset: -204.添加网站已运行时间在themes/layout/_parrials/footer.swing中添加12345678910111213141516171819202122232425262728&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout(&quot;siteTime()&quot;, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(2018,06,07,12,00,00); // 设置建立网站的时间 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+diffYears+&quot; 年 &quot;diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;; &#125; siteTime();&lt;/script&gt;5.添加标签云在next/layout/page.swig中，找到123&lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt;如果你想卷标页先显示标签云，再显示基本的卷标页，可以在这段代码之前添加123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125;如果是先显示默认的卷标页，再显示标签云，则把上面代码添加到后面。如果你只想显示标签云就行，可以把123&lt;div class=&quot;tag-cloud-tags&quot;&gt; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 300, color: true, start_color: &apos;#ccc&apos;, end_color: &apos;#111&apos;&#125;) &#125;&#125; &lt;/div&gt;删去就行6.修改界面内容显示区域宽度Next主题默认的设置，两边留白的区域很大。当然我们可以修改设置在themes\next\source\css_custom的custom.styl添加下面参数12345// 屏幕宽度小于1600px$content-desktop = 700px// 屏幕宽度大于或等于 1600px$content-desktop-large = 900px只需要修改对应的参数就行,要注意的是，此方法不适用于Pisces主题]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题优化(一)]]></title>
    <url>%2F2019%2F06%2F22%2Fnext%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Next主题优化(一)搭建完blog肯定要优化一下,不然界面你不会觉得丑吗？这篇文章将写一些能够优化界面的方法,没有的地方请自行搜索补充1.修改Hexo站点配置文件12345678910111213141516# Site 网站title: Dou Qing #网站标题subtitle: ~~愿你天黑有灯，下雨有伞~~ #网站副标题description: 学无止境 #网站描述author: Yan #博主的名字language: zh-Hans #网站使用的语言 PS:如果设置完后没有效果的话,去\themes\landscape\languages里面查看有的语言，一般会有zh-CN,这个就是中文timezone: #网站时区。Hexo 默认使用您电脑的时区# 侧边栏头像设置# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/图片名字 把你的头像设置在这里 #/images/avatar.gif其余的可以看着设置,不想设置的就不设置2.Hexo主题配置文件(next)next更多内容参考:http://theme-next.iissnan.com/theme-settings.html重点！！！！优化的重点！！想要花里胡哨的特效就认真对待这个文件打开Hexo目录/themes/next/_config.yml文件1.开启打赏功能123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: 你的微信收款码链接alipay: 你的支付宝收款码链接2.开启友情链接123456789# Blog rollslinks_icon: linklinks_title: 友情链接 //自己命名即可links_layout: block#links_layout: inlinelinks: #Title: http://example.com 在这开始写你想要的友情链接3.选择Scheme123456789# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Pisces#scheme: Mist#scheme: Pisces#scheme: Gemini4.设置首页不显示全文打开主题配置文件_config.yml,ctrl + F搜索找到”auto_excerpt”，找到12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt:enable: falselength: 150把enable改为对应的false改为true，length就是预览显示的文字长度，你可以根据你的需要进行更改，然后重新部署，再进主页，你就发现你首页的文章多了一个阅读全文的按钮。5.分类和标签设置首先通过hexo n “name”命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用notepad++或者sublime text打开12345title: namedate: 2014-08-05 11:15:00 tags: ---大概这个样子，可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入categories:项,但是下次创建新的页面的时候还是没有，所以我们直接打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n ‘name’命令，会发现新建的页面里有categories:项了。scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。5.1.设置分类列表123456categories: - 大类- 中类- 小类...---每一层- 内容的下面都是一种包含关系，而不是同级，这点要和标签分开在这里category_map:是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。5.2.设置标签12345678tags: - 标签1- 标签2- 标签3- 标签4...- 标签n---3.背景设置1.静态背景修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：123456body &#123; background-image: url(/images/(你想设置的)背景图片名称.png); background-attachment: fixed; background-repeat: repeat; background-size: contain;&#125;background-image: 你想放置图片的urlbackground-attachment: 不随屏幕滚动而滚动background-repeat: 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺background-size: 等比例铺满屏幕将背景图命名为 (你想设置的)背景图片名称.png并放入主题根目录/images下或者可以直接用自动切换图片,url为:https://source.unsplash.com/random/1600x9002.修改不透明度这个主要是为了避免next的过于简洁的界面而造成看起来过于单一完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125;background: #fff; 颜色设置opacity: 0.8;不透明度设置:范围(0-1)PS: 如果设置完没有效果的话,打开你的blog的界面,F12,打开源代码审查页面,找到不合适的地方,根据html的语法和方式修改即可,若是没学过html+css的朋友可以借鉴一下下个网址一个简单方便学习html+css的网站: http://www.w3school.com.cn/3.动态可交互背景(js引入)打开博客根目录/themes/next/layout/_layout.swig文件，在之前添加代码如下：1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;属性说明:12345属性说明： - color ：线条颜色, 默认: ‘0,0,0’；三个数字分别为(R,G,B) - opacity: 线条透明度（0~1）, 默认: 0.5 - count: 线条的总数量, 默认: 150 - zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1打开博客根目录/themes/next/_config.yml，找到字段canvas_nest，将其置为true【如果没有找到该字段，请自行添加】运行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 查看效果]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我感想]]></title>
    <url>%2F2019%2F06%2F21%2F%E8%87%AA%E6%88%91%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[一些想法回想起当时创建这个blog的时候，只是想把自己做过的题和一些想法写下又或者是写一些对自己警醒、对别人有用的知识点，来达到共同进步和学习现在看来有点偏离主题了随着对算法的逐步学习，发现要学习的东西真的是很多！！！最后，只是想提醒一下自己学算法这条路是我自己选的，没有任何人逼我，完全是自愿的那么，为什么不再努力一把，一直学下去学习，终将是会有所收获，也许收获的不是自己想要的，但是这份经验以及在学习中所积累的解决方法，依然会使自己逐步趋于完善既然当初选择了学习，那边应该一往无前···再努力先前走一小步，也许明天真的不一样了最后提一个小问题：如果生活向你招出了手，你会拒绝吗？]]></content>
      <categories>
        <category>总结</category>
        <category>想法</category>
      </categories>
      <tags>
        <tag>想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后]]></title>
    <url>%2F2019%2F06%2F20%2FN%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[序言N皇后问题一直是一个百炼不厌的题目写着一篇主要是为了深入理解和学会N皇后学习N皇后的主要思想和解题思路主要运用到的方法有,递归,DFS,遗传算法和CSP最小冲突法要说的一点是，因为本人比较菜，所以遗传算法和最小冲突法还没有学会N皇后问题:描述:1234N皇后问题是一个古老而著名的问题，是回溯算法的典型案例。该问题由西洋棋棋手马克斯·贝瑟尔于1848年提出。在国际象棋上，N皇后问题变成了8皇后问题，著名的数学家高斯认为有76种方案，后来有人用图论的知识解出92种结果，计算机发明后，可以通过算法实现问题的求解。8皇后问题是指在8*8的棋盘上摆放8个皇后，使得任意两个皇后都不在同一行、同一列或者同一斜线上，求满足这种摆放的解为多少个。（答案是92种）学会了8皇后以后，N皇后自然就迎刃而解了。提交问题链接:http://acm.hdu.edu.cn/showproblem.php?pid=255312345678910111213141516Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。Sample Input 1 8 5 0 Sample Output 1 92 10解题思路:首先要模拟一下:1.递归算法:123我们逐列放皇后（从小到大逐列摆放），现在先给第一列放皇后，很显然我们会把它放在第一行，接下来，给第二列放皇后，那么第二列的皇后能放在哪些位置？这时候需要一个判断函数来判断第二列的皇后能放在那里。如果第二列找到放皇后的某一行，那么就进行第三列的摆放，这里就是递归。2.回溯法:123如果还没有进行到最后一列的摆放时就已经不能再放皇后，那么此时需要怎么做？就返回递归的前面一次，把当前列的前面一列的皇后放在后面的行数上（从小到大逐行检验）。如果此时逐行检验已经遍历完所有的行数还是出现上面不能摆放的情况，那就在再返回上一次的递归，在进行逐行检验。这里就是回溯。3.递归算法的终止条件:1234由初始条件知道，第一行第一列放皇后，那么会不会有第一行第一列不放皇后的情况呢？我们能不能把这个位置放空，然后把第一列的皇后放在第二行上，或者更后面的一行。答案是肯定能的。那么问题来了，程序在运行到什么时候会进行这样的处理？当第一行第一列放皇后的所有情况都已经遍历完之后，就会把第一列的皇后放在第二行上，再把这个情况都遍历完，然后又把第一列的皇后放在第三行上，依次类推，直到把第一列的皇后放在最后一行上，当遍历完成时，递归终止。4.遗传算法:12345678910是随机剪枝搜索的一个变化形式。它通过把两个父状态结合来生成后继。算法模拟大自然的自然选择、基因杂交和变异。其中自然选择依据适应值的大小来评估被选中的概率，让更加优质的父状态更有可能传给下一代。生成种群、杂交、和变异都是依赖随机数和概率来模拟“物竞天择，适者生存”的自然法则。算法不断Select, Crossover, Mutate直到产生了一个最优解。一个棋盘可以看成是一条染色体，统称为“状态”，一个棋盘中的皇后可以看成一个基因。我不断调整种群数量的大小、适应值函数、杂交的策略、还有变异的概率，逐渐发现了更加优秀的参数。以下是我的实验结论：假设是N皇后，那么种群的数量最优是4N课本《人工智能：一种现代的方法》上的适应值函数不好，稍微改进一点的适应值函数 f = 冲突皇后对的个数的倒数，这样能够拉开优质和劣质个体被选的概率。 课本上面的“单点+双侧”杂交（随机选择单个杂交点，这个杂交点的两侧都交换）的效果不佳，不如“单点+单侧”杂交，也不如“双点+双点之间”杂交。单个基因（一个皇后）变异的概率小于0.05，比如0.04的时候，效果较好。5.CSP最小冲突法:123456789101112131415161718局部搜索对求解不少constraint satisfy problem有着很棒的效果。N皇后问题就是一个约束满足问题，这里的约束，就是指“皇后之间不能冲突”。该算法使用完全状态的形式化：初始状态每个变量都赋一个值，后继函数每一次改变一个变量的取值，改变取值的依据是使冲突最小化——最小冲突启发式。如果最小冲突值有多个，那么按照一定的概率选择。（经过大量反复实验发现，CSP最小冲突法存在极小概率的不完备性，即永远也找不到满足约束条件的最优解，当遇到此情况的时候，可以选择退出当前的求解，重新生成一个新的初始状态再来一次）该算法最精彩的地方，是时间复杂度可以优化到O(n^2)，于是可以在几秒内解决1万皇后的问题，在几十分钟内解决几万甚至10万皇后的问题！这是前两种算法完全无法比拟的。时间复杂度优化到O(n^2)有一点代价，那就是多付出一些空间复杂度。多出来的空间复杂度是O(n)，这个和优化的时间复杂度（从O(n^4 ) 到O(n^2)）相比，可以说是微不足道的，完全值得的。多出来三个vector，分别用来存储一个棋盘上的（以 8 皇后为例）:8个垂直方向的皇后数量15个主对角线方向的皇后数量15个反对角线方向的皇后数量那么，一个皇后的冲突数量，就是这三个vector中的相应的值相加，利用下标转换关系可以做到。这样计算一个皇后的冲突数量，就可以在常数时间内完成。这是十分吸引人的！当然，每一次放置皇后和移开皇后的时候，需要更新上述三个vector的相应值，维护这三个vector也需要时间开销，不过这也是常数。检测一个状态是否达到最优状态的时候，只需要判断每一个垂直方向（列）上面的皇后数量是否为1，主对角线和反对角线方向上的皇后数量是否是0或者1即可，这个时间复杂度是O(n)6.思路实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Max 20 //表示最大的棋盘边长,可以自定义为其它数据int pos[Max+1]; //为什么只需要定义一个一维数组就能描述二维的棋盘？ //pos[i]是这样定义的：即第i列的皇后放在第pos[i]行上， // 也就是说，pos[i]的索引i代表皇后所在的列，它的值pos[i]代表皇后所在的行int n; //棋盘的边长和皇后的数量int sum; //可以成功摆放的数量，每次遍历成功就加1bool checkNQ(int col)&#123; //对第col之前的列进行逐列检查,pos[i]中i的值为列，pos[i]的值为行 for(int i=1;i&lt;col;i++) if(pos[i]==pos[col]||abs(i-col)==abs(pos[i]-pos[col])) //如果行数相同，或者行数相减的绝对值等于列数相减的绝对值 //此时都不能放皇后，因为对第col列之前的列进行逐列检查， //所以不需要再进行列是否相同的判断 return false; return true;&#125;void dfsNQ(int col,int n)&#123; if(col==n+1) //成功遍历一次,sum加1，然后继续探索其他情况 sum++; for(int i=1;i&lt;=n;i++)&#123; pos[col]=i;//假设第col列的皇后放在第i行上，然后利用checkNQ()函数检查是否能放入 //第一种情况，如果能放入，则继续假设下一列也放在第i行（实际上第i行此时已经不能放了， //所以cheakNQ()函数就会直接返回false, //然后上面的for循环中的i自动加1,即假设第col+1列放在第i+1行，然后又继续检查能否放入。 //第二种情况，如果不能放入，for循环中的i就自动加1，即假设第col列的皇后放在第i+1行上， //又继续检查能否放入 //如果当col&lt;=n时（即列还没有遍历完）再也不能在任何一行放皇后，那么此时dfsNQ中的for循环的i已经 //遍历完，dfsNQ就会返回到上一级的dfsNQ(col+1,n),此时col就会自动减1（因为每次递归都是加1）， //然后，尝试第col列的皇后能否放在第i+1行上，如此进行回溯。 if(checkNQ(col)) dfsNQ(col+1,n); //进行递归 &#125;&#125; int main() &#123; cout&lt;&lt;&quot;请输入皇后的数量：&quot;; cin&gt;&gt;n; dfsNQ(1,n); //传入第一列和n,从第一列开始放皇后。 cout&lt;&lt;endl&lt;&lt;&quot;满足条件的所有摆放次数为：&quot;; cout&lt;&lt;sum; return 0; //说明：dfsNQ函数完全退出的条件是所有满足条件的情况都已经遍历过，再也没有满足条件的遍历 //根据递归的初始化分析得知，前面的遍历都会默认第一行第一列的位置会放皇后， //然而实际情况是这个位置不放皇后也能满足条件的次数甚至更多，那么程序在运行到什么时候会把 //第一行第一列的位置放空呢？答案是当第一行第一列放皇后的满足条件的所有遍历都结束时， //就会把第一列的皇后放在第二行，而把第一行第一列的位置放空。 //如此进行到最后，最后面是把第一列的皇后放在最后一行， //然后再全部遍历，结束时整个dfsNQ函数递归运行结束。主函数return 0. &#125;7.代码实现希望看到这里的你不要只是复制粘贴来过题(ctrl+cv),因为这样做，没有任何意义12345678910111213简单方法之打表法(极度不推荐,如果这样做,将学不会N皇后的精髓算法如DFS/回溯法/递归算法)#include &lt;iostream&gt;using namespace std;int n=1,x[11]=&#123;0,1,0,0,2,10,4,40,92,352,724&#125;;int main()&#123; while(n!=0) &#123; cin &gt;&gt; n; if(n!=0) cout &lt;&lt; x[n] &lt;&lt; endl; &#125; return 0;&#125;1.C语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;int a[15],ans[15],num,l,m,n,k,r;void dfs(int x)//搜索第x行可不可以放皇后&#123; if(x==n+1)//当查找到第n+1行是结束 &#123; l++; return; &#125; else &#123; for(int i=1;i&lt;=n;i++)//搜索第x行的第i列可不可以放皇后 &#123; a[x]=i;//假设将皇后放在第i列，标记 r=1; for(int j=1;j&lt;x;j++) &#123; if(a[j]==i||i-x==a[j]-j||i+x==a[j]+j)//第一句查询第j列是否已经放了皇后，第二三句查询对角线上是否放了皇后，算一遍就清楚了 &#123; r=0;//如果有，就退出去进行下一次循环，代表这个地方不能放皇后 break; &#125; &#125; if(r==1) dfs(x+1); &#125; &#125;&#125;int dabiao()//题目中说了n不大于10，所以可以直接打表&#123; for(n=1;n&lt;=10;++n) &#123; l=0; dfs(1); ans[n]=l; &#125;&#125;int main()&#123; dabiao(); while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; if(n==0) break; printf(&quot;%d\n&quot;,ans[n]); &#125; return 0;&#125;2.C++语言实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int vis[3][50], P[15];//三个方向 ↖↑↗在此三个方向都不能有皇后 int n, sum;void DFS(int row);int main()&#123; for(n = 1; n &lt;= 10; n++)//先打表不然会超时的 &#123; memset(vis,0,sizeof(vis)); sum = 0; DFS(1); P[n] = sum; &#125; while(scanf(&quot;%d&quot;,&amp;n), n) &#123; printf(&quot;%d\n&quot;,P[n]); &#125; return 0;&#125;void DFS(int row)&#123; int i; if(row == n + 1)//已经够n行了 &#123; sum ++; return ; &#125; for(i = 1; i &lt;= n; i++) &#123; if(vis[0][row-i+n] == 0 &amp;&amp; vis[1][i] == 0 &amp;&amp; vis[2][row+i] == 0) &#123;//不会回溯的应该好好看看学习学习 vis[0][row-i+n] = vis[1][i] = vis[2][row+i] = 1;//变值 DFS(row + 1);//深搜 vis[0][row-i+n] = vis[1][i] = vis[2][row+i] = 0;//回溯 &#125; &#125;&#125;3.遗传算法伪代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//主循环 void Genetic::GeneticAlgorithm() while m_NotSuccess为真 Select Crossover Mutate End while 打印最优解 End //计算一个state（棋盘）的适应值 //适应值采用“互相攻击皇后对的个数的倒数”，这比书上直接计算不互相攻击的皇后对数作为适应值的方法相比，更能拉开不同状态之间的差距。 //@para state：一个状态的引用 double Genetic::CalcuAdaptive(vector &amp;state) counter←0 For i: 0 to QueenNum-1 do For i: 0 to QueenNum-1 do If 对角线方向互相攻击，或者垂直方向互相攻击 counter++ End if End for End for If counter等于0 m_NotSucess←false，程序的循环终止条件 m_BestOne←state，保存当前的状态 End if Return 1.0/counter End //自然选择，大体思路是轮盘赌选择 void Genetic::Select() 创建一个新的空种群newPopulation For i: 1 to populationSize-1 do m_accumuAdaptive[i]←m_accumuAdaptive[i - 1] + m_adaptive[i] End for totalAdaptive←m_accumuAdaptive的最后一个元素 For i: 0 to populationSize-1 do 先把totalAdaptive(这是一个实数)放大成一个整数 产生一个随机数 ，对totalAdaptive求模，得到 ran 按相同比例缩小成一个实数 用二分查找的方法，在m_ accumuAdaptive内进行查找 ran，找出位置 j 把m_population的第 j 个状态push_back到newPopulation中 End for m_population←newPopulation End杂交有多种思路：选择两个state状态，随机产生一个杂交点，然后对这个杂交点的右（左）边的“基因”进行交换选择两个state状态，随机产生一个杂交点，然后再对这个杂交点两边的“基因”都进行交换。选择两个state状态，随机产生两个杂交点，然后再对这两个杂交点之间的“基因”进行交换。变异： 通过伪随机数，使每一个基因有0.0几的概率进行突变。突变就是用伪随机数赋值。??:4.CSP最小冲突法123456789101112131415161718192021以下是主循环的伪代码 void MinConflict::MinConflictAlgorithm() While 没有找到最优解 For row: 0 to QueenNum-1 do 移开棋盘row这一行的皇后 更新相应的三个保存皇后数量的vector For column: 0 to QueenNum do 计算(row, column)位置的冲突值，常数时间 If 比之前的 min 更小 更新最小值 min, 更新此时的 columnMin Else if 和之前的最小值相等 50%概率更新最小值min，更新此时的 columnMin End if End for 放置皇后到冲突最小的地方(row, columnMin) 更新相应的三个保存皇后数量的vector 如果检测达到了最优状态，即找到了最优解，break For End for End while 打印最优解 End比较效果:遗传算法和CSP最小冲突法的比较:]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言基础]]></title>
    <url>%2F2019%2F06%2F19%2FC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[C语言1.简介：1234C语言是一门面向过程、抽象化的通用程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。C语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。尽管C语言提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的C语言程序可在包括一些类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。2.应用工具：Dev-C++Notepad++VC++3.基础模板：12345678910#include&lt;stdio.h&gt;int main()&#123; //声明变量 //内容（函数体） return 0; &#125;4.C语言简单的a+b12345678910111213#include&lt;stdio.h&gt; //包含标准输入输出的头文件 int main()&#123; int a,b; //定义变量a+b scanf("%d%d",&amp;a,&amp;b); //标准输入scanf,%d十进制转换符号，&amp;取地址符号，scanf里面必须带 sum=a+b; printf("%d\n",sum;) //标准输出printf,\n强制换行符 return 0;&#125;入门c语言：##1.关于数组：a[i] = i ：表示对数组a[i]的第i个元素赋值为i在字符串数组中，如chara[1000],a+3表示将存储字符串的首地址向后取3位名，但是原来的三位并不会消失，只不过在取的时候跳过了n:一个式子：12345678910111213141516171819#include&lt;stdio.h&gt;int a[1000];int main()&#123; int n,m; scanf("%d",&amp;n); while(n--)&#123; scanf("%d",&amp;m); int sum=0; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;a[i]); sum=(sum+a[i]); &#125; printf("%d\n\n",sum); &#125; return 0; &#125;2.需要注意的地方：1.在做算法题的时候，有必要为自己命名的变量赋值，如果不赋值的话可能会影响正常结果。2.在&lt;stdio.h&gt;中输入函数有：scanf(“ “，&amp; ); gets(“字符串”); getchar(“字符”);输出函数有：printf(“ “, )’’; puts(“字符串”)； putchar(“字符”);2.素数判定：对于这个比较好的题（经常错），当然是好好纪念一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546题目：对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。Input：输入数据有多组，每组占一行，由两个整数x，y组成，当x=0,y=0时，表示输入结束，该行不做处理。Ouput：对于每个给定范围内的取值，如果表达式的值都为素数，则输出"OK",否则请输出“Sorry”,每组输出占一行。 Sample Input：0 10 0Sample Output：OK详解：#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;//#include&lt;bits/stdc++.h&gt; 万能头文件，hdu不能用（无语。。。。）using namespace std;int main()&#123; int n,m; int j; while(scanf("%d %d",&amp;n,&amp;m)!=EOF) &#123; int sum=0,flag=1; //sum初始化，flag作为最后的判断条件 if(n==0&amp;&amp;m==0) break; for(int i=n;i&lt;=m;i++) //按照题目赋值 &#123; sum=i*i+i+41; //计算sum值 for(int j=2;j&lt;=sqrt(sum);j++) //素数的判定是从2开始的，sqrt(sum)也可以写作sum-1，只不过sqrt比较快一点 &#123; if(sum%j==0)&#123; //要用sum去%j,判断是否为素数 flag=0; //若为素数则是flag（判断条件）为0 break; &#125; if(flag==0) break; &#125; &#125; if(flag==0) printf("Sorry\n"); else printf("OK\n"); &#125; return 0;&#125;进阶素数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677题目：美素数：小明对数的研究比较热爱，一谈到数，脑子里就涌现出好多数的问题，今天，小明想考考你对素数的认识。 问题是这样的：一个十进制数，如果是素数，而且它的各位数字和也是素数，则称之为“美素数”，如29，本身是素数，而且2+9 = 11也是素数，所以它是美素数。 给定一个区间，你能计算出这个区间内有多少个美素数吗？ Input第一行输入一个正整数T，表示总共有T组数据(T &lt;= 10000)。 接下来共T行，每行输入两个整数L，R(1&lt;= L &lt;= R &lt;= 1000000)，表示区间的左值和右值。Output对于每组数据，先输出Case数，然后输出区间内美素数的个数（包括端点值L,R）。 每组数据占一行，具体输出格式参见样例。Sample Input31 1002 23 19Sample OutputCase #1: 14Case #2: 1Case #3: 4 题解：思路：素筛+打表 本题的目的是计算某个区间的美素数的个数。类似这样的问题，不能每次判定，否则计算上必然超时，所以需要打表。#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define mod 1000000+5bool a[mod];int ans[mod];void prim() //快速素筛--埃拉托斯特尼(Eratosthenes)筛法，比一般的筛法更快一点&#123; int n,m; int i,j; memset(a,true,sizeof(a)); a[0]=a[1]=false; for(i=2;i&lt;mod;i++) &#123; for(j=2;j*i&lt;mod;j++) &#123; a[i*j]=false; &#125; &#125; &#125;int he(int n) //求和&#123; int sum=0; while(n) &#123; sum += n%10; n /= 10; &#125; return sum;&#125;int main()&#123; int t; int i; int shu=1,num=0; prim(); memset(ans,0,sizeof(ans)); //素筛里面初始化为0 int x,y; for(i=2;i&lt;mod;i++) //素筛并打表 &#123; if(a[i]&amp;&amp;a[he(i)]) num++; ans[i]=num; &#125; scanf("%d",&amp;t); while(t--) &#123; scanf("%d %d",&amp;x,&amp;y); printf("Case #%d: %d\n",shu++,ans[y]-ans[x-1]); //ans[y]-ans[x-1]待补 &#125; return 0; &#125;]]></content>
      <categories>
        <category>C</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown知识点]]></title>
    <url>%2F2019%2F06%2F19%2FMarkdown%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[基础知识点1.标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题效果：2.在里面插入图片（使用相对路径）格式为：1![对图片的文字描述](路径)3.文本样式1234**这是加粗的文字** 要加粗的文字左右分别用两个*号包起来*这是倾斜的文字*` 要倾斜的文字左右分别用一个*号包起来***这是斜体加粗的文字*** 要倾斜和加粗的文字左右分别用三个*号包起来~~这是加删除线的文字~~ 要加删除线的文字左右分别用两个~~号包起来效果：4.引用123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容效果：5.分割线12345三个或者三个以上的 - 或者 * 都可以。-------********效果：可以看到，显示效果是一样的。6.超链接12345[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加例如：[简书](http://jianshu.com)[百度](http://baidu.com)PS：注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替效果：7.列表1.无序列表语法：无序列表用 - + * 任何一种都可以12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格效果：2.有序列表语法：数字加点123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格效果：3.列表嵌套：上一级和下一级之间敲三个空格即可8.表格123456789101112131415161718表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略举例：姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟效果：9代码语法：单行代码：代码之间分别用一个反引号包起来1`代码内容`代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行(123456789101112131415161718 代码... 代码... 代码...(```)ps：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。效果：![](Markdown知识点/8.png)## 10.流程图```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;效果：`对文章中的文字段落进行操作一个&lt;center&gt;就可以实现一段文字的居中—非常赞的一个操作]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客]]></title>
    <url>%2F2019%2F06%2F18%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[学习使用hexo搭建自己的博客搭建的目的:1.是为了督促自己的学习2.是加深对计算机知识的理解3.写笔记本上视图看着不舒服相关知识点12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道1.自己搭建的过程经验和总结（写的不好勿喷）：可以参考的链接:https://zhuanlan.zhihu.com/p/266252492.准备Git 和 Node.js这两个工具Git: https://git-scm.com/Node.js: https://nodejs.org/en/安装过程不会的自行百度: https://www.baidu.com/3.开始创建：（打开Git Bash,下面的命令都是在Git Bash中输入）首先要有一个github的账号,连接为: https://github.com/，然后去创建仓库，仓库名命名格式为：你的用户名.github.io配置SSH:输入命令 ssh-keygen -t rsa -C “你的邮件地址” # 然后连续回车。将C盘中的路径”C:\Users\你的用户名.ssh\id_rsa.pub”的内容复制下来，打开之前创建好的GitHub，设置-&gt;SSH and GPG keys-&gt;New SSH key，粘贴到此处确定。然后再bash中输入： ssh -T git@github.com这个命令是用来测试SSH是否配置好，看到You’ve successfully authenticated, but GitHub does not provide shell access.则说明配置好了，否则无法使用hexo d4.安装Hexo输入命令: npm install -g hexo-cli # install可以简写为i5.初始化Hexo在你想要放置你的Blog的地方创建一个文件夹（比如使用Blog）输入命令: hexo init Blog # Blog可以修改成其他的名字找到这个Blog文件夹，进入6.命令:hexo cleanhexo g # 生成 此条和后一条可简写为 hexo s -ghexo s # 预览g是generate的缩写，s是start的缩写，d是deploy的缩写hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容。在输入“hexo s”之后服务会启动（可以通过ctrl+c来停止），此时我们在浏览器输入“localhost:4000”会看到如下情况：此时就表示博客搭建成功了，但是这个主题不太好看，我们稍微设置一下主题。7.修改主题（链接: https://hexo.io/themes/）继续在Git Bash输入“git clone https://github.com/iissnan/hexo-theme-next themes/next”命令完成之后在根目录下打开“_config.yml”文件，修改主题信息（将landscape修改为next）PS：此处安装的是next主题，如果喜欢其他主题，可以自行安装其他主题在Git Bash输入以下命令，然后在浏览器输入“localhost:4000”来查看效果：此时可以看到next主题默认的界面风格，这个是最简洁的，但还是不好看，我们打开“站点根目录/themes/next/_congig.yml ”文件，修改next主题的配置信息，如图：8.安装Hexo扩展npm install hexo-deployer-git –savenpm install9.部署简单理解就是以后你写的东西要相传到网上和别人分享就要通过部署上传到GitHub Pages上传之前，打开站点配置文件_config.yml，位于站点根目录下，修改最后一部分为如下部分。1234deploy: type: git repository: git@github.com:todest/todest.github.io.git # 修改为你的GitHub用户名 branch: master上传到GitHub Pages。此时是已经修改过的样式，至此，用Hexo搭建的本地博客已经完成一下推荐两个大佬的博客：当然，如果可以的话，还是希望你们能看我自己的博客过程啦~~~搭建经验的分享众所周知，学习的过程中如果有老师的指导，肯定要方便不少这次搭建的成功，首先要感谢大佬（手动@亦往沧劫）大佬博客链接：https://blog.todest.cn/修改并完善博客内容看下一篇文章：https://weakdouqing.github.io/2019/06/22/next主题优化(一)/#more推荐博客：https://blog.csdn.net/qq_35117024/article/details/81390780另一个：https://blog.csdn.net/lewky_liu/article/details/81277337]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典算法]]></title>
    <url>%2F2019%2F06%2F07%2F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[分治策略、动态规划、贪心算法、回溯法算法中的经典，同时也是最常用的几种算法1.分治策略(求解递归式的方法)待补2.动态规划能采用动态规划求解的问题的一般要具有3个性质：(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。(3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）动规解题的一般思路动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态动态规划决策过程示意图(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计：（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解算法实现的说明 动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：（1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}算法实现的步骤1、创建一个一维数组或者二维数组，保存每一个子问题的结果，具体创建一维数组还是二维数组看题目而定，基本上如果题目中给出的是一个一维数组进行操作，就可以只创建一个一维数组，如果题目中给出了两个一维数组进行操作或者两种不同类型的变量值，比如背包问题中的不同物体的体积与总体积，找零钱问题中的不同面值零钱与总钱数，这样就需要创建一个二维数组。注：需要创建二维数组的解法，都可以创建一个一维数组运用滚动数组的方式来解决，即一位数组中的值不停的变化，后面会详细徐叙述2、设置数组边界值，一维数组就是设置第一个数字，二维数组就是设置第一行跟第一列的值，特别的滚动一维数组是要设置整个数组的值，然后根据后面不同的数据加进来变幻成不同的值。3、找出状态转换方程，也就是说找到每个状态跟他上一个状态的关系，根据状态转化方程写出代码。4、返回需要的值，一般是数组的最后一个或者二维数组的最右下角。3.贪心算法贪心算法是指：在每一步求解的步骤中，它要求“贪婪”的选择最佳操作，并希望通过一系列的最优选择，能够产生一个问题的（全局的）最优解。贪心算法每一步必须满足一下条件：1、可行的：即它必须满足问题的约束。2、局部最优：他是当前步骤中所有可行选择中最佳的局部选择。3、不可取消：即选择一旦做出，在算法的后面步骤就不可改变了。4.回溯法回溯算法是所有搜索算法中最为基本的一种算法,是一种能避免不必要搜索的穷举式的搜索算法，其基本思想就是穷举搜索。123456789101112► 有许多问题，当需要找出它的解集或者要求回答什么解是满足某些约束条件的最佳解时，往往要使用回溯法► 回溯法的基本做法是搜索，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。► 回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含(而不是找到解）问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索（剪枝），逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。算法思想：采用了一种“走不通就掉头”的思想。搜索时往往有多分支，按某一分支为新的出发点，继续向下探索，当所有可能情况都探索过且都无法到达目标的时候，再回退到上一个出发点，继续探索另一个可能情况，这种不断回头寻找目标的方法称为“回溯法”。搜索的方式主要采用深度优先搜索的方式回溯三要素：1) 解空间：该空包含问题的解2) 约束条件3) 状态树N皇后问题跳马问题迷宫问题图的着色问题0-1背包问题装载问题批处理作业调度填数问题组合输出问题算24点问题ACM应用]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法(DP)]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[一般的，我们常用的解决问题的方法有暴力解决法、分而治之、二分法、贪心法和动态规划法。在你遇到一个问题怎么想都想不出其解法的时候，很可能就需要用到动态规划了；在你的题目中出现最优、最多、最好等字眼的时候，很可能可以使用动态规划问题来解决了。动态规划思想那么什么是动态规划（Dynamic Programming）呢？动态规划和分治思想、递归有着千丝万缕的关系。简单来说，分治思想是把一个问题分成一个一个的互不相关小问题，小问题再细分直至不可分（类似于把一根木棍切啊切）；递归就是在程序运行的过程中调用自身的一种编程技巧；动态规划通过寻找过程状态转移方程，将一个问题分解为子问题求解，但是子问题之间可能会有重复，因此如果单纯的使用递归方法来实现动态规划问题时间复杂度会比较高。不过动态规划问题的本质就是递归，这是因为我们在分析动态规划问题的过程中，需要状态转移方程，这个状态转移方程本质上就是递归。后面实现的过程中是否使用递归只是实现的不同而已，其本质就是递归。动态规划有三个最基本的元素：最优子结构、状态转移方程和边界。状态转移方程用于描述将当前状态的解分解为更小状态的关系式；边界即状态转移方程的截止条件；最优子结构即确保通过状态转移方程所选择的子问题也能给出最优的解。下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。数字三角形(POJ1163)在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99输入格式：5 //表示三角形的行数 接下来输入三角形73 88 1 02 7 4 44 5 2 6 5要求输出最大和接下来，我们来分析一下解题思路：首先，肯定得用二维数组来存放数字三角形然后我们用D( r, j) 来表示第r行第 j 个数字(r,j从1开始算)我们用MaxSum(r, j)表示从D(r,j)到底边的各条路径中，最佳路径的数字之和。因此，此题的最终问题就变成了求 MaxSum(1,1)当我们看到这个题目的时候，首先想到的就是可以用简单的递归来解题：D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形，我们可以写出如下的递归式：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849if ( r == N) MaxSum(r,j) = D(r,j); else MaxSum( r, j) = Max&#123; MaxSum(r＋1,j), MaxSum(r+1,j+1) &#125; + D(r,j); 完整代码#include &lt;iostream&gt; #include &lt;algorithm&gt; #define MAX 101 using namespace std; int D[MAX][MAX]; int n; int MaxSum(int i, int j)&#123; if(i==n) return D[i][j]; int x = MaxSum(i+1,j); int y = MaxSum(i+1,j+1); return max(x,y)+D[i][j]; &#125;int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl; &#125;超时原因：提交过后会超时，原因如下：重复计算了， 就拿第三行数字1来说，当我们计算从第2行的数字3开始的MaxSum时会计算出从1开始的MaxSum，当我们计算从第二行的数字8开始的MaxSum的时候又会计算一次从1开始的MaxSum，也就是说有重复计算。这样就浪费了大量的时间。也就是说如果采用递规的方法，深度遍历每条路径，存在大量重复计算。则时间复杂度为 2的n次方,对于 n = 100 行，肯定超时。接下来，我们就要考虑如何进行改进，我们自然而然就可以想到如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。那么可以用n方的时间复杂度完成计算。因为三角形的数字总数是 n(n+1)/2根据这个思路，我们就可以将上面的代码进行改进，使之成为记忆递归型的动态规划程序：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;#define MAX 101int D[MAX][MAX]; int n; int maxSum[MAX][MAX];int MaxSum(int i, int j)&#123; if( maxSum[i][j] != -1 ) return maxSum[i][j]; if(i==n) maxSum[i][j] = D[i][j]; else&#123; int x = MaxSum(i+1,j); int y = MaxSum(i+1,j+1); maxSum[i][j] = max(x,y)+ D[i][j]; &#125; return maxSum[i][j]; &#125; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) &#123; cin &gt;&gt; D[i][j]; maxSum[i][j] = -1; &#125; cout &lt;&lt; MaxSum(1,1) &lt;&lt; endl; &#125;优化代码:因为递归总是需要使用大量堆栈上的空间，很容易造成栈溢出，我们现在就要考虑如何把递归转换为递推，让我们一步一步来完成这个过程。1234567891011121314151617181920212223242526#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX]; int n; int maxSum[MAX][MAX]; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; for( int i = 1;i &lt;= n; ++ i ) maxSum[n][i] = D[n][i]; for( int i = n-1; i&gt;= 1; --i ) for( int j = 1; j &lt;= i; ++j ) maxSum[i][j] = max(maxSum[i+1][j],maxSum[i+1][j+1]) + D[i][j]; cout &lt;&lt; maxSum[1][1] &lt;&lt; endl; return 0;&#125;继续优化，而这个优化当然是对于空间进行优化，其实完全没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推，那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。对于空间优化后的具体递推过程如下：12345678910111213141516171819202122232425#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 101 int D[MAX][MAX]; int n; int * maxSum; int main()&#123; int i,j; cin &gt;&gt; n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin &gt;&gt; D[i][j]; maxSum = D[n]; //maxSum指向第n行 for( int i = n-1; i&gt;= 1; --i ) for( int j = 1; j &lt;= i; ++j ) maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j]; cout &lt;&lt; maxSum[1] &lt;&lt; endl; return 0;&#125;总结：递归到动规的一般转化方法递归函数有n个参数，就定义一个n维的数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界值开始， 逐步填充数组，相当于计算递归函数值的逆过程。动规解题的一般思路将原问题分解为子问题把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。2.确定状态在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。3.确定一些初始状态（边界状态）的值以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。确定状态转移方程定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。数字三角形的状态转移方程:能用动规解决的问题的特点1) 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。2) 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集与最小生成树]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[大佬博客：https://blog.csdn.net/qq_40772692/article/details/79667455并查集并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。集就是让每个元素构成一个单元素的集合，也就是按一定顺序将属于同一组的元素所在的集合合并。。在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这样的问题看起来似乎很简单，每次直接暴力查找即可，但是我们需要注意的问题是，在数据量非常大的情况下，那么时间复杂度将达到O（N*n）(n为查询次数)，那么这类问题在实际应用中，如果采取上述方法去做的话，耗费的时间将是巨大的。而如果用常规的数据结构去解决该类问题的话（顺序结构，普通树结构等），那么计算机在空间上也无法承受。所以，并查集这种数据结构便应运而生了。1234567891011121314故事读完，并查集就会了~~~~~江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。&lt;!--more--&gt;但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。下面我们来看并查集的实现。int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。1234567891011121314151617//find函数来查找队长int pre[1000 ]; int find(int x) //查找根节点 &#123; int r=x; while ( pre[r] != r ) //返回根节点 r r=pre[r]; int i=x , j ; while( i != r ) //路径压缩 &#123; j = pre[ i ]; // 在改变上级之前用临时变量 j 记录下他的值 pre[ i ]= r ; //把上级改为根节点 i=j; &#125; return r ; &#125;路径压缩(有时候在find函数里面可以省略)123456789再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低， 以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上 。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？123456789//join函数连接 注意：join函数一般写在find函数下边void join(int x,int y) //判断x y是否连通， //如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起, &#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fx ]=fy; &#125;最小生成树1.最小生成树概念：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树（使所有点联通+建立所有边的代价和最小）2.最小生成树应用：要在n个城市之间铺设光缆，主要目标是要使这 n 个城市的任意两个之间都可以通信，但铺设光缆的费用很高，且各个城市之间铺设光缆的费用不同，因此另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。1.Prim（普里姆）算法（加点法）(1)算法思想：以任意一点为树根出发，集合V是已经确定最短路的点集合，集合U是没有确立最短路的集合。初始时只有树根点在V中。每一次循环就代表要修建一条最短路，到达没到达的点（U），我们只能从已经建成的局部最短路点集V中选取V中所有已确定点能到达的所有其他点里面最小的来建设，有点贪心思想，每次选取代价最小的路，逐渐完善点，知道恰好覆盖所有的点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3fint G[1000][1000];//邻接矩阵存图int dis[1000];//存储最小距离（总的集合U里的）bool judge[1000];//判断该点是否已经加入最小点集合int pre[1000];//记录每个点的前导，用于输出路径int n,m;int prim(int a)&#123; int sum=0;//记录总和 int pos;//记录位置 int minn; judge[a]=1; pos=a; for(int i=1; i&lt;=n-1; i++) &#123; minn=INF; for(int j=1; j&lt;=n; j++) &#123; if(!judge[j]&amp;&amp;dis[j]&lt;minn) &#123; pos=j; minn=dis[j]; &#125; &#125; judge[pos]=1; sum+=minn; cout&lt;&lt;&quot;V&quot;&lt;&lt;pre[pos]&lt;&lt;&quot; -- &quot;&lt;&lt;&quot;V&quot;&lt;&lt;pos&lt;&lt;&quot; is &quot;&lt;&lt;minn&lt;&lt;endl; for(int j=1; j&lt;=n; j++) &#123; if(dis[j]&gt;G[pos][j]&amp;&amp;!judge[j]) &#123; dis[j]=G[pos][j]; pre[j]=pos; &#125; &#125; &#125; return sum;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(i==j) G[i][j]=0; else G[i][j]=INF; &#125; &#125; memset(judge,0,sizeof(judge)); for(int i=0; i&lt;m; i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; G[a][b]=G[b][a]=c; &#125; int s; cin&gt;&gt;s; for(int i=1; i&lt;=n; i++) &#123; pre[i]=s; dis[i]=G[s][i]; &#125; int k=prim(s); cout&lt;&lt;k&lt;&lt;endl; &#125; return 0;&#125;2.克鲁斯克尔（Kruskal）算法（加边法）算法思想：最小生成树最后一定是只有n-1条边！所以我们只要选取最小的n-1条边来吧n个点联通起来即可，但是注意不能产生回路，于是我们就用到了并查集！记Graph中有v个顶点，e条边；新建图Graphnew，Graphnew中拥有原图中的v个顶点，但没有边;将原图Graph中所有e条边按权值从小到大排序；循环：从权值最小的边开始，判断并添加每条边，直至添加了n-1条边：注意：加边的条件是不产生回路！即要连接的两定点不在一个集合里面！（并查集判断是否可以加边）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;struct Node&#123; int s,e,v; bool operator &lt;(const Node &amp;n)const&#123; return v&lt;n.v; &#125;&#125;;Node node[1000];int pre[1000];int ranked[1000];int n,m;int finded(int v)//查找&#123; int i=v; while(i!=pre[i])//return pre[v]=v?v:pre[v]=find(pre[v]);//递归 i=pre[i]; int j; while(v!=i) &#123; j=pre[v]; pre[v]=i; v=j; &#125; return i;&#125;void join(int a,int b)//合并&#123; int fx=finded(a); int fy=finded(b); if(fx!=fy) &#123; if(ranked[fx]&lt;ranked[fy]) &#123; pre[fx]=fy; &#125; else &#123; pre[fy]=fx; if(ranked[fx]==ranked[fy]) ranked[fx]++; &#125; &#125;&#125;int Kruskal()&#123; sort(node,node+m); int sizen=0; int sum=0; for(int i=0;i&lt;m&amp;&amp;sizen!=n-1;i++) &#123; if(finded(node[i].s)!=finded(node[i].e)) &#123; join(node[i].s,node[i].e); sum+=node[i].v; sizen++; &#125; &#125; if(sizen&lt;n-1)return -1; return sum;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(ranked,0,sizeof(ranked)); for(int i=1;i&lt;=n;i++) &#123; pre[i]=i; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;node[i].s&gt;&gt;node[i].e&gt;&gt;node[i].v; &#125; int k=Kruskal(); cout&lt;&lt;k&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM模板]]></title>
    <url>%2F2019%2F06%2F02%2FACM%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[ACM模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018201920202021202220232024202520262027202820292030203120322033203420352036203720382039204020412042204320442045204620472048204920502051205220532054205520562057205820592060206120622063206420652066206720682069207020712072207320742075207620772078207920802081208220832084208520862087208820892090209120922093209420952096209720982099210021012102210321042105210621072108210921102111211221132114211521162117211821192120212121222123212421252126212721282129213021312132213321342135213621372138213921402141214221432144214521462147214821492150215121522153215421552156215721582159216021612162216321642165216621672168216921702171217221732174217521762177217821792180218121822183218421852186218721882189219021912192219321942195219621972198219922002201220222032204220522062207220822092210221122122213221422152216221722182219222022212222222322242225222622272228222922302231223222332234223522362237223822392240224122422243224422452246224722482249225022512252225322542255225622572258225922602261226222632264226522662267226822692270227122722273227422752276227722782279228022812282228322842285228622872288228922902291229222932294229522962297229822992300230123022303230423052306230723082309231023112312231323142315231623172318231923202321232223232324232523262327232823292330233123322333233423352336233723382339234023412342234323442345234623472348234923502351235223532354235523562357235823592360236123622363236423652366236723682369237023712372237323742375237623772378237923802381238223832384238523862387238823892390239123922393239423952396239723982399240024012402240324042405240624072408240924102411241224132414241524162417241824192420242124222423242424252426242724282429243024312432243324342435243624372438243924402441244224432444244524462447244824492450245124522453245424552456245724582459246024612462246324642465246624672468246924702471247224732474247524762477247824792480248124822483248424852486248724882489249024912492249324942495249624972498249925002501250225032504250525062507250825092510251125122513251425152516251725182519252025212522252325242525252625272528252925302531253225332534253525362537253825392540254125422543254425452546254725482549255025512552255325542555255625572558255925602561256225632564256525662567256825692570257125722573257425752576257725782579258025812582258325842585258625872588258925902591259225932594259525962597259825992600260126022603260426052606260726082609261026112612261326142615261626172618261926202621262226232624262526262627262826292630263126322633263426352636263726382639264026412642264326442645264626472648264926502651265226532654265526562657265826592660266126622663266426652666266726682669267026712672267326742675267626772678267926802681268226832684268526862687268826892690269126922693269426952696269726982699270027012702270327042705270627072708270927102711271227132714271527162717271827192720272127222723272427252726272727282729273027312732273327342735273627372738273927402741274227432744274527462747274827492750275127522753275427552756275727582759276027612762276327642765276627672768276927702771277227732774277527762777277827792780278127822783278427852786278727882789279027912792279327942795279627972798279928002801280228032804280528062807280828092810281128122813281428152816281728182819282028212822282328242825282628272828头文件#define _CRT_SBCURE_NO_DEPRECATE#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt; &lt;!--more--&gt;using namespace std; const int maxn = 110;const int INF = 0x3f3f3f3f;经典1.埃拉托斯特尼筛法/* |埃式筛法| |快速筛选素数| |16/11/05ztx|*/ int prime[maxn];bool is_prime[maxn]; int sieve(int n)&#123; int p = 0; for(int i = 0; i &lt;= n; ++i) is_prime[i] = true; is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt;= n; ++i)&#123; // 注意数组大小是n if(is_prime[i])&#123; prime[p++] = i; for(int j = i + i; j &lt;= n; j += i) // 轻剪枝，j必定是i的倍数 is_prime[j] = false; &#125; &#125; return p; // 返回素数个数&#125;2.快速幂/* |快速幂| |16/11/05ztx|*/ typedef long long LL; // 视数据大小的情况而定 LL powerMod(LL x, LL n, LL m)&#123; LL res = 1; while (n &gt; 0)&#123; if (n &amp; 1) // 判断是否为奇数，若是则true res = (res * x) % m; x = (x * x) % m; n &gt;&gt;= 1; // 相当于n /= 2; &#125; return res;&#125;3.大数模拟大数加法/* |大数模拟加法| |用string模拟| |16/11/05ztx, thanks to caojiji|*/ string add1(string s1, string s2)&#123; if (s1 == "" &amp;&amp; s2 == "") return "0"; if (s1 == "") return s2; if (s2 == "") return s1; string maxx = s1, minn = s2; if (s1.length() &lt; s2.length())&#123; maxx = s2; minn = s1; &#125; int a = maxx.length() - 1, b = minn.length() - 1; for (int i = b; i &gt;= 0; --i)&#123; maxx[a--] += minn[i] - '0'; // a一直在减 ， 额外还要减个'0' &#125; for (int i = maxx.length()-1; i &gt; 0;--i)&#123; if (maxx[i] &gt; '9')&#123; maxx[i] -= 10;//注意这个是减10 maxx[i - 1]++; &#125; &#125; if (maxx[0] &gt; '9')&#123; maxx[0] -= 10; maxx = '1' + maxx; &#125; return maxx;&#125;大数阶乘/* |大数模拟阶乘| |用数组模拟| |16/12/02ztx|*/ #include &lt;iostream&gt;#include &lt;cstdio&gt; using namespace std; typedef long long LL; const int maxn = 100010; int num[maxn], len; /* 在mult函数中，形参部分：len每次调用函数都会发生改变，n表示每次要乘以的数，最终返回的是结果的长度 tip: 阶乘都是先求之前的(n-1)!来求n! 初始化Init函数很重要，不要落下*/ void Init() &#123; len = 1; num[0] = 1;&#125; int mult(int num[], int len, int n) &#123; LL tmp = 0; for(LL i = 0; i &lt; len; ++i) &#123; tmp = tmp + num[i] * n; //从最低位开始，等号左边的tmp表示当前位，右边的tmp表示进位（之前进的位） num[i] = tmp % 10; // 保存在对应的数组位置，即去掉进位后的一位数 tmp = tmp / 10; // 取整用于再次循环,与n和下一个位置的乘积相加 &#125; while(tmp) &#123; // 之后的进位处理 num[len++] = tmp % 10; tmp = tmp / 10; &#125; return len;&#125; int main() &#123; Init(); int n; n = 1977; // 求的阶乘数 for(int i = 2; i &lt;= n; ++i) &#123; len = mult(num, len, i); &#125; for(int i = len - 1; i &gt;= 0; --i) printf("%d",num[i]); // 从最高位依次输出,数据比较多采用printf输出 printf("\n"); return 0;&#125;4.GCD/* |辗转相除法| |欧几里得算法| |求最大公约数| |16/11/05ztx|*/ int gcd(int big, int small)&#123; if (small &gt; big) swap(big, small); int temp; while (small != 0)&#123; // 辗转相除法 if (small &gt; big) swap(big, small); temp = big % small; big = small; small = temp; &#125; return(big);&#125;5.LCM/* |辗转相除法| |欧几里得算法| |求最小公倍数| |16/11/05ztx|*/ int gcd(int big, int small)&#123; if (small &gt; big) swap(big, small); int temp; while (small != 0)&#123; // 辗转相除法 if (small &gt; big) swap(big, small); temp = big % small; big = small; small = temp; &#125; return(big);&#125;6.全排列/* |求1到n的全排列, 有条件| |16/11/05ztx, thanks to wangqiqi|*/ void Pern(int list[], int k, int n) &#123; // k表示前k个数不动仅移动后面n-k位数 if (k == n - 1) &#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d", list[i]); &#125; printf("\n"); &#125;else &#123; for (int i = k; i &lt; n; i++) &#123; // 输出的是满足移动条件所有全排列 swap(list[k], list[i]); Pern(list, k + 1, n); swap(list[k], list[i]); &#125; &#125;&#125;7.二分搜索/* |二分搜索| |要求：先排序| |16/11/05ztx, thanks to wangxiaocai|*/ // left为最开始元素, right是末尾元素的下一个数，x是要找的数int bsearch(int *A, int left, int right, int x)&#123; int m; while (left &lt; right)&#123; m = left + (right - left) / 2; if (A[m] &gt;= x) right = m; else left = m + 1; // 如果要替换为 upper_bound, 改为:if (A[m] &lt;= v) x = m+1; else y = m; &#125; return left;&#125; /* 最后left == right 如果没有找到135577找6，返回7 如果找有多少的x，可以用lower_bound查找一遍，upper_bound查找一遍，下标相减 C++自带的lower_bound(a,a+n,x)返回数组中最后一个x的下一个数的地址 upper_bound(a,a+n,x)返回数组中第一个x的地址 如果a+n内没有找到x或x的下一个地址，返回a+n的地址 lower_bound(a,a+n,x）-upper_bound(a,a+n,x)返回数组中x的个数*/数据结构并查集8.并查集/* |合并节点操作| |16/11/05ztx, thanks to chaixiaojun|*/ int father[maxn]; // 储存i的father父节点 void makeSet() &#123; for (int i = 0; i &lt; maxn; i++) father[i] = i;&#125; int findRoot(int x) &#123; // 迭代找根节点 int root = x; // 根节点 while (root != father[root]) &#123; // 寻找根节点 root = father[root]; &#125; while (x != root) &#123; int tmp = father[x]; father[x] = root; // 根节点赋值 x = tmp; &#125; return root;&#125; void Union(int x, int y) &#123; // 将x所在的集合和y所在的集合整合起来形成一个集合。 int a, b; a = findRoot(x); b = findRoot(y); father[a] = b; // y连在x的根节点上 或father[b] = a为x连在y的根节点上；&#125; /* 在findRoot(x)中： 路径压缩 迭代 最优版 关键在于在路径上的每个节点都可以直接连接到根上*/图论MST最小生成树Kruskal9.克鲁斯卡尔算法/* |Kruskal算法| |适用于 稀疏图 求最小生成树| |16/11/05ztx thanks to wangqiqi|*/ /* 第一步：点、边、加入vector，把所有边按从小到大排序 第二步：并查集部分 + 下面的code*/ void Kruskal() &#123; ans = 0; for (int i = 0; i&lt;len; i++) &#123; if (Find(edge[i].a) != Find(edge[i].b)) &#123; Union(edge[i].a, edge[i].b); ans += edge[i].len; &#125; &#125;&#125;Prim10.普里姆算法/* |Prim算法| |适用于 稠密图 求最小生成树| |堆优化版，时间复杂度：O(elgn)| |16/11/05ztx, thanks to chaixiaojun|*/ struct node &#123; int v, len; node(int v = 0, int len = 0) :v(v), len(len) &#123;&#125; bool operator &lt; (const node &amp;a)const &#123; // 加入队列的元素自动按距离从小到大排序 return len&gt; a.len; &#125;&#125;; vector&lt;node&gt; G[maxn];int vis[maxn];int dis[maxn]; void init() &#123; for (int i = 0; i&lt;maxn; i++) &#123; G[i].clear(); dis[i] = INF; vis[i] = false; &#125;&#125;int Prim(int s) &#123; priority_queue&lt;node&gt;Q; // 定义优先队列 int ans = 0; Q.push(node(s,0)); // 起点加入队列 while (!Q.empty()) &#123; node now = Q.top(); Q.pop(); // 取出距离最小的点 int v = now.v; if (vis[v]) continue; // 同一个节点，可能会推入2次或2次以上队列，这样第一个被标记后，剩下的需要直接跳过。 vis[v] = true; // 标记一下 ans += now.len; for (int i = 0; i&lt;G[v].size(); i++) &#123; // 开始更新 int v2 = G[v][i].v; int len = G[v][i].len; if (!vis[v2] &amp;&amp; dis[v2] &gt; len) &#123; dis[v2] = len; Q.push(node(v2, dis[v2])); // 更新的点加入队列并排序 &#125; &#125; &#125; return ans;&#125;Bellman-Ford单源最短路Dijkstra11.迪杰斯特拉算法/* |Dijkstra算法| |适用于边权为正的有向图或者无向图| |求从单个源点出发，到所有节点的最短路| |优化版：时间复杂度 O(elbn)| |16/11/05ztx, thanks to chaixiaojun|*/ struct node &#123; int v, len; node(int v = 0, int len = 0) :v(v), len(len) &#123;&#125; bool operator &lt; (const node &amp;a)const &#123; // 距离从小到大排序 return len &gt; a.len; &#125;&#125;; vector&lt;node&gt;G[maxn];bool vis[maxn];int dis[maxn]; void init() &#123; for (int i = 0; i&lt;maxn; i++) &#123; G[i].clear(); vis[i] = false; dis[i] = INF; &#125;&#125;int dijkstra(int s, int e) &#123; priority_queue&lt;node&gt;Q; Q.push(node(s, 0)); // 加入队列并排序 dis[s] = 0; while (!Q.empty()) &#123; node now = Q.top(); // 取出当前最小的 Q.pop(); int v = now.v; if (vis[v]) continue; // 如果标记过了, 直接continue vis[v] = true; for (int i = 0; i&lt;G[v].size(); i++) &#123; // 更新 int v2 = G[v][i].v; int len = G[v][i].len; if (!vis[v2] &amp;&amp; dis[v2] &gt; dis[v] + len) &#123; dis[v2] = dis[v] + len; Q.push(node(v2, dis[v2])); &#125; &#125; &#125; return dis[e];&#125;SPFA12.最短路径快速算法（Shortest Path Faster Algorithm）/* |SPFA算法| |队列优化| |可处理负环|*/ vector&lt;node&gt; G[maxn];bool inqueue[maxn];int dist[maxn]; void Init()&#123; for(int i = 0 ; i &lt; maxn ; ++i)&#123; G[i].clear(); dist[i] = INF; &#125;&#125;int SPFA(int s,int e)&#123; int v1,v2,weight; queue&lt;int&gt; Q; memset(inqueue,false,sizeof(inqueue)); // 标记是否在队列中 memset(cnt,0,sizeof(cnt)); // 加入队列的次数 dist[s] = 0; Q.push(s); // 起点加入队列 inqueue[s] = true; // 标记 while(!Q.empty())&#123; v1 = Q.front(); Q.pop(); inqueue[v1] = false; // 取消标记 for(int i = 0 ; i &lt; G[v1].size() ; ++i)&#123; // 搜索v1的链表 v2 = G[v1][i].vex; weight = G[v1][i].weight; if(dist[v2] &gt; dist[v1] + weight)&#123; // 松弛操作 dist[v2] = dist[v1] + weight; if(inqueue[v2] == false)&#123; // 再次加入队列 inqueue[v2] = true; //cnt[v2]++; // 判负环 //if(cnt[v2] &gt; n) return -1; Q.push(v2); &#125; &#125; &#125; &#125; return dist[e];&#125; /* 不断的将s的邻接点加入队列，取出不断的进行松弛操作，直到队列为空 如果一个结点被加入队列超过n-1次，那么显然图中有负环*/Floyd-Warshall13.弗洛伊德算法/* |Floyd算法| |任意点对最短路算法| |求图中任意两点的最短距离的算法|*/ for (int i = 0; i &lt; n; i++) &#123; // 初始化为0 for (int j = 0; j &lt; n; j++) scanf("%lf", &amp;dis[i][j]);&#125;for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125;&#125;二分图14.染色法/* |交叉染色法判断二分图| |16/11/05ztx|*/ int bipartite(int s) &#123; int u, v; queue&lt;int&gt;Q; color[s] = 1; Q.push(s); while (!Q.empty()) &#123; u = Q.front(); Q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; v = G[u][i]; if (color[v] == 0) &#123; color[v] = -color[u]; Q.push(v); &#125; else if (color[v] == color[u]) return 0; &#125; &#125; return 1;&#125;15..匈牙利算法/* |求解最大匹配问题| |递归实现| |16/11/05ztx|*/ vector&lt;int&gt;G[maxn];bool inpath[maxn]; // 标记int match[maxn]; // 记录匹配对象void init()&#123; memset(match, -1, sizeof(match)); for (int i = 0; i &lt; maxn; ++i) &#123; G[i].clear(); &#125;&#125;bool findpath(int k) &#123; for (int i = 0; i &lt; G[k].size(); ++i) &#123; int v = G[k][i]; if (!inpath[v]) &#123; inpath[v] = true; if (match[v] == -1 || findpath(match[v])) &#123; // 递归 match[v] = k; // 即匹配对象是“k妹子”的 return true; &#125; &#125; &#125; return false;&#125; void hungary() &#123; int cnt = 0; for (int i = 1; i &lt;= m; i++) &#123; // m为需要匹配的“妹子”数 memset(inpath, false, sizeof(inpath)); // 每次都要初始化 if (findpath(i)) cnt++; &#125; cout &lt;&lt; cnt &lt;&lt; endl;&#125;/* |求解最大匹配问题| |dfs实现| |16/11/05ztx|*/ int v1, v2;bool Map[501][501];bool visit[501];int link[501];int result; bool dfs(int x) &#123; for (int y = 1; y &lt;= v2; ++y) &#123; if (Map[x][y] &amp;&amp; !visit[y]) &#123; visit[y] = true; if (link[y] == 0 || dfs(link[y])) &#123; link[y] = x; return true; &#125; &#125; &#125; return false;&#125; void Search() &#123; for (int x = 1; x &lt;= v1; x++) &#123; memset(visit,false,sizeof(visit)); if (dfs(x)) result++; &#125;&#125;动态规划背包16.17.18背包问题/* |01背包| |完全背包| |多重背包| |16/11/05ztx|*/ // 01背包： void bag01(int cost,int weight) &#123; for(i = v; i &gt;= cost; --i) dp[i] = max(dp[i], dp[i-cost]+weight);&#125; // 完全背包： void complete(int cost, int weight) &#123; for(i = cost ; i &lt;= v; ++i) dp[i] = max(dp[i], dp[i - cost] + weight);&#125; // 多重背包： void multiply(int cost, int weight, int amount) &#123; if(cost * amount &gt;= v) complete(cost, weight); else&#123; k = 1; while (k &lt; amount)&#123; bag01(k * cost, k * weight); amount -= k; k += k; &#125; bag01(cost * amount, weight * amount); &#125;&#125; // other int dp[1000000];int c[55], m[110];int sum; void CompletePack(int c) &#123; for (int v = c; v &lt;= sum / 2; ++v)&#123; dp[v] = max(dp[v], dp[v - c] + c); &#125;&#125; void ZeroOnePack(int c) &#123; for (int v = sum / 2; v &gt;= c; --v) &#123; dp[v] = max(dp[v], dp[v - c] + c); &#125;&#125; void multiplePack(int c, int m） &#123; if (m * c &gt; sum / 2) CompletePack(c); else&#123; int k = 1; while (k &lt; m)&#123; ZeroOnePack(k * c); m -= k; k &lt;&lt;= 1; &#125; if (m != 0)&#123; ZeroOnePack(m * c); &#125; &#125;&#125;LIS19.最长上升子序列/* |最长上升子序列| |状态转移| |16/11/05ztx|*/ /* 状态转移dp[i] = max&#123; 1.dp[j] + 1 &#125;; j&lt;i; a[j]&lt;a[i]; d[i]是以i结尾的最长上升子序列 与i之前的 每个a[j]&lt;a[i]的 j的位置的最长上升子序列+1后的值比较*/ void solve()&#123; // 参考挑战程序设计入门经典; for(int i = 0; i &lt; n; ++i)&#123; dp[i] = 1; for(int j = 0; j &lt; i; ++j)&#123; if(a[j] &lt; a[i])&#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125;&#125; /* 优化方法： dp[i]表示长度为i+1的上升子序列的最末尾元素 找到第一个比dp末尾大的来代替*/ void solve() &#123; for (int i = 0; i &lt; n; ++i)&#123; dp[i] = INF; &#125; for (int i = 0; i &lt; n; ++i) &#123; *lower_bound(dp, dp + n, a[i]) = a[i]; // 返回一个指针 &#125; printf("%d\n", *lower_bound(dp, dp + n, INF) - dp; &#125; /* 函数lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value的值。*/LCS20.最长公共子序列/* |求最长公共子序列| |递推形式| |16/11/05ztx|*/ void solve() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (s1[i] == s2[j]) &#123; dp[i + 1][j + 1] = dp[i][j] + 1; &#125;else &#123; dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; &#125;&#125;计算几何21.向量基本用法/* |16/11/06ztx|*/ struct node &#123; double x; // 横坐标 double y; // 纵坐标&#125;; typedef node Vector; Vector operator + (Vector A, Vector B) &#123; return Vector(A.x + B.x, A.y + B.y); &#125;Vector operator - (Point A, Point B) &#123; return Vector(A.x - B.y, A.y - B.y); &#125;Vector operator * (Vector A, double p) &#123; return Vector(A.x*p, A.y*p); &#125;Vector operator / (Vector A, double p) &#123; return Vector(A.x / p, A.y*p); &#125; double Dot(Vector A, Vector B) &#123; return A.x*B.x + A.y*B.y; &#125; // 向量点乘double Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125; // 向量模长double Angle(Vector A, Vector B) &#123; return acos(Dot(A, B) / Length(A) / Length(B)); &#125; // 向量之间夹角 double Cross(Vector A, Vector B) &#123; // 叉积计算 公式 return A.x*B.y - A.y*B.x;&#125; Vector Rotate(Vector A, double rad) // 向量旋转 公式 &#123; return Vector(A.x*cos(rad) - A.y*sin(rad), A.x*sin(rad) + A.y*cos(rad));&#125; Point getLineIntersection(Point P, Vector v, Point Q, Vector w) &#123; // 两直线交点t1 t2计算公式 Vector u = P - Q; double t = Cross(w, u) / Cross(v, w); // 求得是横坐标 return P + v*t; // 返回一个点&#125;22.求多边形面积/* |16/11/06ztx|*/ node G[maxn];int n; double Cross(node a, node b) &#123; // 叉积计算 return a.x*b.y - a.y*b.x;&#125; int main()&#123; while (scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; for (int i = 0; i &lt; n; i++) scanf("%lf %lf", &amp;G[i].x, &amp;G[i].y); double sum = 0; G[n].x = G[0].x; G[n].y = G[0].y; for (int i = 0; i &lt; n; i++) &#123; sum += Cross(G[i], G[i + 1]); &#125; // 或者 //for (int i = 0; i &lt; n; i++) &#123; //sum += fun(G[i], G[（i + 1）% n]); //&#125; sum = sum / 2.0; printf("%.1f\n", sum); &#125; system("pause"); return 0;&#125;23..判断线段相交/* |16/11/06ztx|*/ node P[35][105]; double Cross_Prouct(node A,node B,node C) &#123; // 计算BA叉乘CA return (B.x-A.x)*(C.y-A.y)-(B.y-A.y)*(C.x-A.x);&#125;bool Intersect(node A,node B,node C,node D) &#123; // 通过叉乘判断线段是否相交； if(min(A.x,B.x)&lt;=max(C.x,D.x)&amp;&amp; // 快速排斥实验； min(C.x,D.x)&lt;=max(A.x,B.x)&amp;&amp; min(A.y,B.y)&lt;=max(C.y,D.y)&amp;&amp; min(C.y,D.y)&lt;=max(A.y,B.y)&amp;&amp; Cross_Prouct(A,B,C)*Cross_Prouct(A,B,D)&lt;0&amp;&amp; // 跨立实验； Cross_Prouct(C,D,A)*Cross_Prouct(C,D,B)&lt;0) // 叉乘异号表示在两侧； return true; else return false;&#125;24.求三角形外心/* |16/11/06ztx|*/ Point circumcenter(const Point &amp;a, const Point &amp;b, const Point &amp;c) &#123; //返回三角形的外心 Point ret; double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1*a1 + b1*b1) / 2; double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2*a2 + b2*b2) / 2; double d = a1*b2 - a2*b1; ret.x = a.x + (c1*b2 - c2*b1) / d; ret.y = a.y + (a1*c2 - a2*c1) / d; return ret;&#125;24.极角排序/* |16/11/06ztx|*/ double cross(point p1, point p2, point q1, point q2) &#123; // 叉积计算 return (q2.y - q1.y)*(p2.x - p1.x) - (q2.x - q1.x)*(p2.y - p1.y);&#125;bool cmp(point a, point b) &#123; point o; o.x = o.y = 0; return cross(o, b, o, a) &lt; 0; // 叉积判断&#125;sort(convex + 1, convex + cnt, cmp); // 按角排序, 从小到大字符串kmp25.克努特-莫里斯-普拉特操作/* |kmp算法| |字符串匹配| |17/1/21ztx|*/ void getnext(char str[maxn], int nextt[maxn]) &#123; int j = 0, k = -1; nextt[0] = -1; while (j &lt; m) &#123; if (k == -1 || str[j] == str[k]) &#123; j++; k++; nextt[j] = k; &#125; else k = nextt[k]; &#125;&#125; void kmp(int a[maxn], int b[maxn]) &#123; int nextt[maxm]; int i = 0, j = 0; getnext(b, nextt); while (i &lt; n) &#123; if (j == -1 || a[i] == b[j]) &#123; // 母串不动，子串移动 j++; i++; &#125; else &#123; // i不需要回溯了 // i = i - j + 1; j = nextt[j]; &#125; if (j == m) &#123; printf("%d\n", i - m + 1); // 母串的位置减去子串的长度+1 return; &#125; &#125; printf("-1\n");&#125;26.kmp扩展/* |16/11/06ztx|*/ #include&lt;iostream&gt;#include&lt;cstring&gt; using namespace std; const int MM=100005; int next[MM],extand[MM];char S[MM],T[MM]; void GetNext(const char *T) &#123; int len = strlen(T),a = 0; next[0] = len; while(a &lt; len - 1 &amp;&amp; T[a] == T[a + 1]) a++; next[1] = a; a = 1; for(int k = 2; k &lt; len; k ++) &#123; int p = a + next[a] - 1,L = next[k - a]; if( (k - 1) + L &gt;= p) &#123; int j = (p - k + 1) &gt; 0 ? (p - k + 1) : 0; while(k + j &lt; len &amp;&amp; T[k + j] == T[j]) j++; next[k] = j; a = k; &#125;else next[k] = L; &#125;&#125;void GetExtand(const char *S,const char *T) &#123; GetNext(T); int slen = strlen(S),tlen = strlen(T),a = 0; int MinLen = slen &lt; tlen ? slen : tlen; while(a &lt; MinLen &amp;&amp; S[a] == T[a]) a++; extand[0] = a; a = 0; for(int k = 1; k &lt; slen; k ++) &#123; int p = a + extand[a] - 1, L = next[k - a]; if( (k - 1) + L &gt;= p) &#123; int j = (p - k + 1) &gt; 0 ? (p - k + 1) : 0; while(k + j &lt; slen &amp;&amp; j &lt; tlen &amp;&amp; S[k + j] == T[j]) j ++; extand[k] = j; a = k; &#125; else extand[k] = L; &#125;&#125;void show(const int *s,int len)&#123; for(int i = 0; i &lt; len; i ++) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl;&#125; int main() &#123; while(cin &gt;&gt; S &gt;&gt; T) &#123; GetExtand(S,T); show(next,strlen(T)); show(extand,strlen(S)); &#125; return 0;&#125;字典树27.字典树/* |16/11/06ztx|*/ struct Trie&#123; int cnt; Trie *next[maxn]; Trie()&#123; cnt = 0; memset(next,0,sizeof(next)); &#125;&#125;; Trie *root; void Insert(char *word) &#123; Trie *tem = root; while(*word != '\0') &#123; int x = *word - 'a'; if(tem-&gt;next[x] == NULL) tem-&gt;next[x] = new Trie; tem = tem-&gt;next[x]; tem-&gt;cnt++; word++; &#125;&#125; int Search(char *word) &#123; Trie *tem = root; for(int i=0;word[i]!='\0';i++) &#123; int x = word[i]-'a'; if(tem-&gt;next[x] == NULL) return 0; tem = tem-&gt;next[x]; &#125; return tem-&gt;cnt;&#125; void Delete(char *word,int t) &#123; Trie *tem = root; for(int i=0;word[i]!='\0';i++) &#123; int x = word[i]-'a'; tem = tem-&gt;next[x]; (tem-&gt;cnt)-=t; &#125; for(int i=0;i&lt;maxn;i++) tem-&gt;next[i] = NULL;&#125; int main() &#123; int n; char str1[50]; char str2[50]; while(scanf("%d",&amp;n)!=EOF) &#123; root = new Trie; while(n--) &#123; scanf("%s %s",str1,str2); if(str1[0]=='i') &#123; Insert(str2); &#125;else if(str1[0] == 's') &#123; if(Search(str2)) printf("Yes\n"); else printf("No\n"); &#125;else &#123; int t = Search(str2); if(t) Delete(str2,t); &#125; &#125; &#125; return 0;&#125;28.AC自动机/* |16/11/06ztx|*/ #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt; using namespace std; #define N 1000010 char str[N], keyword[N];int head, tail; struct node &#123; node *fail; node *next[26]; int count; node() &#123; //init fail = NULL;// 默认为空 count = 0; for(int i = 0; i &lt; 26; ++i) next[i] = NULL; &#125;&#125;*q[N]; node *root; void insert(char *str) &#123; // 建立Trie int temp, len; node *p = root; len = strlen(str); for(int i = 0; i &lt; len; ++i) &#123; temp = str[i] - 'a'; if(p-&gt;next[temp] == NULL) p-&gt;next[temp] = new node(); p = p-&gt;next[temp]; &#125; p-&gt;count++;&#125; void build_ac() &#123; // 初始化fail指针，BFS 数组模拟队列： q[tail++] = root; while(head != tail) &#123; node *p = q[head++]; // 弹出队头 node *temp = NULL; for(int i = 0; i &lt; 26; ++i) &#123; if(p-&gt;next[i] != NULL) &#123; if(p == root) &#123; // 第一个元素fail必指向根 p-&gt;next[i]-&gt;fail = root; &#125;else &#123; temp = p-&gt;fail; // 失败指针 while(temp != NULL) &#123; // 2种情况结束：匹配为空or找到匹配 if(temp-&gt;next[i] != NULL) &#123; // 找到匹配 p-&gt;next[i]-&gt;fail = temp-&gt;next[i]; break; &#125; temp = temp-&gt;fail; &#125; if(temp == NULL) // 为空则从头匹配 p-&gt;next[i]-&gt;fail = root; &#125; q[tail++] = p-&gt;next[i]; // 入队 &#125; &#125; &#125;&#125; int query() // 扫描&#123; int index, len, result; node *p = root; // Tire入口 result = 0; len = strlen(str); for(int i = 0; i &lt; len; ++i) &#123; index = str[i] - 'a'; while(p-&gt;next[index] == NULL &amp;&amp; p != root) // 跳转失败指针 p = p-&gt;fail; p = p-&gt;next[index]; if(p == NULL) p = root; node *temp = p; // p不动，temp计算后缀串 while(temp != root &amp;&amp; temp-&gt;count != -1) &#123; result += temp-&gt;count; temp-&gt;count = -1; temp = temp-&gt;fail; &#125; &#125; return result;&#125; int main() &#123; int num; head= tail = 0; root = new node(); scanf("%d", &amp;num); getchar(); for(int i = 0; i &lt; num; ++i) &#123; scanf("%s",keyword); insert(keyword); &#125; build_ac(); scanf("%s", str); if(query()) printf("YES\n"); else printf("NO\n"); return 0;&#125; /* 假设有N个模式串，平均长度为L；文章长度为M。 建立Trie树：O(N*L) 建立fail指针：O(N*L) 模式匹配：O(M*L) 所以，总时间复杂度为:O( (N+M)*L )。*/线段树29.线段树1）点更新/* |16/12/07ztx|*/ struct node&#123; int left, right; int max, sum;&#125;; node tree[maxn &lt;&lt; 2];int a[maxn];int n;int k = 1;int p, q;string str; void build(int m, int l, int r)//m 是 树的标号&#123; tree[m].left = l; tree[m].right = r; if (l == r)&#123; tree[m].max = a[l]; tree[m].sum = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(m &lt;&lt; 1, l, mid); build(m &lt;&lt; 1 | 1, mid + 1, r); tree[m].max = max(tree[m &lt;&lt; 1].max, tree[m &lt;&lt; 1 | 1].max); tree[m].sum = tree[m &lt;&lt; 1].sum + tree[m &lt;&lt; 1 | 1].sum;&#125; void update(int m, int a, int val)//a 是 节点位置， val 是 更新的值（加减的值）&#123; if (tree[m].left == a &amp;&amp; tree[m].right == a)&#123; tree[m].max += val; tree[m].sum += val; return; &#125; int mid = (tree[m].left + tree[m].right) &gt;&gt; 1; if (a &lt;= mid)&#123; update(m &lt;&lt; 1, a, val); &#125; else&#123; update(m &lt;&lt; 1 | 1, a, val); &#125; tree[m].max = max(tree[m &lt;&lt; 1].max, tree[m &lt;&lt; 1 | 1].max); tree[m].sum = tree[m &lt;&lt; 1].sum + tree[m &lt;&lt; 1 | 1].sum;&#125; int querySum(int m, int l, int r)&#123; if (l == tree[m].left &amp;&amp; r == tree[m].right)&#123; return tree[m].sum; &#125; int mid = (tree[m].left + tree[m].right) &gt;&gt; 1; if (r &lt;= mid)&#123; return querySum(m &lt;&lt; 1, l, r); &#125; else if (l &gt; mid)&#123; return querySum(m &lt;&lt; 1 | 1, l, r); &#125; return querySum(m &lt;&lt; 1, l, mid) + querySum(m &lt;&lt; 1 | 1, mid + 1, r);&#125; int queryMax(int m, int l, int r)&#123; if (l == tree[m].left &amp;&amp; r == tree[m].right)&#123; return tree[m].max; &#125; int mid = (tree[m].left + tree[m].right) &gt;&gt; 1; if (r &lt;= mid)&#123; return queryMax(m &lt;&lt; 1, l, r); &#125; else if (l &gt; mid)&#123; return queryMax(m &lt;&lt; 1 | 1, l, r); &#125; return max(queryMax(m &lt;&lt; 1, l, mid), queryMax(m &lt;&lt; 1 | 1, mid + 1, r));&#125; build(1,1,n);update(1,a,b);query(1,a,b);2)区间更新/* |16/11/06ztx|*/ typedef long long ll;const int maxn = 100010; int t,n,q;ll anssum; struct node&#123; ll l,r; ll addv,sum;&#125;tree[maxn&lt;&lt;2]; void maintain(int id) &#123; if(tree[id].l &gt;= tree[id].r) return ; tree[id].sum = tree[id&lt;&lt;1].sum + tree[id&lt;&lt;1|1].sum;&#125; void pushdown(int id) &#123; if(tree[id].l &gt;= tree[id].r) return ; if(tree[id].addv)&#123; int tmp = tree[id].addv; tree[id&lt;&lt;1].addv += tmp; tree[id&lt;&lt;1|1].addv += tmp; tree[id&lt;&lt;1].sum += (tree[id&lt;&lt;1].r - tree[id&lt;&lt;1].l + 1)*tmp; tree[id&lt;&lt;1|1].sum += (tree[id&lt;&lt;1|1].r - tree[id&lt;&lt;1|1].l + 1)*tmp; tree[id].addv = 0; &#125;&#125; void build(int id,ll l,ll r) &#123; tree[id].l = l; tree[id].r = r; tree[id].addv = 0; tree[id].sum = 0; if(l==r) &#123; tree[id].sum = 0; return ; &#125; ll mid = (l+r)&gt;&gt;1; build(id&lt;&lt;1,l,mid); build(id&lt;&lt;1|1,mid+1,r); maintain(id);&#125; void updateAdd(int id,ll l,ll r,ll val) &#123; if(tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r) &#123; tree[id].addv += val; tree[id].sum += (tree[id].r - tree[id].l+1)*val; return ; &#125; pushdown(id); ll mid = (tree[id].l+tree[id].r)&gt;&gt;1; if(l &lt;= mid) updateAdd(id&lt;&lt;1,l,r,val); if(mid &lt; r) updateAdd(id&lt;&lt;1|1,l,r,val); maintain(id);&#125; void query(int id,ll l,ll r) &#123; if(tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r)&#123; anssum += tree[id].sum; return ; &#125; pushdown(id); ll mid = (tree[id].l + tree[id].r)&gt;&gt;1; if(l &lt;= mid) query(id&lt;&lt;1,l,r); if(mid &lt; r) query(id&lt;&lt;1|1,l,r); maintain(id);&#125; int main() &#123; scanf("%d",&amp;t); int kase = 0 ; while(t--)&#123; scanf("%d %d",&amp;n,&amp;q); build(1,1,n); int id; ll x,y; ll val; printf("Case %d:\n",++kase); while(q--)&#123; scanf("%d",&amp;id); if(id==0)&#123; scanf("%lld %lld %lld",&amp;x,&amp;y,&amp;val); updateAdd(1,x+1,y+1,val); &#125; else&#123; scanf("%lld %lld",&amp;x,&amp;y); anssum = 0; query(1,x+1,y+1); printf("%lld\n",anssum); &#125; &#125; &#125; return 0;&#125;30.树状数组/* |16/11/06ztx|*/ #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt; using namespace std; typedef long long ll; const int maxn = 50005; int a[maxn];int n; int lowbit(const int t) &#123; return t &amp; (-t);&#125; void insert(int t, int d) &#123; while (t &lt;= n)&#123; a[t] += d; t = t + lowbit(t); &#125;&#125; ll getSum(int t) &#123; ll sum = 0; while (t &gt; 0)&#123; sum += a[t]; t = t - lowbit(t); &#125; return sum;&#125; int main() &#123; int t, k, d; scanf("%d", &amp;t); k= 1; while (t--)&#123; memset(a, 0, sizeof(a)); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;d); insert(i, d); &#125; string str; printf("Case %d:\n", k++); while (cin &gt;&gt; str) &#123; if (str == "End") break; int x, y; scanf("%d %d", &amp;x, &amp;y); if (str == "Query") printf("%lld\n", getSum(y) - getSum(x - 1)); else if (str == "Add") insert(x, y); else if (str == "Sub") insert(x, -y); &#125; &#125; return 0;&#125;其他31.中国剩余定理（孙子定理）/* |16/11/06ztx|*/ int CRT(int a[],int m[],int n) &#123; int M = 1; int ans = 0; for(int i=1; i&lt;=n; i++) M *= m[i]; for(int i=1; i&lt;=n; i++) &#123; int x, y; int Mi = M / m[i]; extend_Euclid(Mi, m[i], x, y); ans = (ans + Mi * x * a[i]) % M; &#125; if(ans &lt; 0) ans += M; return ans;&#125; void extend_Euclid(int a, int b, int &amp;x, int &amp;y) &#123; if(b == 0) &#123; x = 1; y = 0; return; &#125; extend_Euclid(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a / b) * y;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[最短路径主要思想12345678Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，此时完成一个顶点然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。实例：HDUOJ2544 四种不同算法理解最短路径1.迪杰斯特拉(Dijkstra)算法算法原理：123原理：这里不进行严格证明，Dijkstra的大致思想就是，根据初始点，挨个的把离初始点最近的点一个一个找到并加入集合，集合中所有的点的d[i]都是该点到初始点最短路径长度，由于后加入的点是根据集合S中的点为基础拓展的，所以也能找到最短路径。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//代码实现:#include &lt;iostream&gt;using namespace std;const int Inf = 1e9;int Map[100 + 10][100 + 10];//存储权值的，即Map[i][j] 有i到j的距离 int flag[100 + 10];//存储的是个个点是否已经找到最短路径 int dis[100 + 10];//由初始点到各个点的最短路径 int dj(int m) &#123; int Max = Inf; int dy = 0; for (int i = 1; i &lt;= m; i++) &#123;//一共m个点一个一个找 for (int k = 1; k &lt;= m; k++) &#123;//找到现在为止离初始点最短的距离 if (Map[1][k] &lt; Max &amp;&amp; !flag[k]) &#123; Max = Map[1][k];//记录大小 dy = k;//记录位置 &#125; &#125; flag[dy] = 1;//表示该点已经找到最短路径 dis[dy] = Map[1][dy];//存储最最短路径 for (int k = 1; k &lt;= m; k++) &#123; //找到经过dy点且在dy临近的点离初始点的最短距离 if (!flag[k]&amp;&amp;Map[1][k] &gt; dis[dy] + Map[dy][k]) &#123; Map[1][k] = dis[dy] + Map[dy][k]; &#125; &#125; dy = 0; Max = Inf; &#125; return dis[m];&#125;int main() &#123; int m, n, a, b, c, s; while (cin &gt;&gt; m &gt;&gt; n &amp;&amp; m || n) &#123; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; Map[i][j] = Inf; &#125; &#125; memset(flag, 0, sizeof(flag)); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (Map[a][b] &gt; c) &#123; Map[a][b] = c; Map[b][a] = c; &#125; &#125; cout &lt;&lt; dj(m) &lt;&lt; endl; &#125; return 0;&#125;另一种写法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273思想：每次找到离源点（如1号结点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。步骤：1.开容器v，储存子节点、距离、花费；2、开数组dis记录起始点到各点距离；3、进行n-1次松弛操作（先找出未标记点中离起始点最近的点，标记该点，然后求出该点子节点到起始点的最短距离（优先）与最短花费）；4、输出到终点的最短距离与花费；#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define N 999999999using namespace std;struct node&#123; int er,len,cost;&#125;;vector&lt;node&gt;v[1111];int main()&#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; int dis[1111],spend[1111]; bool vis[1111]; node tmp; int x,y; for(int i=0;i&lt;1111;i++) v[i].clear(); while(m--)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;tmp.len,&amp;tmp.cost); tmp.er=x; v[y].push_back(tmp); tmp.er=y; v[x].push_back(tmp); &#125; scanf(&quot;%d%d&quot;,&amp;x,&amp;y);//起点和终点 for(int i=1;i&lt;=n;i++)&#123; vis[i]=0; dis[i]=spend[i]=N; &#125; for(int i=0;i&lt;v[x].size();i++)&#123; dis[v[x][i].er]=v[x][i].len; spend[v[x][i].er]=v[x][i].cost; &#125; vis[x]=1; for(int k=1;k&lt;=n-1;k++) &#123; int id,mi=N; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]&amp;&amp;dis[i]&lt;mi)&#123;//查询并记录离x最近的点 id=i;mi=dis[i]; &#125; &#125; vis[id]=1;//标记过的点已经是最短 for(int i=0;i&lt;v[id].size();i++) &#123; int vv=v[id][i].er; if(!vis[vv]&amp;&amp;dis[vv]&gt;dis[id]+v[id][i].len)//未标记、直接距离大于通过id点的距离 dis[vv]=dis[id]+v[id][i].len, spend[vv]=spend[id]+v[id][i].cost; else if(!vis[vv]&amp;&amp;dis[vv]==dis[id]+v[id][i].len&amp;&amp;spend[vv]&gt;spend[vv]+v[id][i].cost)//未标记、距离相等找花费更小的 spend[vv]=spend[id]+v[id][i].cost; &#125; &#125; printf(&quot;%d %d\n&quot;,dis[y],spend[y]); &#125; return 0;&#125;2.Floyd算法弗洛伊德算法（解决多源最短路径）：时间复杂度O(n^3),空间复杂度O(n^2)12345678910111213141516171819202122232425262728293031323334353637思想：最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转......允许经过1~n号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。即求从i号顶点到j号顶点只经过前k号点的最短路程。#include&lt;iostream&gt;#include&lt;string.h&gt;#define inf 99999999using namespace std;int n,dis[111][111];void init()&#123; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++) dis[i][j]=inf; dis[i][i]=0; &#125;&#125;int main()&#123; int m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; init(); while(m--)&#123; int x,y,len; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); dis[x][y]=min(dis[x][y],len); dis[y][x]=dis[x][y]; &#125; for(int k=1;k&lt;=n;k++)//要经过的点 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); printf(&quot;%d\n&quot;,dis[1][n]);//可以选任意两点之间的距离 &#125; return 0;&#125;3.DFS/BFS算法深度或广度优先搜索算法（解决单源最短路径）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263从起始结点开始访问所有的深度遍历路径或广度优先路径，则到达终点结点的路径有多条，取其中路径权值最短的一条则为最短路径。给定一个带权有向图G=（V,E），其中每条边的权是一个实数。另外，还给定V中的一个顶点，称为源。现在要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径 [1] 问题。从起始结点开始访问所有的深度遍历路径或广度优先路径，则到达终点结点的路径有多条，取其中路径权值最短的一条则为最短路径#include&lt;iostream&gt;#include&lt;string.h&gt;#define inf 99999999using namespace std;int dis[111][111];bool vis[111];int n,cnt;//n为节点数,cnt为最短长度void init(int x)&#123; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=n;j++) dis[i][j]=inf; dis[i][i]=0; vis[i]=0; &#125;&#125;void dfs(int st,int dst)&#123; if(dst&gt;cnt)return ;//距离大于最短路径，无需遍历 if(st==n)&#123;//到达终点 cnt=cnt&gt;dst?dst:cnt; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(!vis[i]&amp;&amp;dis[st][i]!=inf&amp;&amp;dis[st][i])&#123; vis[i]=1; dfs(i,dst+dis[st][i]); vis[i]=0; &#125; &#125;&#125;int main()&#123; int m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)&amp;&amp;n&amp;&amp;m) &#123; int x,y,len; cnt=inf; init(n); while(m--)&#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;len); dis[x][y]=min(dis[x][y],len);//两点之间距离重复输入取小距离 dis[y][x]=dis[x][y]; &#125; vis[1]=1; dfs(1,0); printf(&quot;%d\n&quot;,cnt); &#125; return 0;&#125;4.Bellman-FordBellman-Ford算法(解决负权边，解决单源最短路径，前几种方法不能求含负权边的图)：：时间复杂度O(nm),空间复杂度O(m)1234主要思想：对所有的边进行n-1轮松弛操作，因为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边。换句话说，第1轮在对所有的边进行松弛后，得到的是从1号顶点只能经过一条边到达其余各定点的最短路径长度。第2轮在对所有的边进行松弛后，得到的是从1号顶点只能经过两条边到达其余各定点的最短路径长度，......代码待补]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM题]]></title>
    <url>%2F2019%2F05%2F22%2F%E9%A2%98%E7%9B%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目集将用来集中题目和提高自己的能力奉上一段千古名句：模拟只会猜题意，贪心只能过样例。数学上来先打表，DP 一般看规律。组合数学靠运气，计算几何瞎暴力。图论一顿套模板，数论只会 GCD。题解：https://weakdouqing.github.io/2019/06/25/%E9%A2%98%E8%A7%A3/#more1.The Triangle(DP)链接：http://poj.org/problem?id=116312345678910111213141516171819202122232425例题：The Triangle 73 88 1 02 7 4 44 5 2 6 5(Figure 1)Figure 1 shows a number triangle. Write a program that calculates the highest sum of numbers passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right. InputYour program is to read from standard input. The first line contains one integer N: the number of rows in the triangle. The following N lines describe the data of the triangle. The number of rows in the triangle is &gt; 1 but &lt;= 100. The numbers in the triangle, all integers, are between 0 and 99. OutputYour program is to write to standard output. The highest sum is written as an integer. Sample Input573 88 1 0 2 7 4 44 5 2 6 5Sample Output302.区间完美数(gcd/lcm)链接: https://hpuoj.com/contest/20/problem/F/Problem Description：对于给定的区间[a,b]，codancer想统计[a,b]内有多少数既不是c的倍数，也不是d的倍数。Input单组输入输入四个数a,b,c,d(1≤a≤b≤1018,1≤c,d≤109)Output输出[a,b]内既不是c的倍数，也不是d的倍数的数的个数。Sample Input2 6 2 3Sample Output1PS：样例解释:[2,6]内的数为2,3,4,5,6,其中只有5既不是2的倍数也不是3的倍数。3.最短路链接: http://acm.hdu.edu.cn/showproblem.php?pid=2544Problem Description在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？Input输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。输入保证至少存在1条商店到赛场的路线。Output对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间Sample Input2 11 2 33 31 2 52 3 53 1 20 0Sample Output32]]></content>
      <categories>
        <category>ACM</category>
        <category>Questions Set</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马大定理]]></title>
    <url>%2F2019%2F05%2F20%2F%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[费马大定理又被称为“费马最后的定理”。由17世纪法国数学家皮耶·德·费玛提出。他断言当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;int main()&#123; int n,t; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++)&#123; cin&gt;&gt;n; if(n&lt;=2) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCM]]></title>
    <url>%2F2019%2F05%2F17%2FLCM%2F</url>
    <content type="text"><![CDATA[LCM(最小公倍数):简单公式： lcm = a / gcd * b实用方法：gcd(ka, kb) = k gcd(a, b) lcm(ka, kb) = k lcm(a, b)c++实现1234567891011121314151617181920212223242526272829303132333435363738394041输入2个正整数A，B，求A与B的最小公倍数。 Input2个数A,B，中间用空格隔开。(1&lt;= A,B &lt;= 10^9)Output输出A与B的最小公倍数。Input示例30 105Output示例210题解：#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int a, b; cin &gt;&gt; a &gt;&gt; b; int m = a; int n = b; if (a &lt; b) &#123; int temp = a; a = b; b = temp; &#125; int c; while (b != 0) &#123; c = a % b; a = b; b = c; &#125; cout &lt;&lt; (long long int)(m/a)*n &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD]]></title>
    <url>%2F2019%2F05%2F16%2FGCD%2F</url>
    <content type="text"><![CDATA[GCD(最大公约数):欧几里得算法据说是最早的算法，用于计算最大公约数，也是数论的基础算法之一。这里给出使用欧几里得算法求最大公约数的递归和非递归的程序，同时给出穷举法求最大公约数的程序。从计算时间上看，递推法计算速度最快。程序中包含条件编译语句用于统计分析计算复杂度。1234567891011121314151617181920代码： 递归算法： ll gcd(ll a,ll b)&#123; return b==0?a:gcd(b,a%b);&#125;循环算法：/* 迭代法（递推法）：欧几里得算法，计算最大公约数 */int gcd(int m, int n)&#123; while(m) &#123; int c = n % m; n = m; m = c; &#125; return n;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错排]]></title>
    <url>%2F2019%2F05%2F16%2F%E9%94%99%E6%8E%92%2F</url>
    <content type="text"><![CDATA[错排：公式：a[i]=(i-1)*(a[i-1]+a[i-2])链接：https://blog.csdn.net/achesong/article/details/87387024错排公式的原形为D(n) = n! (1/0! - 1/1! + 1/2! - 1/3! - ….. + (-1)^n/n!)，当n很大时计算就很不方便。一个供参考的简化后的公式是D(n) = [n!/e+0.5] ，其中e是自然对数的底，[x]为x的整数部分。123456789101112131415161718证明：由于1/e = e^(-1) = 1/0! - 1/1! + 1/2! - 1/3! - ..... + (-1)^n/n! + Rn(-1),其中Rn(-1)是余项，等于(-1)^(n+1) * e^u / (n+1)!，且u∈(-1, 0).所以，D(n) = n! * e^(-1) - (-1)^(n+1) * e^u / (n+1), u∈(-1, 0).而|n! Rn| = |(-1)^(n+1) * e^u / (n+1)| = e^u / (n+1) ∈ (1/[e(n+1)], 1/(n+1))，可知即使在n=1时，该余项（的绝对值）也小于1/2。因此，无论n! Rn是正是负，n! / e + 1/2的整数部分都一定与M(n)相同。对于比较小的n，结果及简单解释是：D(0) = 0（所有的元素都放回原位、没有摆错的情况）D(1) = 0（只剩下一个元素，无论如何也不可能摆错）D(2) = 1（两者互换位置）D(3) = 2（ABC变成BCA或CAB）D(4) = 9D(5) = 44D(6) = 265D(7) = 1854D(8) = 14833D(9) = 133496D(10) = 1334961]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo教程]]></title>
    <url>%2F2019%2F05%2F14%2FHexo%2F</url>
    <content type="text"><![CDATA[Hexo ConfigurationDocs: http://hexo.io/docs/configuration.htmlSource: https://github.com/hexojs/hexo/1.Site 站点信息123456789101112131415title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:2.Directory(目录)123456789101112131415source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:3.Category &amp; Tag(分类和标签)default_category: uncategorized #默认分类category_map:tag_map:4.Archives12345678910112: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev5.Date / Time format(日期时间格式)12345678910111213date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap6.Deployment(部署，将 lmintlcx 改成用户名)1234deploy:type: gitrepo: github创库地址.gitbranch: master]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单排序]]></title>
    <url>%2F2019%2F05%2F13%2F%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[简单排序：sort(a,a+n);——默认是正序 头文件是algorithma是数组，或字符串，反正好多都可以排，包括结构体，string，n是排序长度。1234567891011#include&lt;iostream&gt; C++中标准输入输出#include&lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123;return a&gt;b&#125;; //返回值为0或者1，可以换成intint main()&#123; int a[10]=&#123;-1,3,-6,3,-4,0,7,-2,5,8&#125;; sort(a,a+10,cmp); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++基础]]></title>
    <url>%2F2019%2F05%2F12%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[C++一点内容：重点：当数组定义为全局变量时，数组如果没有初始化，默认为零（0）；大佬的博客链接：https://blog.csdn.net/c20182030/article/list/1?t=1&amp;1.时间/空间复杂度：具体链接：https://blog.csdn.net/qq347198688/article/details/5272576412341.时间复杂度：时间复杂度和空间复杂度一般是针对算法而言，是衡量一个算法是否高效的重要标准。先纠正一个误区，时间复杂度并不是算法执行的时间，再纠正一个误区，算法不单单指冒泡排序之类的，一个循环甚至是一个判断都可以称之为算法。其实理解起来并不冲突，八大排序甚至更多的算法本质上也是通过各种循环判断来实现的。2.空间复杂度：空间复杂度就是一个算法在运行过程中临时占用的存储空间大小，换句话说就是被创建次数最多的变量，它被创建了多少次，那么这个算法的空间复杂度就是多少。具体实现上图：2.OJ判题原理：Online Judge系统（简称OJ）是一个在线的判题系统。用户可以在线提交程序多种程序（如C、C++）源代码，系统对源代码进行编译和执行，并通过与预先设计的测试数据进行比较来检验程序源代码的正确性。万能头文件 #include&lt;bits/stdc++.h&gt;但是有些OJ不支持链接：https://www.cnblogs.com/Kiven5197/p/5745589.html12345678910111213141516171819万能头文件包含的部分文件：#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;fstream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;deque&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;cstring&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;set&gt; using namespace std;int main()&#123; return 0;&#125;C++简单计算a+b为了熟悉一个C++的简单操作123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,sum; // const int a,b; 也可以这样定义变量，c++提供的另一种定义变量的方法 cout&lt;&lt;"请输入两个整数:"&lt;&lt;endl; //cout必须和&lt;&lt;配着用,表示输出 //endl:end line的缩写，与C语言的\n功能一样，强行换行 cin&gt;&gt;a&gt;&gt;b; //cin与&gt;&gt;配合用,表示输入 sum=a+b; cout&lt;&lt;sum; //cout必须和&lt;&lt;配着用,表示输出 //使用cout&lt;&lt;输出的时候不用考虑输出的数据类型，cout会自动考虑 return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
