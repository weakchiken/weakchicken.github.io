<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dou Qing</title>
  
  <subtitle>~人间有万紫千红~&lt;br&gt;~唯你是我情之所钟~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-05T14:34:12.883Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集训中学到的方法</title>
    <link href="http://yoursite.com/2019/08/30/%E9%9B%86%E8%AE%AD%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/30/集训中学到的方法/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-08-05T14:34:12.883Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="学习就该如贪心！！一直向前-！"><a href="#学习就该如贪心！！一直向前-！" class="headerlink" title="学习就该如贪心！！一直向前~！"></a><center>学习就该如贪心！！一直向前~！</center></h1><p><center>记录一些会用到并且好用的函数<br>或者是容易混淆的知识点<br><code>持续更新</code><br><a id="more"></a></center></p><h2 id="STL的定义方式："><a href="#STL的定义方式：" class="headerlink" title="STL的定义方式："></a>STL的定义方式：</h2><p>set/stack/queue/vector &lt;int/string&gt; 定义名称；<br><code>set</code>有自动排序的功能(从小到大)</p><blockquote><p>set里面用的是平衡二叉搜索树（也就是红黑树）维护</p></blockquote><p>string 字符串名称；<br>map&lt;string/int, int/string&gt; 名称；</p><h3 id="set的迭代器："><a href="#set的迭代器：" class="headerlink" title="set的迭代器："></a>set的迭代器：</h3><p>set<int>:: iterator it;<br>这个it是为指针用法<br>eg：<br>it = st.begin();<br>cout &lt;&lt; <em>it;<br>it ++;<br>for(; it != st.end(); it ++)<br>{<br>cout &lt;&lt; “ “ &lt;&lt; </em>it;<br>}</int></p><h3 id="map的迭代器："><a href="#map的迭代器：" class="headerlink" title="map的迭代器："></a>map的迭代器：</h3><p>map&lt;string, int&gt; :: iterator mp;<br>这个mp用法要用mp -&gt; first 或者mp -&gt; second 来表示<br>eg：<br>map&lt;string, int&gt; :: iterator it1;<br>map&lt;string, node&gt; :: iterator it2;<br>for(it2 = mp.begin(); it2 != mp.end(); it2 ++)<br>{<br>cout &lt;&lt; it2 -&gt; first &lt;&lt; endl;<br>for(it1 = mp[it2 -&gt; first].count.begin(); it1 != mp[it2 -&gt; first].count.end(); it1 ++)<br>{<br>cout &lt;&lt; “|—-“ &lt;&lt; it1 -&gt; first &lt;&lt; “(“ &lt;&lt; it1 -&gt; second &lt;&lt; “)” &lt;&lt; endl;<br>}<br>}</p><h3 id="嵌套map用法可以为"><a href="#嵌套map用法可以为" class="headerlink" title="嵌套map用法可以为"></a>嵌套map用法可以为</h3><p>struct node{<br>map&lt;string, int&gt; count;<br>};</p><p>map&lt;string, node&gt; mp;</p><p>用的时候为：mp[string].count[string] ++;或者一些操作</p><h2 id="二分查找–binary-search的用法"><a href="#二分查找–binary-search的用法" class="headerlink" title="二分查找–binary_search的用法"></a>二分查找–binary_search的用法</h2><p>头文件 <code>#include &lt;algorithm&gt;</code></p><p>使用方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.函数模板：binary_search(arr[],arr[]+size ,  indx)</span><br><span class="line">b.参数说明：</span><br><span class="line">    arr[]： 数组首地址</span><br><span class="line">    size：数组元素个数</span><br><span class="line">    indx:需要查找的值</span><br><span class="line">c.函数功能：  在数组中以二分法检索的方式查找，若在数组(要求数组元素非递减)中查找到indx元素则真，若查找不到则返回值为假。</span><br></pre></td></tr></table></figure><p></p><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>查找第一个大于或等于某个元素的位置<br>使用方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a.函数模板：lower_bound(arr[],arr[]+size ,  indx):</span><br><span class="line">b.参数说明：</span><br><span class="line">    arr[]： 数组首地址</span><br><span class="line">    size：数组元素个数</span><br><span class="line">    indx:需要查找的值</span><br><span class="line">c.函数功能:函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置(注意是地址)。如果所有元素都小于val，则返回last的位置</span><br><span class="line">d.举例如下：</span><br><span class="line">　　一个数组number序列为：4,10,11,30,69,70,96,100.设要插入数字3,9,111.pos为要插入的位置的下标，则</span><br><span class="line">　　/*注意因为返回值是一个指针，所以减去数组的指针就是int变量了*/</span><br><span class="line">　　pos = lower_bound( number, number + 8, 3) - number，pos = 0.即number数组的下标为0的位置。</span><br><span class="line">　　pos = lower_bound( number, number + 8, 9) - number， pos = 1，即number数组的下标为1的位置（即10所在的位置）。</span><br><span class="line">　　pos = lower_bound( number, number + 8, 111) - number， pos = 8，即number数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。</span><br><span class="line">e.注意：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的！</span><br></pre></td></tr></table></figure><p></p><h3 id="upper-bound-查找第一个大于某个位置的元素的位置"><a href="#upper-bound-查找第一个大于某个位置的元素的位置" class="headerlink" title="upper_bound: 查找第一个大于某个位置的元素的位置"></a>upper_bound: 查找第一个大于某个位置的元素的位置</h3><p>使用方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.函数模板：upper_bound(arr[],arr[]+size ,  indx):</span><br><span class="line">b.参数说明：</span><br><span class="line">    arr[]： 数组首地址</span><br><span class="line">    size：数组元素个数</span><br><span class="line">    indx:需要查找的值</span><br><span class="line">c.函数功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置</span><br><span class="line">　　例如：一个数组number序列1,2,2,4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置,同样，如果插入元素大于数组中全部元素，返回的是last。(注意：数组下标越界)</span><br><span class="line">　　返回查找元素的最后一个可安插位置，也就是“元素值&gt;查找值”的第一个元素的位置 。</span><br></pre></td></tr></table></figure><p></p><h2 id="gcd的前缀后缀维护"><a href="#gcd的前缀后缀维护" class="headerlink" title="gcd的前缀后缀维护"></a>gcd的前缀后缀维护</h2><p>说到gcd,就不得不提一下<br>C++11中子代有内置gcd函数,用法是 __gcd(a, b);</p><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6025" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6025</a></p><p><code>持续更新</code><br>PS:暂时不会讲解，先看代码吧，等以后理解透了在讲解<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">if(a&lt;b)&#123;</span><br><span class="line">int t=a;</span><br><span class="line">a=b;b=t;</span><br><span class="line">&#125;</span><br><span class="line">return b==0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int a[1000005],q[1000005],h[1000005];</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">memset(q,0,sizeof(q));</span><br><span class="line">memset(h,0,sizeof(h));</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">q[0]=a[0];</span><br><span class="line">for(i=1;i&lt;n-1;i++)&#123;</span><br><span class="line">q[i]=gcd(q[i-1],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">h[n-1]=a[n-1];</span><br><span class="line">for(i=n-2;i&gt;0;i--)&#123;</span><br><span class="line">h[i]=gcd(h[i+1],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">int ans=max(q[n-2],h[1]);</span><br><span class="line">for(i=1;i&lt;n-1;i++)&#123;</span><br><span class="line">ans=max(ans,gcd(q[i-1],h[i+1]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="C-中auto的用法"><a href="#C-中auto的用法" class="headerlink" title="C++中auto的用法"></a>C++中auto的用法</h2><h3 id="C-98-auto"><a href="#C-98-auto" class="headerlink" title="C++98 auto"></a>C++98 auto</h3><p>早在C++98标准中就存在了auto关键字，那时的auto用于声明变量为自动变量，自动变量意为拥有自动的生命期，这是多余的，因为就算不使用auto声明，变量依旧拥有自动的生命期：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a =10 ;  //拥有自动生命期</span><br><span class="line">auto int b = 20 ;//拥有自动生命期</span><br><span class="line">static int c = 30 ;//延长了生命期</span><br></pre></td></tr></table></figure><p></p><p>C++98中的auto多余且极少使用，C++11已经删除了这一用法，取而代之的是全新的auto：变量的自动类型推断。</p><h3 id="C-11-auto"><a href="#C-11-auto" class="headerlink" title="C++11 auto"></a>C++11 auto</h3><p>auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">auto au_a = a;//自动类型推断，au_a为int类型</span><br><span class="line">cout &lt;&lt; typeid(au_a).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p></p><p>typeid运算符可以输出变量的类型。程序的运行结果输出了<br>int<br>这种用法就类似于C#中的var关键字。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。而是否会造成编译期的时间消耗，我认为是不会的，在未使用auto时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。</p><h3 id="为什么用auto"><a href="#为什么用auto" class="headerlink" title="为什么用auto:"></a>为什么用auto:</h3><p>用于代替冗长复杂、变量使用范围专一的变量声明。<br>想象一下在没有auto的时候，我们操作标准库时经常需要这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; vs;</span><br><span class="line">    for (vector&lt;string&gt;::iterator i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用auto 可以简化代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; vs;</span><br><span class="line">    for (auto i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="pair的用法"><a href="#pair的用法" class="headerlink" title="pair的用法"></a>pair的用法</h2><h3 id="pair的应用"><a href="#pair的应用" class="headerlink" title="pair的应用"></a>pair的应用</h3><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。<br>另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            //创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2);    //创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span><br><span class="line">make_pair(v1, v2);          // 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span><br><span class="line">p1 &lt; p2;                    // 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span><br><span class="line">p1 == p2；                  // 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span><br><span class="line">p1.first;                   // 返回对象p1中名为first的公有数据成员</span><br><span class="line">p1.second;                 // 返回对象p1中名为second的公有数据成员</span><br></pre></td></tr></table></figure><p></p><h3 id="pair的创建和初始化"><a href="#pair的创建和初始化" class="headerlink" title="pair的创建和初始化"></a>pair的创建和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pair包含两个数值，与容器一样，pair也是一种模板类型。但是又与之前介绍的容器不同；</span><br><span class="line">在创建pair对象时，必须提供两个类型名，两个对应的类型名的类型不必相同</span><br><span class="line"></span><br><span class="line">pair&lt;string, string&gt; anon;        // 创建一个空对象anon，两个元素类型都是string</span><br><span class="line">pair&lt;string, int&gt; word_count;     // 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span><br><span class="line">pair&lt;string, vector&lt;int&gt; &gt; line;  // 创建一个空对象line，两个元素类型分别是string和vector类型</span><br><span class="line"></span><br><span class="line">当然也可以在定义时进行成员初始化：</span><br><span class="line">pair&lt;string, string&gt; author(&quot;James&quot;,&quot;Joy&quot;);    // 创建一个author对象，两个元素类型分别为string类型，并默认初始值为James和Joy。</span><br><span class="line">pair&lt;string, int&gt; name_age(&quot;Tom&quot;, &quot;18&quot;);</span><br><span class="line">pair&lt;string, int&gt; name_age2(name_age);    // 拷贝构造初始化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：</span><br><span class="line">typedef pair&lt;string,string&gt; Author;</span><br><span class="line">Author proust(&quot;March&quot;,&quot;Proust&quot;);</span><br><span class="line">Author Joy(&quot;James&quot;,&quot;Joy&quot;);</span><br><span class="line"></span><br><span class="line">变量间赋值：</span><br><span class="line">pair&lt;int, double&gt; p1(1, 1.2);</span><br><span class="line">pair&lt;int, double&gt; p2 = p1;     //operator =</span><br></pre></td></tr></table></figure><h2 id="pair对象的操作"><a href="#pair对象的操作" class="headerlink" title="pair对象的操作"></a>pair对象的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int ,double&gt; p1;</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;p1.first&lt;&lt;&apos; &apos;&lt;&lt;p1.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">//输出结果：1 2.5</span><br><span class="line"></span><br><span class="line">string firstBook;</span><br><span class="line">if(author.first==&quot;James&quot; &amp;&amp; author.second==&quot;Joy&quot;)</span><br><span class="line">    firstBook=&quot;Stephen Hero&quot;;</span><br></pre></td></tr></table></figure><h2 id="生成新的pair对象"><a href="#生成新的pair对象" class="headerlink" title="生成新的pair对象"></a>生成新的pair对象</h2><p>还可以利用make_pair创建新的pair对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;</span><br><span class="line">p1 = make_pair(1, 1.2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//output: 1 1.2</span><br><span class="line"></span><br><span class="line">int a = 8;</span><br><span class="line">string m = &quot;James&quot;;</span><br><span class="line">pair&lt;int, string&gt; newone;</span><br><span class="line"></span><br><span class="line">newone = make_pair(a, m);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; newone.first &lt;&lt; newone.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//output: 8 James</span><br></pre></td></tr></table></figure><p></p><h2 id="通过tie获取pair元素值"><a href="#通过tie获取pair元素值" class="headerlink" title="通过tie获取pair元素值"></a>通过tie获取pair元素值</h2><p>在某些清况函数会以pair对象作为返回值时，可以直接通过std::tie进行接收。比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;std::string, int&gt; getPreson() &#123;</span><br><span class="line">    return std::make_pair(&quot;Sven&quot;, 25);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int ages;</span><br><span class="line"></span><br><span class="line">    std::tie(name, ages) = getPreson();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; &quot;, ages: &quot; &lt;&lt; ages &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="有关字符串的一些用法"><a href="#有关字符串的一些用法" class="headerlink" title="有关字符串的一些用法"></a>有关字符串的一些用法</h2><p>1.isalpha(c) ~判断是否为英文字符<br>2.tolower(c) ~将字符转换成小写<br>3.字符串输入sstream<br>4.将字符串分割成单词：<br>stringstream temp(str); //分割成一个个单词<br>5.将字符串插入进set中，自动排序~</p><h2 id="stringstream的用法："><a href="#stringstream的用法：" class="headerlink" title="stringstream的用法："></a>stringstream的用法：</h2><p>stringstream是 C++ 提供的另一个字串型的串流(stream)物件，和之前学过的iostream、fstream有类似的操作方式。要使用stringstream， 必须先加入这一行：</p><p>#include<sstream><br>stringstream主要是用在將一个字符串分割，可以先用.clear( )以及.str( )將指定字串设定成一开始的內容，再用&gt;&gt;把个別的资料输出。</sstream></p><p>Eg:<br>題目：输入的第一行有一个数字 N 代表接下來有 N 行资料，每一行资料里有不固定个数的整数(最多20个，每行最大200个字元)，编程將每行的总和打印出來。<br>输入：<br>3<br>1 2 3<br>20 17 23 54 77 60<br>111 222 333 444 555 666 777 888 999<br>输出：<br>6<br>251<br>4995<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    getline(cin, s);  //读取换行</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin, s);</span><br><span class="line">        ss.clear();</span><br><span class="line">        ss.str(s);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            int a;</span><br><span class="line">            ss &gt;&gt; a;</span><br><span class="line">            if(ss.fail())</span><br><span class="line">                break;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用stringstream简化类型转换<br>C++标准库中的<sstream>提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，即单纯性、类型安全和可扩展性。接下来，我将举例说明怎样使用这些库来实现安全和自动的类型转换。<br>Eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 10000;</span><br><span class="line">    char s[10];</span><br><span class="line"></span><br><span class="line">    sprintf(s, &quot;%d&quot;, n);</span><br><span class="line">    //s中的内容为“10000”</span><br><span class="line"></span><br><span class="line">//到目前为止看起来还不错。但是，对上面代码的一个微小的改变就会使程序发生错误</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, s);</span><br><span class="line">    sprintf(s, &quot;%f&quot;, n);</span><br><span class="line">    </span><br><span class="line">//错误的格式化符</span><br><span class="line">    printf(&quot;%s\n&quot;, s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sstream></p><p><code>详细学习链接</code>：<br><a href="http://blog.csdn.net/zhang_xueping/article/details/47846807" target="_blank" rel="noopener">http://blog.csdn.net/zhang_xueping/article/details/47846807</a><br><a href="http://blog.csdn.net/u014097230/article/details/52089530" target="_blank" rel="noopener">http://blog.csdn.net/u014097230/article/details/52089530</a></p><h2 id="优先队列—自动排序！！！"><a href="#优先队列—自动排序！！！" class="headerlink" title="优先队列—自动排序！！！"></a>优先队列—自动排序！！！</h2><p>说道优先队列就必须提一句<br>优先队列别有back()操作，并且第一个元素不是用front()而是top()，，，front()是队列的<br>优先队列是一种特殊的队列，在学习堆排序的时候就有所了解。<br><a href="https://blog.csdn.net/c20182030/article/details/52727101" target="_blank" rel="noopener">堆排序</a></p><h2 id="奇偶剪枝"><a href="#奇偶剪枝" class="headerlink" title="奇偶剪枝"></a>奇偶剪枝</h2><p><a href="https://www.cnblogs.com/wkfvawl/p/9337156.html" target="_blank" rel="noopener">点这里</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;学习就该如贪心！！一直向前-！&quot;&gt;&lt;a href=&quot;#学习就该如贪心！！一直向前-！&quot; class=&quot;headerlink&quot; title=&quot;学习就该如贪心！！一直向前~！&quot;&gt;&lt;/a&gt;&lt;center&gt;学习就该如贪心！！一直向前~！&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;center&gt;记录一些会用到并且好用的函数&lt;br&gt;或者是容易混淆的知识点&lt;br&gt;&lt;code&gt;持续更新&lt;/code&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/ACM/Algorithm/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Day19</title>
    <link href="http://yoursite.com/2019/08/07/Day19/"/>
    <id>http://yoursite.com/2019/08/07/Day19/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-08-07T14:30:57.716Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day19"><a href="#Day19" class="headerlink" title="Day19"></a>Day19</h1><p>今天讲的是拓扑排序算法<br>努力学习！！<br><a href="https://vjudge.net/contest/317983#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="加一个-假-模板"><a href="#加一个-假-模板" class="headerlink" title="加一个(假)模板"></a>加一个(假)模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int in[10100];// 存入度</span><br><span class="line">vector&lt;int&gt; v[10100];// 存关系 构建图</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m,n;</span><br><span class="line">int x,y;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)// 根据题目要求可以改动</span><br><span class="line">&#123;</span><br><span class="line">memset(in,0,sizeof(in));// 清空入度</span><br><span class="line">for(int i=1;i&lt;=n;i++) v[i].clear() ;// 清空vector</span><br><span class="line">while(m--)// m组数据</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;y&gt;&gt;x;</span><br><span class="line">in[y]++;// y的关系大于x，x指向y y的入度+1；</span><br><span class="line">v[x].push_back(y);// 就 y 放在 x后面</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt;q;// 定义一个队列 最为节点的删除</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!in[i]) &#123; // 入度为零的节点放入 队列</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty() )</span><br><span class="line">&#123;</span><br><span class="line">int xx=q.front() ; // 如果队列中一次存了大于 2 个节点</span><br><span class="line">q.pop() ; //说明该图有 2-&gt;3 &amp;&amp; 2-&gt;4 这种情况 有点个点之间没有关系</span><br><span class="line">n--; // 总节点数 -1；</span><br><span class="line">for(int i=0;i&lt;v[xx].size() ;i++) // 遍历这个节点后面的 点</span><br><span class="line">&#123;</span><br><span class="line">int yy=v[xx][i];</span><br><span class="line">in[yy]--; // 删除 x 后 yy 的入度就 -1；</span><br><span class="line">if(!in[yy]) &#123; // 如果此时 yy 入度为零放入队列 遍历他的下一个节点</span><br><span class="line">q.push(yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n) cout&lt;&lt;&quot;该图有环&quot;&lt;&lt;endl; // 如果总结点数没减为零 说明有环的存在</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Genealogical-tree"><a href="#Genealogical-tree" class="headerlink" title="Genealogical tree"></a>Genealogical tree</h1><p>Description:<br>The system of Martians’ blood relations is confusing enough. Actually, Martians bud when they want and where they want. They gather together in different groups, so that a Martian can have one parent as well as ten. Nobody will be surprised by a hundred of children. Martians have got used to this and their style of life seems to them natural.<br>And in the Planetary Council the confusing genealogical system leads to some embarrassment. There meet the worthiest of Martians, and therefore in order to offend nobody in all of the discussions it is used first to give the floor to the old Martians, than to the younger ones and only than to the most young childless assessors. However, the maintenance of this order really is not a trivial task. Not always Martian knows all of his parents (and there’s nothing to tell about his grandparents!). But if by a mistake first speak a grandson and only than his young appearing great-grandfather, this is a real scandal.<br>Your task is to write a program, which would define once and for all, an order that would guarantee that every member of the Council takes the floor earlier than each of his descendants.<br><code>Input</code><br>The first line of the standard input contains an only number N, 1 &lt;= N &lt;= 100 — a number of members of the Martian Planetary Council. According to the centuries-old tradition members of the Council are enumerated with the natural numbers from 1 up to N. Further, there are exactly N lines, moreover, the I-th line contains a list of I-th member’s children. The list of children is a sequence of serial numbers of children in a arbitrary order separated by spaces. The list of children may be empty. The list (even if it is empty) ends with 0.<br><code>Output</code><br>The standard output should contain in its only line a sequence of speakers’ numbers, separated by spaces. If several sequences satisfy the conditions of the problem, you are to write to the standard output any of them. At least one such sequence always exists.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">4 5 1 0</span><br><span class="line">1 0</span><br><span class="line">5 3 0</span><br><span class="line">3 0</span><br><span class="line">Sample Output</span><br><span class="line">2 4 5 3 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">//清空图 </span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">v[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">//存图，找度数 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1;; j ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">if(x == 0) break;</span><br><span class="line">v[i].push_back(x);</span><br><span class="line">in[x] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">//找到0入度，加入队列 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; xx;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else cout &lt;&lt; &quot; &quot; &lt;&lt; xx;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Window-Pains"><a href="#Window-Pains" class="headerlink" title="Window Pains"></a>Window Pains</h1><p>Description:<br>Boudreaux likes to multitask, especially when it comes to using his computer. Never satisfied with just running one application at a time, he usually runs nine applications, each in its own window. Due to limited screen real estate, he overlaps these windows and brings whatever window he currently needs to work with to the foreground. If his screen were a 4 x 4 grid of squares, each of Boudreaux’s windows would be represented by the following 2 x 2 windows:</p><p>When Boudreaux brings a window to the foreground, all of its squares come to the top, overlapping any squares it shares with other windows. For example, if window 1 and then window 2 were brought to the foreground, the resulting representation would be:</p><p>If window 4 were then brought to the foreground:</p><p>. . . and so on . . .<br>Unfortunately, Boudreaux’s computer is very unreliable and crashes often. He could easily tell if a crash occurred by looking at the windows and seeing a graphical representation that should not occur if windows were being brought to the foreground correctly. And this is where you come in . . .</p><p><code>Input</code><br>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets.</p><p>A single data set has 3 components:<br>Start line - A single line:<br>START</p><p>Screen Shot - Four lines that represent the current graphical representation of the windows on Boudreaux’s screen. Each position in this 4 x 4 matrix will represent the current piece of window showing in each square. To make input easier, the list of numbers on each line will be delimited by a single space.<br>End line - A single line:<br>END</p><p>After the last data set, there will be a single line:<br>ENDOFINPUT</p><p>Note that each piece of visible window will appear only in screen areas where the window could appear when brought to the front. For instance, a 1 can only appear in the top left quadrant.<br><code>Output</code><br>For each data set, there will be exactly one line of output. If there exists a sequence of bringing windows to the foreground that would result in the graphical representation of the windows on Boudreaux’s screen, the output will be a single line with the statement:</p><p>THESE WINDOWS ARE CLEAN</p><p>Otherwise, the output will be a single line with the statement:<br>THESE WINDOWS ARE BROKEN</p><p>题意：<br>给你一个4<em>4的棋盘窗口,现在电脑上有9个应用,每个应用占用固定的2</em>2正方形网格位置.你通过不同的顺序操作9个应用可以使得4<em>4的窗口当前显示的内容(数字代表)不同,现在给你一个4</em>4棋盘窗口的内容,问你这个内容是否合法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">START</span><br><span class="line">1 2 3 3</span><br><span class="line">4 5 6 6</span><br><span class="line">7 8 9 9</span><br><span class="line">7 8 9 9</span><br><span class="line">END</span><br><span class="line">START</span><br><span class="line">1 1 3 3</span><br><span class="line">4 1 3 3</span><br><span class="line">7 7 9 9</span><br><span class="line">7 7 9 9</span><br><span class="line">END</span><br><span class="line">ENDOFINPUT</span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line">THESE WINDOWS ARE CLEAN</span><br><span class="line">THESE WINDOWS ARE BROKEN</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=10;</span><br><span class="line">vector&lt;int&gt; value[maxn][maxn];</span><br><span class="line">int dr[]=&#123;0,1,0,1&#125;;//原地,下,右,右下</span><br><span class="line">int dc[]=&#123;0,0,1,1&#125;;</span><br><span class="line">int G[maxn][maxn]; //图</span><br><span class="line">int in[maxn];      //入度</span><br><span class="line"> </span><br><span class="line">bool topo()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; Q;</span><br><span class="line">    for(int i=0;i&lt;9;i++)</span><br><span class="line">        if(in[i]==0) Q.push(i);</span><br><span class="line">    int sum=0;//记录我们删除的0入度点</span><br><span class="line">    while(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int u=Q.front(); Q.pop();</span><br><span class="line">        for(int v=0;v&lt;9;v++)if(G[u][v])</span><br><span class="line">        &#123;</span><br><span class="line">            G[u][v]=0;</span><br><span class="line">            if(--in[v]==0) Q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum==9;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;9;i++)                //处理0-8每个应用所在的方格vector</span><br><span class="line">    &#123;</span><br><span class="line">        int r=i/3, c=i%3;               //i应用左上角的格子所在的(r,c)</span><br><span class="line">        for(int dir=0;dir&lt;4;dir++)      //i应用所在的其他3个点</span><br><span class="line">        &#123;</span><br><span class="line">            int nr=r+dr[dir], nc=c+dc[dir];</span><br><span class="line">            value[nr][nc].push_back(i); //将i压入对应方格的vector中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    char str[100];</span><br><span class="line">    while(scanf(&quot;%s&quot;,str)==1&amp;&amp;str[0]!=&apos;E&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(G,0,sizeof(G));</span><br><span class="line">        memset(in,0,sizeof(in));</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">        for(int j=0;j&lt;4;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int v;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;v);</span><br><span class="line">            v--;</span><br><span class="line">            for(int k=0;k&lt;value[i][j].size();k++)</span><br><span class="line">            if((value[i][j])[k]!=v)//构造有向边</span><br><span class="line">            &#123;</span><br><span class="line">                int x=(value[i][j])[k];</span><br><span class="line">                if(G[x][v]==0)//一定要做这个判断,因为会重复添加有向边</span><br><span class="line">                &#123;</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    G[x][v]=1;</span><br><span class="line">                &#125;</span><br><span class="line">                //printf(&quot;当前格子为:(%d,%d),当前边为:%d v=%d, %d点的入度为%d\n&quot;,i,j,x,v,v,in[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(topo()) printf(&quot;THESE WINDOWS ARE CLEAN\n&quot;);</span><br><span class="line">        else printf(&quot;THESE WINDOWS ARE BROKEN\n&quot;);</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="确定比赛名次（拓扑排序）"><a href="#确定比赛名次（拓扑排序）" class="headerlink" title="确定比赛名次（拓扑排序）"></a>确定比赛名次（拓扑排序）</h1><p>Description:<br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。<br><code>Input</code><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。<br><code>Output</code><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line">Sample Output</span><br><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">//清空图 </span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">v[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">//存图，找度数 </span><br><span class="line">while(m --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">//找到0入度，加入队列 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; xx;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else cout &lt;&lt; &quot; &quot; &lt;&lt; xx;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="产生冠军"><a href="#产生冠军" class="headerlink" title="产生冠军"></a>产生冠军</h1><p>Description:<br>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。<br><code>Input</code><br>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。<br><code>Output</code><br>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">Alice Bob</span><br><span class="line">Smith John</span><br><span class="line">Alice Smith</span><br><span class="line">5</span><br><span class="line">a c</span><br><span class="line">c d</span><br><span class="line">d e</span><br><span class="line">b e</span><br><span class="line">a d</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法</span><br><span class="line">//set方法 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">string s1, s2;</span><br><span class="line">set&lt;string&gt; all, loser;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">all.clear();</span><br><span class="line">loser.clear();</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">all.insert(s1);</span><br><span class="line">all.insert(s2);</span><br><span class="line">loser.insert(s2);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (all.size() - loser.size() == 1 ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二种：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e4 + 10;</span><br><span class="line">int in[maxx];</span><br><span class="line">//int edge[maxx][maxx];//用于构图但是这一题没有用到 </span><br><span class="line">bool slove(int n)</span><br><span class="line">&#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">sum ++;</span><br><span class="line">&#125;</span><br><span class="line">if(sum == 1) return true;</span><br><span class="line">return false;</span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">map&lt;string, int&gt; mp;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">//清空图 </span><br><span class="line">mp.clear();</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">//memset(edge, 0, sizeof edge);//没用到 </span><br><span class="line">string s1, s2;</span><br><span class="line">int t = 1; </span><br><span class="line">//存图</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">if(!mp[s1]) mp[s1] = t ++;</span><br><span class="line">if(!mp[s2]) mp[s2] = t ++;</span><br><span class="line">//edge[mp[s1]][mp[s2]] = 1;//没用到</span><br><span class="line">in[mp[s2]] ++; </span><br><span class="line">&#125;</span><br><span class="line">t --;</span><br><span class="line">if(slove(t)) puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三种：</span><br><span class="line">//map的另一种做法 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, cnt;</span><br><span class="line">map&lt;string, int&gt; mp;</span><br><span class="line">string winner, loser;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">mp.clear();</span><br><span class="line">cnt = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; winner &gt;&gt; loser;</span><br><span class="line">if(mp.find(winner) == mp.end())</span><br><span class="line">mp[winner] = 1;</span><br><span class="line">mp[loser] = 0;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; :: iterator it;</span><br><span class="line">for(it = mp.begin(); it != mp.end(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">if(it -&gt; second)</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt == 1) puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Legal-or-Not"><a href="#Legal-or-Not" class="headerlink" title="Legal or Not"></a>Legal or Not</h1><p>Description:<br>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many “holy cows” like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost “master”, and Lost will have a nice “prentice”. By and by, there are many pairs of “master and prentice”. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?</p><p>We all know a master can have many prentices and a prentice may have a lot of masters too, it’s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian’s master and, at the same time, 3xian is HH’s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not.</p><p>Please note that the “master and prentice” relation is transitive. It means that if A is B’s master ans B is C’s master, then A is C’s master.<br><code>Input</code><br>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y’s master and y is x’s prentice. The input is terminated by N = 0.<br>TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,…, N-1). We use their numbers instead of their names.<br><code>Output</code><br>For each test case, print in one line the judgement of the messy relationship.<br>If it is legal, output “YES”, otherwise “NO”.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 2</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int flag = 1, cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">n --;</span><br><span class="line">if(cnt &gt;= n) continue;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n) puts(&quot;NO&quot;);</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Reward"><a href="#Reward" class="headerlink" title="Reward"></a>Reward</h1><p>Description:<br>Dandelion’s uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.<br>The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a’s reward should more than b’s.Dandelion’s unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work’s reward will be at least 888 , because it’s a lucky number.<br><code>Input</code><br>One line with two integers n and m ,stands for the number of works and the number of demands .(n&lt;=10000,m&lt;=20000)<br>then m lines ,each line contains two integers a and b ,stands for a’s reward should be more than b’s.<br><code>Output</code><br>For every case ,print the least money dandelion ‘s uncle needs to distribute .If it’s impossible to fulfill all the works’ demands ,print -1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">Sample Output</span><br><span class="line">1777</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx], sum[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; y &gt;&gt; x;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int ans = 0, k = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">sum[i] = 888;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">k ++;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">sum[v[xx][i]] = sum[xx] + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">ans += sum[i];</span><br><span class="line">if(n != k) puts(&quot;-1&quot;);</span><br><span class="line">else cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ordering-Tasks"><a href="#Ordering-Tasks" class="headerlink" title="Ordering Tasks"></a>Ordering Tasks</h2><p>Description:<br>John has n tasks to do. Unfortunately, the tasks are not independent and the execution of one task is<br>only possible if other tasks have already been executed.<br>Input<br>The input will consist of several instances of the problem. Each instance begins with a line containing<br>two integers, 1 ≤ n ≤ 100 and m. n is the number of tasks (numbered from 1 to n) and m is the<br>number of direct precedence relations between tasks. After this, there will be m lines with two integers<br>i and j, representing the fact that task i must be executed before task j.<br>An instance with n = m = 0 will finish the input.<br>Output<br>For each instance, print a line with n integers representing the tasks in a possible order of execution.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">1 5</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">1 4 2 5 3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; xx;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; xx; </span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Rank-of-Tetris"><a href="#Rank-of-Tetris" class="headerlink" title="Rank of Tetris"></a>Rank of Tetris</h2><p>Description:<br>自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。</p><p>为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。</p><p>终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。<br>同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是”A &gt; B”,”A = B”,”A &lt; B”，分别表示A的Rating高于B,等于B,小于B。</p><p>现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出”OK”。否则就请你判断出错的原因，到底是因为信息不完全（输出”UNCERTAIN”），还是因为这些信息中包含冲突（输出”CONFLICT”）。<br>注意，如果信息中同时包含冲突且信息不完全，就输出”CONFLICT”。<br><code>Input</code><br>本题目包含多组测试，请处理到文件结束。<br>每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),分别表示要排名的人数以及得到的关系数。<br>接下来有M行，分别表示这些关系<br><code>Output</code><br>对于每组测试，在一行里按题目要求输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">0 &gt; 1</span><br><span class="line">1 &lt; 2</span><br><span class="line">0 &gt; 2</span><br><span class="line">4 4</span><br><span class="line">1 = 2</span><br><span class="line">1 &gt; 3</span><br><span class="line">2 &gt; 0</span><br><span class="line">0 &gt; 1</span><br><span class="line">3 3</span><br><span class="line">1 &gt; 0</span><br><span class="line">1 &gt; 2</span><br><span class="line">2 &lt; 1</span><br><span class="line">Sample Output</span><br><span class="line">OK</span><br><span class="line">CONFLICT</span><br><span class="line">UNCERTAIN</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node//边</span><br><span class="line">&#123;</span><br><span class="line">int a,b;//顶点</span><br><span class="line">char ch;//运算符</span><br><span class="line">&#125;c[10005];</span><br><span class="line">vector&lt;int&gt;map[10005];//map数组存贮邻接表</span><br><span class="line">int n,m,sum,in[10005],fa[10005];//in数组表示入度,fa[i]表示顶点i所在集合的根节点</span><br><span class="line">int find(int x)//查找根节点</span><br><span class="line">&#123;</span><br><span class="line">if(fa[x]!=x) fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">bool comb(int x,int y)//合并集合</span><br><span class="line">&#123;</span><br><span class="line">x=find(x);</span><br><span class="line">y=find(y);</span><br><span class="line">if(x==y)</span><br><span class="line">return false;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">fa[y]=x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">void top_sort()//queue实现拓扑排序</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt;s;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i]==0&amp;&amp;fa[i]==i)</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line">while(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">if(s.size()&gt;1)//即使发现信息不完整也要继续运行下去，因为如果信息同时不完整和冲突都是CONFLICT</span><br><span class="line">flag=1;</span><br><span class="line">int pos=s.front();</span><br><span class="line">s.pop(),sum--;</span><br><span class="line">for(int i=0;i&lt;map[pos].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">in[map[pos][i]]--;</span><br><span class="line">if(in[map[pos][i]]==0)</span><br><span class="line">s.push(map[pos][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(sum&gt;0) printf(&quot;CONFLICT\n&quot;);</span><br><span class="line">else if(flag) printf(&quot;UNCERTAIN\n&quot;);</span><br><span class="line">else printf(&quot;OK\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">sum=n;</span><br><span class="line">init();</span><br><span class="line">memset(map,0,sizeof(map));</span><br><span class="line">memset(in,0,sizeof(in));</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %c %d&quot;,&amp;c[i].a,&amp;c[i].ch,&amp;c[i].b);</span><br><span class="line">if(c[i].ch==&apos;=&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(comb(c[i].a,c[i].b))</span><br><span class="line">sum--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(c[i].ch==&apos;=&apos;)</span><br><span class="line">continue;</span><br><span class="line">int x=find(c[i].a);</span><br><span class="line">int y=find(c[i].b);</span><br><span class="line">if(c[i].ch==&apos;&gt;&apos;)</span><br><span class="line">&#123;</span><br><span class="line">map[x].push_back(y);</span><br><span class="line">in[y]++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">map[y].push_back(x);</span><br><span class="line">in[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top_sort();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day19&quot;&gt;&lt;a href=&quot;#Day19&quot; class=&quot;headerlink&quot; title=&quot;Day19&quot;&gt;&lt;/a&gt;Day19&lt;/h1&gt;&lt;p&gt;今天讲的是拓扑排序算法&lt;br&gt;努力学习！！&lt;br&gt;&lt;a href=&quot;https://vjudge.net/contest/317983#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day18</title>
    <link href="http://yoursite.com/2019/08/06/Day18/"/>
    <id>http://yoursite.com/2019/08/06/Day18/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-07T14:30:49.761Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day18"><a href="#Day18" class="headerlink" title="Day18"></a>Day18</h1><p>今天讲的是最短路算法<br><code>补题</code><br><a href="https://vjudge.net/contest/317592#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><blockquote><p>提醒自己一下，因为今天有事没有写完这些题目，所以大部分的题解和代码都是在网上找到的，希望以后自己可以把这部分题补上</p></blockquote><h2 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h2><p>详情链接-&gt;<a href="https://cdreamer.cn/2019/06/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" target="_blank" rel="noopener">传送</a></p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>Description:<br>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><p><code>Input</code><br>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。<br><code>Output</code><br>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2 1</span><br><span class="line">1 2 3</span><br><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int map[maxx][maxx];</span><br><span class="line">int dj(int x, int n)</span><br><span class="line">&#123;</span><br><span class="line">int p;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">dis[i] = map[1][i];</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">vis[x] = 1;</span><br><span class="line">for(int i = 1; i &lt;= n ; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int minn = INF;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">&#123;</span><br><span class="line">minn = dis[j];</span><br><span class="line">p = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[p] = 1;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[j] &amp;&amp; dis[p] + map[p][j] &lt; dis[j])</span><br><span class="line">dis[j] = dis[p] + map[p][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int a, b, c;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break; </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">if(map[a][b] &gt; c)</span><br><span class="line">map[a][b] = map[b][a] = c;</span><br><span class="line">&#125;</span><br><span class="line">dj(1, n);</span><br><span class="line">cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Frogger"><a href="#Frogger" class="headerlink" title="Frogger"></a>Frogger</h2><p>Description:<br>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.<br>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.<br>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.<br>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.</p><p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.<br><code>Input</code><br>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.<br><code>Output</code><br>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">17 4</span><br><span class="line">19 4</span><br><span class="line">18 5</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Scenario #1</span><br><span class="line">Frog Distance = 5.000</span><br><span class="line"></span><br><span class="line">Scenario #2</span><br><span class="line">Frog Distance = 1.414</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">//Floyd解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for(int k=1; k&lt;=n; k++)</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=min(map[i][j],max(map[i][k],map[k][j]));//许多通路中最长边中的最小边</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        floyd();</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,map[1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//dijkstra解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">double dis[maxnum];</span><br><span class="line">int vis[maxnum];</span><br><span class="line">void dj(int s)</span><br><span class="line">&#123;</span><br><span class="line">    mem(vis,0);</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;//这里最好别用memset</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minn=inf,k;</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            if(vis[j]==0&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                k=j;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        vis[k]=1;</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            dis[j]=min(dis[j],max(dis[k],map[k][j]));//dis[j]为从一号石头到第j号石头所有通路中最长边中的最小边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        dj(1);</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,dis[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//SPFA解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">double dis[maxnum];</span><br><span class="line">int vis[maxnum];</span><br><span class="line">void spfa()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    dis[1]=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        vis[i]=0;</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int k=q.front();</span><br><span class="line">        vis[k]=0;</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            if(max(dis[k],map[k][j])&lt;dis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j]=max(dis[k],map[k][j]);</span><br><span class="line">                if(vis[j]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    vis[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        spfa();</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,dis[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Stockbroker-Grapevine"><a href="#Stockbroker-Grapevine" class="headerlink" title="Stockbroker Grapevine"></a>Stockbroker Grapevine</h2><p>Description:<br>Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way.</p><p>Unfortunately for you, stockbrokers only trust information coming from their “Trusted sources” This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.<br><code>Input</code><br>Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a ‘1’ means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules.</p><p>Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people.</p><p><code>Output</code><br>For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.<br>It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message “disjoint”. Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">2 2 4 3 5</span><br><span class="line">2 1 2 3 6</span><br><span class="line">2 1 2 2 2</span><br><span class="line">5</span><br><span class="line">3 4 4 2 8 5 3</span><br><span class="line">1 5 8</span><br><span class="line">4 1 6 4 10 2 7 5 2</span><br><span class="line">0</span><br><span class="line">2 2 5 1 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3 2</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">经典水题floyd这道题重点在于找到从某一个源点出发的最短路</span><br><span class="line">怎么找？可以找到从一个源点出发最长的时间，即是传递结束，</span><br><span class="line">然后找最长的最短。当然会出现有些人没有传递到，但是这道</span><br><span class="line">题的bug在于此，不会出现disjoint的情况。</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define inf 20</span><br><span class="line">#define M 210</span><br><span class="line"> </span><br><span class="line">int dist[M][M];</span><br><span class="line">int n;</span><br><span class="line"> </span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for(int k = 1;k &lt;= n; k++)</span><br><span class="line">        for(int i = 1;i &lt;= n; i++)</span><br><span class="line">            for(int j = 1;j &lt;= n; j++)</span><br><span class="line">                if(i != j &amp;&amp; dist[i][j] &gt; dist[i][k] + dist[k][j])</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line"> </span><br><span class="line">    int minlength = inf;</span><br><span class="line">    int maxlength,pos;</span><br><span class="line">    for(int i = 1;i &lt;= n; i++)&#123;</span><br><span class="line">        maxlength = 0;</span><br><span class="line">        for(int j = 1;j &lt;= n; j++)</span><br><span class="line">            if(i != j &amp;&amp; maxlength &lt; dist[i][j])</span><br><span class="line">                maxlength = dist[i][j];</span><br><span class="line">        if(minlength &gt; maxlength)&#123;</span><br><span class="line">            minlength = maxlength;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;minlength&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        memset(dist,inf,sizeof(dist));</span><br><span class="line"> </span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line"> </span><br><span class="line">        if(!n)</span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        for(int i = 1;i &lt;= n; i++)&#123;</span><br><span class="line">            int n1;</span><br><span class="line">            cin&gt;&gt;n1;</span><br><span class="line">            for(int j = 1;j &lt;= n1; j++)&#123;</span><br><span class="line">                int p,t;</span><br><span class="line">                cin&gt;&gt;p&gt;&gt;t;</span><br><span class="line">                dist[i][p] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Invitation-Cards"><a href="#Invitation-Cards" class="headerlink" title="Invitation Cards"></a>Invitation Cards</h2><p>Description:<br>In the age of television, not many people attend theater performances. Antique Comedians of Malidinesia are aware of this fact. They want to propagate theater and, most of all, Antique Comedies. They have printed invitation cards with all the necessary information and with the programme. A lot of students were hired to distribute these invitations among the people. Each student volunteer has assigned exactly one bus stop and he or she stays there the whole day and gives invitation to people travelling by bus. A special course was taken where students learned how to influence people and what is the difference between influencing and robbery.</p><p>The transport system is very special: all lines are unidirectional and connect exactly two stops. Buses leave the originating stop with passangers each half an hour. After reaching the destination stop they return empty to the originating stop, where they wait until the next full half an hour, e.g. X:00 or X:30, where ‘X’ denotes the hour. The fee for transport between two stops is given by special tables and is payable on the spot. The lines are planned in such a way, that each round trip (i.e. a journey starting and finishing at the same stop) passes through a Central Checkpoint Stop (CCS) where each passenger has to pass a thorough check including body scan.</p><p>All the ACM student members leave the CCS each morning. Each volunteer is to move to one predetermined stop to invite passengers. There are as many volunteers as stops. At the end of the day, all students travel back to CCS. You are to write a computer program that helps ACM to minimize the amount of money to pay every day for the transport of their employees.<br><code>Input</code><br>The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case begins with a line containing exactly two integers P and Q, 1 &lt;= P,Q &lt;= 1000000. P is the number of stops including CCS and Q the number of bus lines. Then there are Q lines, each describing one bus line. Each of the lines contains exactly three numbers - the originating stop, the destination stop and the price. The CCS is designated by number 1. Prices are positive integers the sum of which is smaller than 1000000000. You can also assume it is always possible to get from any stop to any other stop.<br><code>Output</code><br>For each case, print one line containing the minimum amount of money to be paid each day by ACM for the travel costs of its volunteers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 2 13</span><br><span class="line">2 1 33</span><br><span class="line">4 6</span><br><span class="line">1 2 10</span><br><span class="line">2 1 60</span><br><span class="line">1 3 20</span><br><span class="line">3 4 10</span><br><span class="line">2 4 5</span><br><span class="line">4 1 50</span><br><span class="line">Sample Output</span><br><span class="line">46</span><br><span class="line">210</span><br></pre></td></tr></table></figure><p><code>题意</code><br>求1到各个顶点和各个定点到1的路线总长最短。有向图。<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//各个点到1顶点的总和最短可以反向建图来实现。而不是反复最短路</span><br><span class="line">//因为有1000000的顶点所以采用了邻接表。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1000000+100;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int b[N],w[N],e[N];</span><br><span class="line">int fir[N],nxt[N];</span><br><span class="line">int n,m;</span><br><span class="line">int dis[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void  spfa(int &amp;ans)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=i==1?0:inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[1]=0;vis[1]=1;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int now=q.front();</span><br><span class="line">        int k=fir[now];</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now]=0;</span><br><span class="line">        while(k!=-1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(dis[e[k]]&gt;dis[b[k]]+w[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[e[k]]=dis[b[k]]+w[k];</span><br><span class="line">                if(!vis[e[k]]) q.push(e[k]),vis[e[k]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            k=nxt[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fir[i]=-1;</span><br><span class="line">            nxt[i]=-1;</span><br><span class="line">            dis[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;b[i],&amp;e[i],&amp;w[i]);</span><br><span class="line">            nxt[i]=fir[b[i]];</span><br><span class="line">            fir[b[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(ans);</span><br><span class="line">        memset(nxt,-1,sizeof nxt);</span><br><span class="line">        memset(fir,-1,sizeof fir);</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int t=b[i];</span><br><span class="line">            b[i]=e[i];</span><br><span class="line">            e[i]=t;</span><br><span class="line">            nxt[i]=fir[b[i]];</span><br><span class="line">            fir[b[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(ans);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Skiing"><a href="#Skiing" class="headerlink" title="Skiing"></a>Skiing</h2><p>Description:<br>Bessie and the rest of Farmer John’s cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 &lt;= R &lt;= 100) by C (1 &lt;= C &lt;= 100) grid of elevations E (-25 &lt;= E &lt;= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.</p><p>Bessie starts out travelling at a initial speed V (1 &lt;= V &lt;= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.</p><p>Find the both smallest amount of time it will take Bessie to join her cow friends.<br><code>Input</code></p><ul><li><p>Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie’s initial velocity and the number of rows and columns in the grid.</p></li><li><p>Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid.<br><code>Output</code><br>A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 3 3</span><br><span class="line">1 5 3</span><br><span class="line">6 3 5</span><br><span class="line">2 4 3</span><br><span class="line">Sample Output</span><br><span class="line">29.00</span><br><span class="line">Hint</span><br><span class="line">Bessie&apos;s best route is: </span><br><span class="line">Start at 1,1 time 0 speed 1 </span><br><span class="line">East to 1,2 time 1 speed 1/16 </span><br><span class="line">South to 2,2 time 17 speed 1/4 </span><br><span class="line">South to 3,2 time 21 speed 1/8 </span><br><span class="line">East to 3,3 time 29 speed 1/4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">//dijkstra解法</span><br><span class="line">/*dijkstra解法题解：每个节点的耗时就是从左上角（1，1）点到（i,j)点的2^高度差,而速度是其倒数，需输出的啦~，先把节点存储成耗时的静态邻接表，然后利用dijkstra的堆优化进行（nlogn)的求解。*/</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define maxn 111</span><br><span class="line">#define inf 999999999999</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">struct node&#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">double dis;</span><br><span class="line">bool operator &lt; (const node &amp;a) const&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int dic[4][2]=&#123;0,1,1,0,-1,0,0,-1&#125;;</span><br><span class="line">int at[maxn][maxn];</span><br><span class="line">double mp[maxn][maxn];</span><br><span class="line">double dis[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int v,r,c;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">dis[i][j]=inf;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">double get_cost(int h)</span><br><span class="line">&#123;</span><br><span class="line">return v*1.0*pow(2*1.0,at[1][1]-h);</span><br><span class="line">&#125;</span><br><span class="line">bool ok(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;0&amp;&amp;x&lt;=r&amp;&amp;y&gt;0&amp;&amp;y&lt;=c)</span><br><span class="line">return true;</span><br><span class="line">else </span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node now,next;</span><br><span class="line">now.x=1;</span><br><span class="line">now.y=1;</span><br><span class="line">now.dis=0;</span><br><span class="line">dis[1][1]=0;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(vis[now.x][now.y]) continue;</span><br><span class="line">vis[now.x][now.y]=true;</span><br><span class="line">if(now.x==r&amp;&amp;now.y==c)</span><br><span class="line">break;</span><br><span class="line">int x;int y;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=now.x+dic[i][0];</span><br><span class="line">y=now.y+dic[i][1];</span><br><span class="line">if(!ok(x,y)) continue;</span><br><span class="line">if(!vis[x][y]&amp;&amp;dis[x][y]&gt;now.dis+1.0/mp[now.x][now.y])</span><br><span class="line">&#123;</span><br><span class="line">dis[x][y]=now.dis+1.0/mp[now.x][now.y];</span><br><span class="line">next.x=x;</span><br><span class="line">next.y=y;</span><br><span class="line">next.dis=dis[x][y];</span><br><span class="line">q.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;v,&amp;r,&amp;c);</span><br><span class="line">init();</span><br><span class="line">//printf(&quot;%lf\n&quot;,dis[1][1]);</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;at[i][j]);</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">mp[i][j]=get_cost(at[i][j]);</span><br><span class="line">dijkstra();</span><br><span class="line">printf(&quot;%.2f\n&quot;,dis[r][c]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SPFA解法</span><br><span class="line">/*题解：可以看出每个点的速度都与第一个点有关，因为V*2^(A-B)*2^(B-C)它就等于V*2^(A-C)，所以每个点的速度都可以用第一个点算出来。然后把每个点对应到下一个点的时间存到这个点的位置上。*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cfloat&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double inf = 0x3f3f3f3f;</span><br><span class="line">const int MAX = 200;</span><br><span class="line">int v,r,c;</span><br><span class="line">int vis[MAX][MAX];</span><br><span class="line">double mp[MAX][MAX],t[MAX][MAX],dis[MAX][MAX];// mp要用double 待会用到pow函数要不然报错</span><br><span class="line">int mv[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">struct hh&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">void spfa()&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=1;i&lt;=r;i++)&#123;// 赋一个很大的值给double类型的数组，要用这种形式，要不然用下面那种形式，不对。</span><br><span class="line">for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">dis[i][j] = DBL_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//memset(dis,inf,sizeof(dis));</span><br><span class="line">queue&lt;hh&gt; q;</span><br><span class="line">hh tmp,nex;</span><br><span class="line">int xx,yy;</span><br><span class="line">tmp.x=1;</span><br><span class="line">tmp.y=1;</span><br><span class="line">dis[1][1]=0;//注意赋值为0，dis数组表示别的点到这个点需要的时间，不包括这个点到别的点的时间，也就是不包括这个点所存的时间</span><br><span class="line">q.push(tmp);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">tmp=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[tmp.x][tmp.y]=0;// 注意要赋值0，要不然会错，因为这个点我们可能需要重新走</span><br><span class="line">for (int i = 0; i &lt; 4;i++)&#123;</span><br><span class="line">xx=tmp.x+mv[i][0];</span><br><span class="line">yy=tmp.y+mv[i][1];</span><br><span class="line">if(xx&lt;1|yy&lt;1||xx&gt;r||yy&gt;c) continue;</span><br><span class="line">if(dis[xx][yy]&gt;t[tmp.x][tmp.y]+dis[tmp.x][tmp.y])&#123;</span><br><span class="line">dis[xx][yy]=t[tmp.x][tmp.y]+dis[tmp.x][tmp.y];</span><br><span class="line">if(!vis[xx][yy])&#123;</span><br><span class="line">vis[xx][yy]=1;</span><br><span class="line">nex.x=xx;</span><br><span class="line">nex.y=yy;</span><br><span class="line">q.push(nex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; r &gt;&gt; c;</span><br><span class="line">for (int i = 1; i &lt;= r;i++)&#123;</span><br><span class="line">for (int j = 1; j &lt;= c;j++)&#123;</span><br><span class="line">cin &gt;&gt; mp[i][j];</span><br><span class="line">t[i][j]=1/(v*(pow(2,mp[1][1]-mp[i][j])));//计算每个点到下一个点所需要的时间，存到这个点上</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">spfa();</span><br><span class="line">printf(&quot;%.2lf\n&quot;,dis[r][c]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cow-Hurdles"><a href="#Cow-Hurdles" class="headerlink" title="Cow Hurdles"></a>Cow Hurdles</h2><p>Description:<br>Farmer John wants the cows to prepare for the county jumping competition, so Bessie and the gang are practicing jumping over hurdles. They are getting tired, though, so they want to be able to use as little energy as possible to jump over the hurdles.</p><p>Obviously, it is not very difficult for a cow to jump over several very short hurdles, but one tall hurdle can be very stressful. Thus, the cows are only concerned about the height of the tallest hurdle they have to jump over.</p><p>The cows’ practice room has N (1 ≤ N ≤ 300) stations, conveniently labeled 1..N. A set of M (1 ≤ M ≤ 25,000) one-way paths connects pairs of stations; the paths are also conveniently labeled 1..M. Path i travels from station Si to station Ei and contains exactly one hurdle of height Hi (1 ≤ Hi ≤ 1,000,000). Cows must jump hurdles in any path they traverse.</p><p>The cows have T (1 ≤ T ≤ 40,000) tasks to complete. Task i comprises two distinct numbers, Ai and Bi (1 ≤ Ai ≤ N; 1 ≤ Bi ≤ N), which connote that a cow has to travel from station Ai to station Bi (by traversing over one or more paths over some route). The cows want to take a path the minimizes the height of the tallest hurdle they jump over when traveling from Ai to Bi . Your job is to write a program that determines the path whose tallest hurdle is smallest and report that height.</p><p><code>Input</code></p><ul><li>Line 1: Three space-separated integers: N, M, and T</li><li>Lines 2..M+1: Line i+1 contains three space-separated integers: Si , Ei , and Hi</li><li>Lines M+2..M+T+1: Line i+M+1 contains two space-separated integers that describe task i: Ai and Bi</li></ul><p><code>Output</code></p><ul><li>Lines 1..T: Line i contains the result for task i and tells the smallest possible maximum height necessary to travel between the stations. Output -1 if it is impossible to travel between the two stations.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ample Input</span><br><span class="line">5 6 3</span><br><span class="line">1 2 12</span><br><span class="line">3 2 8</span><br><span class="line">1 3 5</span><br><span class="line">2 5 3</span><br><span class="line">3 4 4</span><br><span class="line">2 4 8</span><br><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">5 1</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><blockquote><p>题意：有一头牛，要进行跳木桩训练，已知有n个木桩，而且知道m对木桩之间的高度差。但是它很懒，它想尽可能的跳最小的高度就完成从任意一个木桩到任意一个木桩的跳跃，给m对点，问是否存在最小的跳跃高度使得其能够完成跳跃，如果有就输出最小高度；否则输出-1。</p></blockquote><blockquote><p>解析：对于每一次询问，求的是每条路径上边权值的最大值（该路径所经过的相邻两木桩之间的差值的最大值），然后取其中的最小值即可。因为只要能跳过这个高度差最大的，高度差小的当然能跳过去了。由于是求任意两木桩之间的所有路径上最大高度差值的最小值，所以我们可以用Floyd算法，对其进行处理，处理之后得到的最终结果即为所求了。</p></blockquote><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 123456789</span><br><span class="line">int a[302][302];        //最大高度的最小值矩阵</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, t;</span><br><span class="line">    int x, y, w;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t)!=EOF)&#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)                 //初始化</span><br><span class="line">            for(int j=1; j&lt;=n; j++) a[i][j] = i==j ? 0 : INF;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)&#123;                //读入高度差</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            a[x][y] = min(a[x][y], w);          //更新最大高度差</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k=1; k&lt;=n; k++)                 //Floyd</span><br><span class="line">            for(int i=1; i&lt;=n; i++)</span><br><span class="line">                for(int j=1; j&lt;=n; j++)&#123;</span><br><span class="line">                    a[i][j] = min(a[i][j], max(a[i][k], a[k][j]));      </span><br><span class="line">                &#125;</span><br><span class="line">        for(int i=1; i&lt;=t; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">            printf(&quot;%d\n&quot;, a[x][y]==INF ? -1 : a[x][y]);       //输出，如果还是INF，那就代表不可达，两者时之间没有路径满足要求</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day18&quot;&gt;&lt;a href=&quot;#Day18&quot; class=&quot;headerlink&quot; title=&quot;Day18&quot;&gt;&lt;/a&gt;Day18&lt;/h1&gt;&lt;p&gt;今天讲的是最短路算法&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://vjudge.net/contest/317592#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day17</title>
    <link href="http://yoursite.com/2019/08/05/Day17/"/>
    <id>http://yoursite.com/2019/08/05/Day17/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-05T14:17:27.973Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day17"><a href="#Day17" class="headerlink" title="Day17"></a>Day17</h1><p>今天讲的是并查集和最小生成树<br><a href="https://vjudge.net/contest/317297#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="并查集-最小生成树"><a href="#并查集-最小生成树" class="headerlink" title="并查集+最小生成树"></a>并查集+最小生成树</h2><p>具体内容点这里-&gt;<a href="https://cdreamer.cn/2019/06/02/%E5%B9%B6%E6%9F%A5%E9%9B%86+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" target="_blank" rel="noopener">链接</a></p><h2 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h2><p>Description:<br>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.<br><code>Input</code><br>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.<br><code>Output</code><br>For each case, output the number of suspects in one line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int sum;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">//路径压缩算法</span><br><span class="line">int i = x, j;</span><br><span class="line">while(pre[i] != r)</span><br><span class="line">&#123;</span><br><span class="line">j = pre[r];</span><br><span class="line">pre[i] = r;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, k;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">for(int i = 0; i &lt; n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">int num1, num;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;num1);</span><br><span class="line">k --;</span><br><span class="line">while(k --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">join(num1, num);</span><br><span class="line">num1 = num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">if(find(i) == pre[0]) sum ++;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h2><p>Description:<br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br><code>Input</code><br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。<br><code>Output</code><br>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br><span class="line"></span><br><span class="line">Huge input, scanf is recommended.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int x, y;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">join(x, y);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(pre[i] == i)</span><br><span class="line">ans ++; </span><br><span class="line">cout &lt;&lt; ans - 1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="还是畅通工程"><a href="#还是畅通工程" class="headerlink" title="还是畅通工程"></a>还是畅通工程</h2><p>Description:<br>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br><code>Input</code><br>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。<br><code>Output</code><br>对每个测试用例，在1行里输出最小的公路总长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">1 4 1</span><br><span class="line">2 3 3</span><br><span class="line">2 4 2</span><br><span class="line">3 4 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">Huge input, scanf is recommended.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int t;</span><br><span class="line">struct node&#123;</span><br><span class="line">int s, e, w;</span><br><span class="line">&#125;e_e[maxx];</span><br><span class="line">int cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">int kru()</span><br><span class="line">&#123;</span><br><span class="line">int len = t * (t - 1) / 2;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">pre[i] = i;</span><br><span class="line">sort(e_e + 1, e_e + len + 1, cmp);</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(e_e[i].s);</span><br><span class="line">int yy = find(e_e[i].e);</span><br><span class="line">if(xx != yy)</span><br><span class="line">&#123;</span><br><span class="line">ans += e_e[i].w;</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line">if(t == 0) break;</span><br><span class="line">int len = t * (t - 1) / 2;</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d %d&quot;,&amp;e_e[i].s, &amp;e_e[i].e, &amp;e_e[i].w);</span><br><span class="line">&#125;</span><br><span class="line">int ans = kru();</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ubiquitous-Religions"><a href="#Ubiquitous-Religions" class="headerlink" title="Ubiquitous Religions"></a>Ubiquitous Religions</h2><p>Description:<br>There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.</p><p>You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.<br><code>Input</code><br>The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.<br><code>Output</code><br>For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">1 6</span><br><span class="line">1 7</span><br><span class="line">1 8</span><br><span class="line">1 9</span><br><span class="line">1 10</span><br><span class="line">10 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 8</span><br><span class="line">5 8</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 1</span><br><span class="line">Case 2: 7</span><br><span class="line">Hint</span><br><span class="line">Huge input, scanf is recommended.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int x, y;</span><br><span class="line">int k = 1;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">join(y, x);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(pre[i] == i)</span><br><span class="line">ans ++; </span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,k ++, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cube-Stacking"><a href="#Cube-Stacking" class="headerlink" title="Cube Stacking"></a>Cube Stacking</h2><p>Description:<br>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.</p><ul><li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.</li><li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</li></ul><p>Write a program that can verify the results of the game.<br><code>Input</code></p><ul><li><p>Line 1: A single integer, P</p></li><li><p>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.</p></li></ul><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.<br><code>Output</code><br>Print the output from each of the count operations in the same order as the input file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx], dis[maxx], cnt[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(pre[x] != x)</span><br><span class="line">&#123;</span><br><span class="line">int tmp = pre[x];</span><br><span class="line">pre[x] = find(pre[x]);</span><br><span class="line">dis[x] += dis[tmp];</span><br><span class="line">&#125;</span><br><span class="line">return pre[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">pre[x] = y;</span><br><span class="line">dis[x] += cnt[y];</span><br><span class="line">cnt[y] += cnt[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i = 0; i &lt; 31000; i ++)</span><br><span class="line">&#123;</span><br><span class="line">pre[i] = i;</span><br><span class="line">cnt[i] = 1;</span><br><span class="line">dis[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">int a, b;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">if(ch == &apos;M&apos;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a, &amp;b);</span><br><span class="line">if(find(a) != find(b))</span><br><span class="line">join(find(a), find(b));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">find(x);</span><br><span class="line">printf(&quot;%d\n&quot;,dis[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Dragon-Balls"><a href="#Dragon-Balls" class="headerlink" title="Dragon Balls"></a>Dragon Balls</h2><p>Description:<br>Five hundred years later, the number of dragon balls will increase unexpectedly, so it’s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.<br>His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities’ dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.<br>Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far.<br><code>Input</code><br>The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).<br>For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).<br>Each of the following Q lines contains either a fact or a question as the follow format:<br>T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different.<br>Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N)<br><code>Output</code><br>For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space.</p><p><code>题目大意</code>：<br>有标号为1到n的n个龙珠，分别放在对应标号为1到n的n个城市里。<br>下面有两种操作:<br>T A B表示把A龙珠所在城市的所有龙珠都转移到B龙珠所在的城市中<br>Q A 表示查询A，需要知道A龙珠现在所在的城市，A所在的城市有几颗龙珠，A转移到这个城市移动了多少次,分别输出3个整数，表示上述信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">T 1 2</span><br><span class="line">T 3 2</span><br><span class="line">Q 2</span><br><span class="line">3 4</span><br><span class="line">T 1 2</span><br><span class="line">Q 1</span><br><span class="line">T 1 3</span><br><span class="line">Q 1</span><br><span class="line">Sample Output</span><br><span class="line">Case 1:</span><br><span class="line">2 3 0</span><br><span class="line">Case 2:</span><br><span class="line">2 2 1</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><blockquote><p>没写出来，先看着别人的代码和详解吧<br>code:<br><a href="https://blog.csdn.net/CSDN___CSDN/article/details/89424711" target="_blank" rel="noopener">详细链接</a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 10005;</span><br><span class="line"> </span><br><span class="line">int pre[maxn];//pre[i]表示第i个球所在的城市</span><br><span class="line">int sum[maxn];//sum[i]表示第i个城市所拥有的球的个数</span><br><span class="line">int cnt[maxn];//cnt[i]表示第i个球移动了几次</span><br><span class="line">int n,m,root;</span><br><span class="line">char str[3];</span><br><span class="line">//初始化，每一个球原来都呆在自己的城市，所以每一个城市里都只有1个球，每一个球的移动次数都是0。</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line">pre[i] = i;</span><br><span class="line">sum[i] = 1;</span><br><span class="line">cnt[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x==pre[x])</span><br><span class="line">return x;</span><br><span class="line">int fx = find(pre[x]);</span><br><span class="line">cnt[x] += cnt[pre[x]];</span><br><span class="line">pre[x] = fx;</span><br><span class="line">return fx;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int fx = find(x);</span><br><span class="line">int fy = find(y);</span><br><span class="line">if(fy==fx)</span><br><span class="line">return ;</span><br><span class="line">pre[fx] = fy;</span><br><span class="line">sum[fy] += sum[fx];</span><br><span class="line">sum[fx] = 0;</span><br><span class="line">cnt[fx] = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">int T,k=1,i;</span><br><span class="line">int x,y,a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">printf(&quot;Case %d:\n&quot;,k++);</span><br><span class="line">init();</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">if(str[0]==&apos;T&apos;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">join(x,y);</span><br><span class="line">&#125;</span><br><span class="line">else if(str[0]==&apos;Q&apos;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">root = find(a);</span><br><span class="line">printf(&quot;%d %d %d\n&quot;,root,sum[root],cnt[a]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="Zjnu-Stadium"><a href="#Zjnu-Stadium" class="headerlink" title="Zjnu Stadium"></a>Zjnu Stadium</h2><p>Description:<br>In 12th Zhejiang College Students Games 2007, there was a new stadium built in Zhejiang Normal University. It was a modern stadium which could hold thousands of people. The audience Seats made a circle. The total number of columns were 300 numbered 1–300, counted clockwise, we assume the number of rows were infinite.<br>These days, Busoniya want to hold a large-scale theatrical performance in this stadium. There will be N people go there numbered 1–N. Busoniya has Reserved several seats. To make it funny, he makes M requests for these seats: A B X, which means people numbered B must seat clockwise X distance from people numbered A. For example: A is in column 4th and X is 2, then B must in column 6th (6=4+2).<br>Now your task is to judge weather the request is correct or not. The rule of your judgement is easy: when a new request has conflicts against the foregoing ones then we define it as incorrect, otherwise it is correct. Please find out all the incorrect requests and count them as R.<br><code>Input</code><br>There are many test cases:<br>For every case:<br>The first line has two integer N(1&lt;=N&lt;=50,000), M(0&lt;=M&lt;=100,000),separated by a space.<br>Then M lines follow, each line has 3 integer A(1&lt;=A&lt;=N), B(1&lt;=B&lt;=N), X(0&lt;=X&lt;300) (A!=B), separated by a space.</p><p><code>Output</code><br>For every case:<br>Output R, represents the number of incorrect request.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">10 10</span><br><span class="line">1 2 150</span><br><span class="line">3 4 200</span><br><span class="line">1 5 270</span><br><span class="line">2 6 200</span><br><span class="line">6 5 80</span><br><span class="line">4 7 150</span><br><span class="line">8 9 100</span><br><span class="line">4 8 50</span><br><span class="line">1 7 100</span><br><span class="line">9 2 100</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Hint:</span><br><span class="line">（PS： the 5th and 10th requests are incorrect）</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//题目大意：给你n个人，m个关系，关系表示b在距离a顺时针方向的X距离的地、询问有哪些信息需要改正（也就是错的）。</span><br><span class="line">/*其中A表示a的祖先，B表示b的祖先，suma表示a到A的权值 ，sumb表示b到B的权值，我们已知a，b间距离，那么x也是可求距离。</span><br><span class="line">那么如果两个节点已经连接了，那么如何判断这两个节点之间的距离确实是w呢？直接用sum【b】-sum【a】就能得到a，b之间真实距离，如果和w不等，那么说明这条边需要更改消息。</span><br><span class="line">也就是说output要加1了</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[1000010];</span><br><span class="line">int sum[1000010];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=f[x])</span><br><span class="line">    &#123;</span><br><span class="line">//pre是x的一个父节点。</span><br><span class="line">        int pre=f[x];</span><br><span class="line">//递归找祖先。</span><br><span class="line">        f[x]=find(f[x]);</span><br><span class="line">        sum[x]+=sum[pre];</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        int output=0;</span><br><span class="line">        for(int i=0; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=i;</span><br><span class="line">            sum[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x,y,w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            int xx=find(x);</span><br><span class="line">            int yy=find(y);</span><br><span class="line">            if(xx==yy)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sum[y]-sum[x]!=w)</span><br><span class="line">                &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                sum[yy]=w-sum[y]+sum[x];</span><br><span class="line">                f[yy]=xx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="How-Many-Tables"><a href="#How-Many-Tables" class="headerlink" title="How Many Tables"></a>How Many Tables</h2><p>Description:<br>Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.</p><p>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.</p><p>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.<br><code>Input</code><br>The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.<br><code>Output</code><br>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">5 1</span><br><span class="line">2 5</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, T;</span><br><span class="line">int x, y;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;m);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">join(x, y);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(pre[i] == i)</span><br><span class="line">ans ++; </span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day17&quot;&gt;&lt;a href=&quot;#Day17&quot; class=&quot;headerlink&quot; title=&quot;Day17&quot;&gt;&lt;/a&gt;Day17&lt;/h1&gt;&lt;p&gt;今天讲的是并查集和最小生成树&lt;br&gt;&lt;a href=&quot;https://vjudge.net/contest/317297#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day16</title>
    <link href="http://yoursite.com/2019/08/03/Day16/"/>
    <id>http://yoursite.com/2019/08/03/Day16/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-04T14:03:47.639Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --><h1 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h1><p>今天是一场积分赛，还行~~<br><a href="https://hpuoj.com/contest/25/" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="蚂蚁觅食（一）"><a href="#蚂蚁觅食（一）" class="headerlink" title="蚂蚁觅食（一）"></a>蚂蚁觅食（一）</h2><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的小蚂蚁发现了好多食物，但是它只有一次搬食物的机会。<br>可因为力气太小了，它不能搬走重量超过自己体重的食物,且只能搬走位置相邻的两个食物，或者只搬走其中一个。<br>食物的位置不会改变。<br>这可难住了这只蚂蚁，它不知道它最多能搬走多重的食物。请帮小蚂蚁计算。<br><code>输入格式</code><br>第一行一个正整数n，(n&gt;=0并且n&lt;=1000)</p><p>第二行n个正整数 A[1]…..A[n]，A[i] 表示在第i 个位置上食物的重量。A[i]&lt;=1e9.</p><p>第三行一个正整数m，表示蚂蚁的体重。(m&lt;=1e9).</p><p><code>输出格式</code><br>一个整数表示小蚂蚁能带走的食物的重量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">1 3 3</span><br><span class="line">4</span><br><span class="line">output</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int w[maxx], v[maxx], dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++) cin &gt;&gt; v[i];</span><br><span class="line">cin &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= v[i]; j --)</span><br><span class="line">dp[j] = max(dp[j], dp[j - v[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[V] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁觅食（二）"><a href="#蚂蚁觅食（二）" class="headerlink" title="蚂蚁觅食（二）"></a>蚂蚁觅食（二）</h2><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的的小蚂蚁发现了好多食物。<br>但是这些食物位于一个N∗M的方格魔法阵的右下角，而小蚂蚁位于方格法阵的左上角。<br>并且小蚂蚁被施展了魔法，它只能向下或者向右走。<br>请你帮助小蚂蚁计算一下，它一共有多少条路可以走到有食物的方格。</p><p><code>输入格式</code><br>多组输入，</p><p>每一组两个正整数N， M （N,M≤30）。表示一个方格魔法阵。</p><p><code>输出格式</code><br>一个整数表示一共有多少条路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2 3</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//dfs般写法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">ll dp[50][50];</span><br><span class="line">int d[2][2] = &#123;0, 1, 1, 0&#125;;</span><br><span class="line">ll dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[x][y]) return dp[x][y];</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = x + d[i][0];</span><br><span class="line">int yy = y + d[i][1];</span><br><span class="line">if(xx &gt;= 1 &amp;&amp; yy &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m)</span><br><span class="line">dp[x][y] += dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">dp[n][m] = 1;</span><br><span class="line">cout &lt;&lt; dfs(1, 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//dp般写法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">ll dp[1234][1234];</span><br><span class="line">ll n, m;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt; 1009; i ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][1] = 1;</span><br><span class="line">dp[1][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">while(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 2; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 2; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁觅食（三）"><a href="#蚂蚁觅食（三）" class="headerlink" title="蚂蚁觅食（三）"></a>蚂蚁觅食（三）</h2><p>Description:<br>马上就要冬天了，勤劳的小蚂蚁需要储存足够多的食物才能安全过冬。<br>今天，这只小蚂蚁走出巢穴寻找食物，但是这次蚁巢周围只有很少的食物，它需要去别的地方。<br>不幸的是小蚂蚁的体力很有限，而且每走一个单位长度就要消耗一点体力，不能找的时间太久，所以想让你帮忙计算一下它是否能用剩下的体力把足够多的食物搬回蚁巢。<br>由于蚂蚁的嘴太小，每次最多只能衔起一个食物。</p><p>输入格式<br>输入t组, t≤20<br>第一行三个数n,E,V表示食物的个数，蚂蚁剩余的体力，安全过冬需要的最少食物体积, 0&lt;n≤200,0&lt;E,V≤10000。<br>接下来n行，每行两个数pi,vi,表示第i个食物的位置和体积,0&lt;p[i],v[i]≤1000。<br>初始蚂蚁和蚁巢均在坐标轴原点。</p><p>输出格式<br>每个输出占一行。<br>如果蚂蚁能安全过冬，输出 “YES”,否则输出”NO”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">1 2 2</span><br><span class="line">1 2</span><br><span class="line">1 2 2</span><br><span class="line">2 1</span><br><span class="line">output</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int w[maxx], v[maxx], dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, E, V;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; E &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = E / 2; j &gt;= w[i]; j --)</span><br><span class="line">dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">if(dp[E / 2] &gt;= V) puts(&quot;YES&quot;);</span><br><span class="line">else puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>##<br>Description:<br>平面上有 n只蚂蚁，它走过的路径可以看作一条直线</p><p>由这n 条直线定义的某些区域是无界的，而另一些区域则是有界的。</p><p>有界区域的最大个数是多少？</p><p>比如现在有4条直线，只有下面最左边的图中直线定义的有界区域是最多的<br><img src="https://i.loli.net/2019/08/04/nNgw1ZJHtWMsipD.png" alt="jay.VpPvtTX2.png"><br><code>输入格式</code><br>T 组输入, (1≤T≤100)</p><p>每组一个数 n ，(1≤n≤109)</p><p><code>输出格式</code><br>对于每组数据，输出一个整数表示有界区域的最大个数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">ll n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">ll ans = 0;</span><br><span class="line">if(n &lt; 3) ans = 0;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">ans = (n - 1) * (n - 2) / 2;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁和斐波那契"><a href="#蚂蚁和斐波那契" class="headerlink" title="蚂蚁和斐波那契"></a>蚂蚁和斐波那契</h2><p>Description:<br>聪明的小蚂蚁最近学习了斐波那契数列,但是它想到了一个问题：<br>从L到R之间斐波那契数列和的奇偶是什么呢？<br>其中Fib[1]=1,Fib[2]=1 .</p><p><code>输入格式</code><br>单组输入:<br>每组输入两个以空格隔开的数字 L 和 R<br>其中 (0&lt;L&lt;=R&lt;1018)</p><p><code>输出格式</code><br>从 L 到 R 斐波那契数列和的奇偶，如果是奇数输出 “1” (不带引号) ，否则输出 “0” (不带引号)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">1 2</span><br><span class="line">output</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[55];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll mid,miid,l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">mid=l%3,miid=r%3;</span><br><span class="line">if(mid==0&amp;&amp;miid==0)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==miid)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==0&amp;&amp;miid==1)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==0&amp;&amp;miid==2)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==1&amp;&amp;miid==0)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==2&amp;&amp;miid==0)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==2&amp;&amp;miid==1)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==1&amp;&amp;miid==2)puts(&quot;0&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁装修"><a href="#蚂蚁装修" class="headerlink" title="蚂蚁装修"></a>蚂蚁装修</h2><p>Description:<br>还有一个月就开学了，爱学习的小蚂蚁想庆祝一下！于是它要把它的“家”装修一下。<br>首先要做的就是贴地板。<br>小蚂蚁“家”的地面可以看成一个2∗N 的方格 ，它拥有无数块1∗2 和 2∗1的地板。<br>请你帮下蚂蚁计算一下一共有多少种方法能把地面给放满 。<br>地板不能切割，也不能重叠。</p><p><code>输入格式</code><br>单组输入：<br>只有一个数字 N<br>其中 (0&lt;N&lt;1018)</p><p><code>输出格式</code><br>输出放法数对109+7取模的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">output</span><br><span class="line">2</span><br><span class="line">input</span><br><span class="line">1</span><br><span class="line">output</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">const int maxx = 4;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll m[maxx][maxx];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m, 0, sizeof ans.m);</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 2; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; 2; k ++)</span><br><span class="line">ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node kpow(node a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.m, 0, sizeof res.m);</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">res.m[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">node a, b, ans;</span><br><span class="line">a.m[0][0] = 2; a.m[0][1] = 0;</span><br><span class="line">a.m[1][0] = 1; a.m[1][1] = 0;</span><br><span class="line">b.m[0][0] = 1; b.m[0][1] = 1;</span><br><span class="line">b.m[1][0] = 1; b.m[1][1] = 0;</span><br><span class="line">if(n == 1) ans.m[0][0] = 1;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">ans = kpow(b, n - 2);</span><br><span class="line">ans = mul(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans.m[0][0] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁的镜像串"><a href="#蚂蚁的镜像串" class="headerlink" title="蚂蚁的镜像串"></a>蚂蚁的镜像串</h2><p>Description:<br>一只聪明的蚂蚁在学习了回文串之后，一直觉得回文串不够优美，所以它决定自己定义一种新的字符串——镜像串</p><p>所谓镜像串，就是对一个字符串进行一整个完全的翻转后，得到的新字符串与原字符串相同，也就是说左右镜像之后的字符串和原串相同。例如：AA就是一个镜像串,bb不是镜像串</p><p>现在给你一个字符串S，请你快速的判断字符串S是不是一个镜像串</p><p>字符串中出现的字母字体如下表</p><p><code>输入格式</code><br>第一行一个整数T (1≤T≤100)代表有T组输入</p><p>接下来T行，每行输入一个长度小于等于105的字符串S<br>保证每个字符串只包含大小写字母</p><p><code>输出格式</code><br>对于每组输入，判断S是否为镜像串</p><p>如果是，输出”YES”。否则输出”NO”。</p><p>每组输出占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">5</span><br><span class="line">QAQ</span><br><span class="line">TAT</span><br><span class="line">oUo</span><br><span class="line">oVo</span><br><span class="line">XoX</span><br><span class="line">output</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">提示</span><br><span class="line">mm,nn,uu也是镜像串</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int flag=1;</span><br><span class="line"> string mid=s;</span><br><span class="line"> reverse(mid.begin(),mid.end());</span><br><span class="line">for(int i=0;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if((s[i]==&apos;b&apos;&amp;&amp;mid[i]==&apos;d&apos;)||(s[i]==&apos;d&apos;&amp;&amp;mid[i]==&apos;b&apos;)||(s[i]==&apos;p&apos;&amp;&amp;mid[i]==&apos;q&apos;)||(s[i]==&apos;q&apos;&amp;&amp;mid[i]==&apos;p&apos;)||(s[i]==mid[i]&amp;&amp;(s[i]==&apos;A&apos;||s[i]==&apos;H&apos;||s[i]==&apos;I&apos;||s[i]==&apos;i&apos;||s[i]==&apos;l&apos;||s[i]==&apos;M&apos;||s[i]==&apos;m&apos;||s[i]==&apos;n&apos;||s[i]==&apos;O&apos;||s[i]==&apos;o&apos;||s[i]==&apos;T&apos;||s[i]==&apos;U&apos;||s[i]==&apos;u&apos;||s[i]==&apos;V&apos;||s[i]==&apos;v&apos;||s[i]==&apos;W&apos;||s[i]==&apos;w&apos;||s[i]==&apos;X&apos;||s[i]==&apos;x&apos;||s[i]==&apos;Y&apos;)))</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag==1)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁赛跑"><a href="#蚂蚁赛跑" class="headerlink" title="蚂蚁赛跑"></a>蚂蚁赛跑</h2><p>Description:<br>小白和小黑非常喜欢养蚂蚁，他们每个人都养了n只蚂蚁。<br>有一天，他们想比一比谁养蚂蚁的本领更强，于是就举办了一场蚂蚁赛跑比赛。假设蚂蚁都是匀速直线奔跑。<br>比赛的规则是这样的：每只蚂蚁必须且最多比一场，赢一场得10分，输一场扣10分。平局都不得分也不扣分。<br>狡猾的小黑同学为了赢得比赛，提前偷到了小白所有蚂蚁得速度，请你帮小黑算一算，他在比赛中最多得多少分。</p><p><code>输入格式</code><br>有多组测试案例，最多有100组，对于每一组案例：<br>第一行以正整数n ,（n≤1000），即每个人的蚂蚁数量。<br>第二行的n个整数是小黑的蚂蚁的速度。<br>第三行的n整数是小白的蚂蚁速度。<br>蚂蚁的速度小于100</p><p><code>输出格式</code><br>对于每个输入案例，输出一个整数，这是小黑能够获得的最大分数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">10 10</span><br><span class="line">2</span><br><span class="line">10 1</span><br><span class="line">100 8</span><br><span class="line">output</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁上树"><a href="#蚂蚁上树" class="headerlink" title="蚂蚁上树"></a>蚂蚁上树</h2><p>Description:<br>蚂蚁想知道这棵树上距离最远的两个点之间的距离</p><p>给你一个具有 n 个节点的树</p><p>求这棵树上距离最远的两个点之间的距离</p><p>输入格式<br>第一行一个整数 n ，(1≤n≤104)</p><p>接下来 n−1 行，每行三个整数 x,y,z 表示 x 与 y 之间有一条长度为 z 的边 (1≤x,y≤n,1≤z≤104)</p><p>输出格式<br>一个整数表示树上距离最远的两个点之间的距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">5</span><br><span class="line">1 2 9</span><br><span class="line">1 3 3</span><br><span class="line">1 5 2</span><br><span class="line">2 4 10</span><br><span class="line">output</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e4 + 10;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; v[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int ans, point;</span><br><span class="line">//struct node&#123;</span><br><span class="line">//int x, y, step;</span><br><span class="line">//&#125;;</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">//node e1, e2;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x] = 1;</span><br><span class="line">ans = 0;</span><br><span class="line">point = 0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[f] &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line">ans = dis[f];</span><br><span class="line">point = f;</span><br><span class="line">//return ans;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int, int&gt; t;</span><br><span class="line">for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">t = v[f][i];</span><br><span class="line">if(vis[t.first] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first] = 1;</span><br><span class="line">dis[t.first] = t.second + dis[f];</span><br><span class="line">q.push(t.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int a, b, c;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">v[a].push_back(make_pair(b, c));</span><br><span class="line">v[b].push_back(make_pair(a, c));</span><br><span class="line">&#125;</span><br><span class="line">bfs(1);</span><br><span class="line">bfs(point);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁的游戏"><a href="#蚂蚁的游戏" class="headerlink" title="蚂蚁的游戏"></a>蚂蚁的游戏</h2><p>Description:<br>蚂蚁Bob和蚂蚁Alice是青梅竹蚁，Alice喜欢和Bob一起玩游戏，每当Alice想到新的游戏，都会找Bob一起玩</p><p>今天Alice的游戏是这样的：</p><p>n堆石子，两人轮流取。每次只能在1堆中取，不能不取，最先取完石子者胜</p><p>Alice先取石子，Alice和Bob都非常聪明，拿石子的过程中不会出现失误。</p><p><code>输入格式</code><br>第一行有一个整数T，有T组输入数据(T≤50)</p><p>每组第一行有一个数n表示有n堆石子，(1≤n≤20000)</p><p>第二行有n个非零整数x，表示每堆石子的数量(x≤103)</p><p><code>输出格式</code><br>请你判断Alice能否在游戏中获胜，如果不能获胜，输出NO。</p><p>否则，输出YES，并输出第一次取石子的所有方法（具体参见样例和提示）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">45 45</span><br><span class="line">5</span><br><span class="line">5 7 8 9 10</span><br><span class="line">output</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">3 1</span><br><span class="line">4 0</span><br><span class="line">5 3</span><br><span class="line">提示</span><br><span class="line">对于第一组样例，不论Alice怎么取，Bob总能拿到最后一个石子，所以输出为NO</span><br><span class="line"></span><br><span class="line">对于第二组样例，Alice可以第一次取石子有三种取法：</span><br><span class="line"></span><br><span class="line">第3堆取出7个，剩下1个</span><br><span class="line">第4堆全部取出，剩下0个</span><br><span class="line">第5堆取出7个，剩下3个</span><br><span class="line">对于每组输出，总是按照堆的编号顺序输出的</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day16&quot;&gt;&lt;a href=&quot;#Day16&quot; class=&quot;headerlink&quot; title=&quot;Day16&quot;&gt;&lt;/a&gt;Day16&lt;/h1&gt;&lt;p&gt;今天是一场积分赛，还行~~&lt;br&gt;&lt;a href=&quot;https://hpuoj.com/contest/25/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Day15</title>
    <link href="http://yoursite.com/2019/08/02/Day15/"/>
    <id>http://yoursite.com/2019/08/02/Day15/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-08-04T13:02:08.134Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --><h1 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h1><p>今天继续学习背包问题，刷题~刷题~刷题！<br><a href="https://www.acwing.com/problem/" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>Description:<br>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">输出样例：</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int v[10001], w[10001];</span><br><span class="line">int dp[10001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= w[i]; j --)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">//下面的是没优化的部分</span><br><span class="line">//if(j &gt;= w[i])</span><br><span class="line">//dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">//else</span><br><span class="line">//dp[i][j] = dp[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[V];</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>Description:<br>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。<br><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">输出样例：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int w[10001], v[10001];</span><br><span class="line">int dp[10001][10001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= V; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &gt;= w[i])</span><br><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">else</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[N][V] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="多重背包1"><a href="#多重背包1" class="headerlink" title="多重背包1"></a>多重背包1</h2><p>Description:<br>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br><span class="line">输出样例：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int f = 300;</span><br><span class="line">int w[f], v[f], c[f];</span><br><span class="line">int dp[f][f];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= 0; j --)</span><br><span class="line">&#123;</span><br><span class="line">//其实就是把这类物品展开，调用c[i]次01背包代码</span><br><span class="line">for(int k = 0; k &lt;= c[i]; k ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &gt;= w[i] * k)</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i] * k] + v[i] * k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[N][V] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="多重背包2-用二进制优化"><a href="#多重背包2-用二进制优化" class="headerlink" title="多重背包2(用二进制优化)"></a>多重背包2(用二进制优化)</h2><p>Description:<br>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N≤1000<br>0&lt;V≤2000<br>0&lt;vi,wi,si≤2000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br><span class="line">输出样例：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int w[1001], v[1001], c[1001], dp[2001];</span><br><span class="line">int a[25000], b[25000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 0; i &lt; N; i ++)</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0; i &lt; N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt; c[i]; j &lt;&lt;= 1)</span><br><span class="line">&#123;</span><br><span class="line">a[sum] = j * w[i];//存储容量 </span><br><span class="line">b[sum ++] = j * v[i];//存储价值</span><br><span class="line">c[i] -= j; </span><br><span class="line">&#125;</span><br><span class="line">if(c[i])</span><br><span class="line">&#123;</span><br><span class="line">a[sum] = c[i] * w[i];</span><br><span class="line">b[sum ++] = c[i] * v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; sum; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= a[i]; j --)</span><br><span class="line">dp[j] = max(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[V] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="掺杂个字符串的题-混入其中"><a href="#掺杂个字符串的题-混入其中" class="headerlink" title="掺杂个字符串的题(混入其中)"></a>掺杂个字符串的题(混入其中)</h2><p><a href="https://www.luogu.org/problem/P1055" target="_blank" rel="noopener">ISBN号码-字符串的题</a><br>Description:<br>每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括99位数字、11位识别码和33位分隔符，其规定格式如x-xxx-xxxxx-x，其中符号-就是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符-之后的三位数字代表出版社，例如670670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。</p><p>识别码的计算方法如下：</p><p>首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1,2,…,9再求和，即0×1+6×2+……+2×9=158，然后取158mod11的结果4作为识别码。</p><p>你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出Right；如果错误，则输出你认为是正确的ISBN号码。</p><p>输入格式<br>一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。</p><p>输出格式<br>一行，假如输入的ISBN号码的识别码正确，那么输出Right，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符-）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入输出样例</span><br><span class="line">输入</span><br><span class="line">0-670-82162-4</span><br><span class="line">输出</span><br><span class="line">Right</span><br><span class="line">输入</span><br><span class="line">0-670-82162-0</span><br><span class="line">输出</span><br><span class="line">0-670-82162-4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char str[13], a[12] = &#123;&quot;0123456789X&quot;&#125;;</span><br><span class="line">gets(str);</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0, len = 1; i &lt; 12; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(str[i] == &apos;-&apos;)</span><br><span class="line">continue;</span><br><span class="line">sum += (str[i] - &apos;0&apos;)* len;</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">sum %= 11;</span><br><span class="line">if(a[sum] == str[12])</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Right&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">str[12] = a[sum];</span><br><span class="line">puts(str);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day15&quot;&gt;&lt;a href=&quot;#Day15&quot; class=&quot;headerlink&quot; title=&quot;Day15&quot;&gt;&lt;/a&gt;Day15&lt;/h1&gt;&lt;p&gt;今天继续学习背包问题，刷题~刷题~刷题！&lt;br&gt;&lt;a href=&quot;https://www.acwing.com/problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Day14</title>
    <link href="http://yoursite.com/2019/08/01/Day14/"/>
    <id>http://yoursite.com/2019/08/01/Day14/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-05T14:33:13.052Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --><h1 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h1><p>今天讲的是矩阵快速幂<br>相比于之前，算是好理解一点~<br><a id="more"></a></p><h2 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h2><p>就比如Fib<br>Fib[i] = Fib[i-1] + Fib[i-2]<br>int Fib[maxn] ;<br>Fib[1] = 1 ,Fib[2] = 1 ;<br>for (int i = 3 ; i &lt;= n ; i ++ ) {<br>Fib[i] = Fib[i-1] + Fib[i-2] ;<br>}</p><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a href="https://blog.csdn.net/MosBest/article/details/69264953" target="_blank" rel="noopener">链接</a></p><h2 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h2><p>在线性代数中，一个n×n矩阵A的主对角线（从左上方至右下方的对角线）上各个元素的总和被称为矩阵A的迹（或迹数），一般记作tr(A)。</p><h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>Description:<br>菲波那契数列是指这样的数列: 数列的第一个是0和第二个数是1，接下来每个数都等于前面2个数之和。 给出一个正整数a，要求菲波那契数列中第a个数的后四位是多少。<br><code>Input</code><br>多组数据 -1结束 范围1~10^9<br><code>Output</code><br>第x项的后4位<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">999999999</span><br><span class="line">1000000000</span><br><span class="line">-1</span><br><span class="line">Sample Output</span><br><span class="line">0</span><br><span class="line">34</span><br><span class="line">626</span><br><span class="line">6875</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 10000;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int N, M;</span><br><span class="line">int f = 2;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(ll i = 1; i &lt;= f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j = 1; j &lt;= f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll k = 1; k &lt;= f; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(ll i = 1; i &lt;= f; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, a, b;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;N))</span><br><span class="line">&#123;</span><br><span class="line">if(N == -1) break;</span><br><span class="line">if(N == 0)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;0&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">a.materix[1][1] = 1 ; a.materix[1][2] = 0 ;</span><br><span class="line">a.materix[2][1] = 1 ; a.materix[2][2] = 0 ;</span><br><span class="line">b.materix[1][1] = 1 ; b.materix[1][2] = 1 ;</span><br><span class="line">b.materix[2][1] = 1 ; b.materix[2][2] = 0 ;</span><br><span class="line">ans = kpow(b, N - 2);</span><br><span class="line">ans = mul(ans, a);</span><br><span class="line">cout &lt;&lt; ans.materix[1][1] % 10000 &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Tr-A"><a href="#Tr-A" class="headerlink" title="Tr A"></a>Tr A</h2><p>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。<br><code>Input</code><br>数据的第一行是一个T，表示有T组数据。<br>每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。<br><code>Output</code><br>对应每组数据，输出Tr(A^k)%9973。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">3 99999999</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">2686</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 9973;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll N, M;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= N; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, b;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">ll sum;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; b.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">ans = kpow(b, M - 1);</span><br><span class="line">ans = mul(ans, b);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">sum = (sum + ans.materix[i][i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A-Simple-Math-Problem"><a href="#A-Simple-Math-Problem" class="headerlink" title="A Simple Math Problem"></a>A Simple Math Problem</h2><p>Description:<br>Lele now is thinking about a simple function f(x).</p><p>If x &lt; 10 f(x) = x.<br>If x &gt;= 10 f(x) = a0 <em>f(x-1) + a1 </em>f(x-2) + a2 <em>f(x-3) + …… + a9 </em>f(x-10);<br>And ai(0&lt;=i&lt;=9) can only be 0 or 1 .</p><p>Now, I will give a0 ~ a9 and two positive integers k and m ,and could you help Lele to caculate f(k)%m.<br><code>Input</code><br>The problem contains mutiple test cases.Please process to the end of file.<br>In each case, there will be two lines.<br>In the first line , there are two positive integers k and m. ( k&lt;2*10^9 , m &lt; 10^5 )<br>In the second line , there are ten integers represent a0 ~ a9.<br><code>Output</code><br>For each case, output f(k) % m in one line.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">10 9999</span><br><span class="line">1 1 1 1 1 1 1 1 1 1</span><br><span class="line">20 500</span><br><span class="line">1 0 1 0 1 0 1 0 1 0</span><br><span class="line">Sample Output</span><br><span class="line">45</span><br><span class="line">104</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">int m;</span><br><span class="line">int f = 10;</span><br><span class="line">int x[10];</span><br><span class="line">struct node&#123;</span><br><span class="line">int materix[10][10];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; f; k ++)</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % m) % m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//矩阵快速幂 </span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, a, b, s;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">cin &gt;&gt; x[i];</span><br><span class="line">if(n &lt; 10) ans.materix[0][0] = n % m;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">memset(a.materix, 0, sizeof a.materix);</span><br><span class="line">memset(b.materix, 0, sizeof b.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a.materix[i][0] = 10 - 1 - i;</span><br><span class="line">b.materix[0][i] = x[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; 10; i ++)</span><br><span class="line">b.materix[i][i - 1] = 1;</span><br><span class="line">ans = kpow(b, n - 9);</span><br><span class="line">ans = mul(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans.materix[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Recursive-sequence"><a href="#Recursive-sequence" class="headerlink" title="Recursive sequence"></a>Recursive sequence</h2><p>Description:<br>Farmer John likes to play mathematics games with his N cows. Recently, they are attracted by recursive sequences. In each turn, the cows would stand in a line, while John writes two positive numbers a and b on a blackboard. And then, the cows would say their identity number one by one. The first cow says the first number a and the second says the second number b. After that, the i-th cow says the sum of twice the (i-2)-th number, the (i-1)-th number, and i4. Now, you need to write a program to calculate the number of the N-th cow in order to check if John’s cows can make it right.<br><code>Input</code><br>The first line of input contains an integer t, the number of test cases. t test cases follow.<br>Each case contains only one line with three numbers N, a and b where N,a,b &lt; 231 as described above.<br><code>Output</code><br>For each test case, output the number of the N-th cow. This number might be very large, so you need to output it modulo 2147493647.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 1 2</span><br><span class="line">4 1 10</span><br><span class="line">Sample Output</span><br><span class="line">85</span><br><span class="line">369</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">In the first case, the third number is 85 = 2*1十2十3^4.</span><br><span class="line"> In the second case, the third number is 93 = 2*1十1*10十3^4 and the fourth number is 369 = 2 * 10 十 93 十 4^4.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod = 2147493647;</span><br><span class="line">const ll f = 7;</span><br><span class="line">ll n, x, y;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[f][f];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; f; k ++)</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 0; i &lt; 7; i ++)</span><br><span class="line">for(int j = 0; j &lt; 7; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(i == j) res.materix[i][j] = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll T;</span><br><span class="line">node a, b, ans;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">if(n == 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else if(n == 2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">memset(a.materix, 0, sizeof a.materix);</span><br><span class="line">memset(b.materix, 0, sizeof b.materix);</span><br><span class="line">a.materix[0][0]=1,a.materix[0][1]=2,a.materix[0][2]=1,a.materix[0][3]=0,a.materix[0][4]=0,a.materix[0][5]=0;a.materix[0][6]=0;</span><br><span class="line">        a.materix[1][0]=1,a.materix[1][1]=0,a.materix[1][2]=0,a.materix[1][3]=0,a.materix[1][4]=0,a.materix[1][5]=0;a.materix[1][6]=0;</span><br><span class="line">        a.materix[2][0]=0,a.materix[2][1]=0,a.materix[2][2]=1,a.materix[2][3]=4,a.materix[2][4]=6,a.materix[2][5]=4;a.materix[2][6]=1;</span><br><span class="line">        a.materix[3][0]=0,a.materix[3][1]=0,a.materix[3][2]=0,a.materix[3][3]=1,a.materix[3][4]=3,a.materix[3][5]=3;a.materix[3][6]=1;</span><br><span class="line">        a.materix[4][0]=0,a.materix[4][1]=0,a.materix[4][2]=0,a.materix[4][3]=0,a.materix[4][4]=1,a.materix[4][5]=2;a.materix[4][6]=1;</span><br><span class="line">        a.materix[5][0]=0,a.materix[5][1]=0,a.materix[5][2]=0,a.materix[5][3]=0,a.materix[5][4]=0,a.materix[5][5]=1;a.materix[5][6]=1;</span><br><span class="line">        a.materix[6][0]=0,a.materix[6][1]=0,a.materix[6][2]=0,a.materix[6][3]=0,a.materix[6][4]=0,a.materix[6][5]=0;a.materix[6][6]=1;</span><br><span class="line">        b.materix[0][0]=y % mod;</span><br><span class="line">        b.materix[1][0]=x % mod;</span><br><span class="line">        b.materix[2][0]=81;</span><br><span class="line">        b.materix[3][0]=27;</span><br><span class="line">        b.materix[4][0]=9;</span><br><span class="line">        b.materix[5][0]=3;</span><br><span class="line">        b.materix[6][0]=1;</span><br><span class="line">        ans = kpow(a, n - 2);</span><br><span class="line">        ans = mul(ans, b);</span><br><span class="line">        cout &lt;&lt; ans.materix[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="求递推序列的第N项"><a href="#求递推序列的第N项" class="headerlink" title="求递推序列的第N项"></a>求递推序列的第N项</h2><p>有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A <em>f(n - 1) + B </em>f(n - 2)) mod 7.<br>给出A，B和N，求f(n)的值。</p><p><code>输入</code><br>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)<br><code>输出</code><br>输出f(n)的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">3 -1 5</span><br><span class="line">输出样例</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int f = 2;</span><br><span class="line">const int mod = 7;</span><br><span class="line">struct node&#123;</span><br><span class="line">int materix[5][5];</span><br><span class="line">&#125;; </span><br><span class="line">//矩阵乘法</span><br><span class="line">node nul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= f; k ++)</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans; </span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 1; i &lt;= f ;i ++)</span><br><span class="line">res.materix[i][i] = 1; </span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = nul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = nul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int A, B, N;</span><br><span class="line">cin &gt;&gt; A &gt;&gt; B &gt;&gt; N;</span><br><span class="line">node a, b;</span><br><span class="line">if(N == 1 || N == 1)</span><br><span class="line">puts(&quot;1&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a.materix[1][1] = 1; a.materix[1][2] = 0;</span><br><span class="line">a.materix[2][1] = 1; a.materix[2][2] = 0;</span><br><span class="line">b.materix[1][1] = A; b.materix[1][2] = B;</span><br><span class="line">b.materix[2][1] = 1; b.materix[2][2] = 0;</span><br><span class="line">node ans = kpow(b, N - 2);</span><br><span class="line">ans = nul(ans, a);</span><br><span class="line">cout &lt;&lt; ans.materix[1][1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="矩阵快速幂-1"><a href="#矩阵快速幂-1" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>Description:</p><p>给出一个N <em>N的矩阵，其中的元素均为正整数。求这个矩阵的M次方。由于M次方的计算结果太大，只需要输出每个元素Mod (10^9 + 7）的结果。<br><code>输入</code><br>第1行：2个数N和M，中间用空格分隔。N为矩阵的大小，M为M次方。(2 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 10^9)<br>第2 - N + 1行：每行N个数，对应N </em>N矩阵中的1行。(0 &lt;= N[i] &lt;= 10^9)<br><code>输出</code><br>共N行，每行N个数，对应M次方Mod (10^9 + 7)的结果。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">2 3</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">输出样例</span><br><span class="line">4 4</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int N, M;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= N; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, b;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; b.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = kpow(b, M - 1);</span><br><span class="line">ans = mul(ans, b);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cout &lt;&lt; ans.materix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>Description:<br>给出2个N <em>N的矩阵M1和M2，输出2个矩阵相乘后的结果。<br><code>输入</code><br>第1行：1个数N，表示矩阵的大小(2 &lt;= N &lt;= 100)<br>第2 - N + 1行，每行N个数，对应M1的1行(0 &lt;= M1[i] &lt;= 1000)<br>第N + 2 - 2N + 1行，每行N个数，对应M2的1行(0 &lt;= M2[i] &lt;= 1000)<br><code>输出</code><br>输出共N行，每行N个数，对应M1 </em>M2的结果的一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">输出样例</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int N, M;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= N; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, a, b;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; a.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; b.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = mul(a, b);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cout &lt;&lt; ans.materix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day14&quot;&gt;&lt;a href=&quot;#Day14&quot; class=&quot;headerlink&quot; title=&quot;Day14&quot;&gt;&lt;/a&gt;Day14&lt;/h1&gt;&lt;p&gt;今天讲的是矩阵快速幂&lt;br&gt;相比于之前，算是好理解一点~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="矩阵快速幂" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>Day13</title>
    <link href="http://yoursite.com/2019/07/31/Day13/"/>
    <id>http://yoursite.com/2019/07/31/Day13/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T15:21:19.039Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h1><p>今天讲的是 <code>背包</code> 问题<br>背包九讲(自闭快乐~~)<br><a id="more"></a></p><h2 id="今天先背包三讲"><a href="#今天先背包三讲" class="headerlink" title="今天先背包三讲"></a>今天先背包三讲</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line">有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><br><span class="line">基本思路 </span><br><span class="line">这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 </span><br><span class="line"></span><br><span class="line">用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;。 </span><br><span class="line"></span><br><span class="line">这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。 </span><br><span class="line"></span><br><span class="line">注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </span><br><span class="line"></span><br><span class="line">优化空间复杂度 </span><br><span class="line">以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 </span><br><span class="line"></span><br><span class="line">先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1] [v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v -c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i -1][v-c[i]]的值。伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line">其中的f[v]=max&#123;f[v],f[v-c[i]]&#125;一句恰就相当于我们的转移方程f[i][v]=max&#123;f[i-1][v],f[i- 1][v-c[i]]&#125;，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本思路 </span><br><span class="line">这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;= v&#125;。这跟01背包问题一样有O(N*V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 </span><br><span class="line"></span><br><span class="line">将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 </span><br><span class="line"></span><br><span class="line">一个简单有效的优化 </span><br><span class="line">完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题求解 </span><br><span class="line">既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c [i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 </span><br><span class="line"></span><br><span class="line">更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。 * O(VN)的算法这个算法使用一维数组，先看伪代码： &lt;pre class&quot;example&quot;&gt; for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 </span><br><span class="line"></span><br><span class="line">这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max&#123;f[i-1][v],f[i][v-c[i]]+w[i]&#125;，将这个方程用一维数组实现，便得到了上面的伪代码。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</span><br></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本算法 </span><br><span class="line">这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取 n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max&#123;f[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]&#125;。复杂度是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题 </span><br><span class="line">另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 </span><br><span class="line"></span><br><span class="line">方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 </span><br><span class="line"></span><br><span class="line">分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 </span><br><span class="line"></span><br><span class="line">这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 </span><br><span class="line"></span><br><span class="line">O(VN)的算法 </span><br><span class="line">多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">这里我们看到了将一个算法的复杂度由O(V*∑n[i])改进到O(V*∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</span><br></pre></td></tr></table></figure><h2 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h2><p>Description:<br>涂奥最近迷上了吃鸡，房间有n个配件，每个配件有c(c&lt;=1e3)的重量和v(v&lt;=1e3)的价值，哇，涂奥捡了一个2级包，容量为s，所以涂奥最多当多肥的快递员呢？<br>Input<br>输入的第一行是T, 表示有一共要打T场比赛.<br>每组数据由三行组成.<br>第1行包含两个整数n和s 第2行包含n个整数, 表示每一个配件的价值. 第3行包含n个整数, 表示每个配件的重量.<br>Output<br>对每一组数据, 输出涂奥可以多肥.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">10 10</span><br><span class="line">1 3 5 7 9 11 13 15 17 19</span><br><span class="line">19 17 15 13 11 9 7 5 3 1</span><br><span class="line">Sample Output</span><br><span class="line">51</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e3 + 10;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int w[maxx], v[maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, s;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i];</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int  j = 0; j &lt;= s; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &lt; w[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n][s] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="饭卡"><a href="#饭卡" class="headerlink" title="饭卡"></a>饭卡</h2><p>Description:<br>电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。<br>某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。<br>Input<br>多组数据。对于每组数据：<br>第一行为正整数n，表示菜的数量。n&lt;=1000。<br>第二行包括n个正整数，表示每种菜的价格。价格不超过50。<br>第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。</p><p>n=0表示数据结束。<br>Output<br>对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">50</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 3 2 1 1 2 3 2 1</span><br><span class="line">50</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">-45</span><br><span class="line">32</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int w[maxx], v[maxx], num[maxx], dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))//n表示菜的数量 </span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">int maxn = 0, max_id = -1, ans = 0, m;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">memset(w, 0, sizeof w);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; w[i];//菜的价格 </span><br><span class="line">if(w[i] &gt; maxn)</span><br><span class="line">&#123;</span><br><span class="line">maxn = w[i];//记录最贵的菜价</span><br><span class="line">max_id = i;//记录最贵菜的下标 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w[max_id] = 0;</span><br><span class="line">cin &gt;&gt; m;//卡上余额 </span><br><span class="line">m -= 5;//预留5元最后买最贵的菜 </span><br><span class="line">int cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = m; j &gt;= w[i]; j --)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[j] &lt; dp[j - w[i]] + w[i])</span><br><span class="line">dp[j] = dp[j - w[i]] + w[i];</span><br><span class="line">if(dp[j] &gt; cnt)</span><br><span class="line">cnt = dp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(m &gt;= 0)</span><br><span class="line">ans = m - cnt - maxn + 5;</span><br><span class="line">else</span><br><span class="line">ans = m + 5;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="CD"><a href="#CD" class="headerlink" title="CD"></a>CD</h2><p>Description:<br>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How to choose tracks from CD to get most out of tape space and have as short unused space as possible. Assumptions: • number of tracks on the CD does not exceed 20 • no track is longer than N minutes • tracks do not repeat • length of each track is expressed as an integer number • N is also integer Program should find the set of tracks which fills the tape best and print it in the same sequence as the tracks are stored on the CD Input Any number of lines.<br>Each one contains value N, (after space) number of tracks and durations of the tracks. For example from first line in sample data: N = 5, number of tracks=3, first track lasts for 1 minute, second one 3 minutes, next one 4 minutes Output Set of tracks (and durations) which are the correct solutions and string ‘sum:’ and sum of duration times.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input </span><br><span class="line">5 3 1 3 4 </span><br><span class="line">10 4 9 8 4 2 </span><br><span class="line">20 4 10 5 7 4 </span><br><span class="line">90 8 10 23 1 2 3 4 5 7 </span><br><span class="line">45 8 4 10 44 43 12 9 8 2 </span><br><span class="line">Sample Output </span><br><span class="line">1 4 sum:5 </span><br><span class="line">8 2 sum:10 </span><br><span class="line">10 5 4 sum:19 </span><br><span class="line">10 23 1 2 3 4 5 7 sum:55 </span><br><span class="line">4 10 12 9 8 2 sum:45</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,num;</span><br><span class="line">const int maxn=10005;</span><br><span class="line">int a[maxn],dp[maxn],flag[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">cin.tie(0);</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;a[i];</span><br><span class="line">memset(flag,0,sizeof(flag));</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=m-1;i&gt;=0;i--)//这里倒序主要是在输出的时候方便</span><br><span class="line">&#123;</span><br><span class="line">for(int j=n;j&gt;=a[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[j]&lt;dp[j-a[i]]+a[i])//选上了a[i]的情况</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=dp[j-a[i]]+a[i];</span><br><span class="line">flag[i][j]=1;//进行标记</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0,j=n;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(flag[i][j])//标价到的就输出</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">j-=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;sum:&quot;&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Piggy-Bank"><a href="#Piggy-Bank" class="headerlink" title="Piggy-Bank"></a>Piggy-Bank</h2><p>Description:<br>在 ACM 能够开展之前，必须准备预算，并获得必要的财力支持。该活动的主要收入来自于 Irreversibly Bound Money (IBM)。思路很简单。任何时候，某位 ACM 会员有少量的钱时，他将所有的硬币投入到小猪储钱罐中。这个过程不可逆，因为只有把小猪储钱罐打碎才能取出硬币。在足够长的时间之后，小猪储钱罐中有了足够的现金，用于支付 ACM 活动所需的花费。<br>但是，小猪储钱罐存在一个大的问题，即无法确定其中有多少钱。因此，我们可能在打碎小猪储钱罐之后，发现里面的钱不够。显然，我们希望避免这种不愉快的情况。唯一的可能是，称一下小猪储钱罐的重量，并尝试猜测里面的有多少硬币。假定我们能够精确判断小猪储钱罐的重量，并且我们也知道给定币种的所有硬币的重量。那么，我们可以保证小猪储钱罐中最少有多少钱。<br>你的任务是找出最差的情形，即判断小猪储钱罐中的硬币最少有多少钱。我们需要你的帮助。不能再贸然打碎小猪储钱罐了！<br>小猪储钱罐了！<br>输入<br>输入包含 T 组测试数据。输入文件的第一行，给出了 T 的值。<br>对于每组测试数据，第一行包含 E 和 F 两个整数，它们表示空的小猪储钱罐的重量，以及装有硬币的小猪储钱罐的重量。两个重量的计量单位都是 g (克)。小猪储钱罐的重量不会超过 10 kg (千克)，即 1 &lt;= E &lt;= F &lt;= 10000 。每组测试数据的第二行，有一个整数 N (1 &lt;= N &lt;= 500)，提供了给定币种的不同硬币有多少种。接下来的 N 行，每行指定一种硬币类型，每行包含两个整数 P 和 W (1 &lt;= P &lt;= 50000，1 &lt;= W &lt;=10000)。P 是硬币的金额 (货币计量单位)；W 是它的重量，以 g (克) 为计量单位。<br>输出<br>对于每组测试数据，打印一行输出。每行必须包含句子 “The minimum amount of money in the piggy-bank is X.” 其中，X 表示对于给定总重量的硬币，所能得到的最少金额。如果无法恰好得到给定的重量，则打印一行 “This is impossible.” 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例输入</span><br><span class="line">3</span><br><span class="line">10 110</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">30 50</span><br><span class="line">10 110</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">50 30</span><br><span class="line">1 6</span><br><span class="line">2</span><br><span class="line">10 3</span><br><span class="line">20 4</span><br><span class="line">示例输出</span><br><span class="line">The minimum amount of money in the piggy-bank is 60.</span><br><span class="line">The minimum amount of money in the piggy-bank is 100.</span><br><span class="line">This is impossible.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int v[mod], w[mod];</span><br><span class="line">int dp[mod];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T, n, m;</span><br><span class="line">int E, F;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; E &gt;&gt; F;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">for(int i = 1; i &lt;= F - E; i ++) dp[i] = INF;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = w[i]; j &lt;= F - E; j ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = min(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(dp[F - E] != INF)</span><br><span class="line">printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[F - E]);</span><br><span class="line">else</span><br><span class="line">puts(&quot;This is impossible.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Dividing-coins"><a href="#Dividing-coins" class="headerlink" title="Dividing coins"></a>Dividing coins</h2><p>Description:<br>It’s commonly known that the Dutch have invented copper-wire. Two Dutch men were fighting over a nickel, which was made of copper. They were both so eager to get it and the fighting was so fierce, they stretched the coin to great length and thus created copper-wire. Not commonly known is that the fighting started, after the two Dutch tried to divide a bag with coinsbetweenthetwoofthem. Thecontentsofthebagappearednottobeequallydivisible. TheDutch of the past couldn’t stand the fact that a division should favour one of them and they always wanted a fair share to the very last cent. Nowadays fighting over a single cent will not be seen anymore, but being capable of making an equal division as fair as possible is something that will remain important forever… That’s what this whole problem is about. Not everyone is capable of seeing instantly what’s the most fair division of a bag of coins between two persons. Your help is asked to solve this problem. Given a bag with a maximum of 100 coins, determine the most fair division between two persons. This means that the difference between the amount each person obtains should be minimised.<br>The value of a coin varies from 1 cent to 500 cents. It’s not allowed to split a single coin. Input A line with the number of problems n, followed by n times: • a line with a non negative integer m (m ≤ 100) indicating the number of coins in the bag • a line with m numbers separated by one space, each number indicates the value of a coin. Output The output consists of n lines. Each line contains the minimal positive difference between the amount the two persons obtain when they divide the coins from the corresponding bag.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"> 2 </span><br><span class="line"> 3 </span><br><span class="line"> 2 3 5</span><br><span class="line"> 4 </span><br><span class="line"> 1 2 4 6 </span><br><span class="line"> Sample Output </span><br><span class="line"> 0 </span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int tx=1e5+10;</span><br><span class="line">int m[tx],dp[tx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,t;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i=0;i&lt;t;i++)cin&gt;&gt;m[i],sum+=m[i];</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=sum/2;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]+m[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum-dp[sum/2]-dp[sum/2]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Robberies"><a href="#Robberies" class="headerlink" title="Robberies"></a>Robberies</h2><p>Description:<br>可怜的POIUYTREWQ最近想买下dota2的商品，但是手头缺钱。他想起了之前看过的一部大片，觉得抢银行也许是个不错的选择。他认为，坏人被抓是因为没有预先规划。于是他在之前的几个月对各大银行进行了一次评估； 评估内容包括安全性和可盗窃金额： 他想知道在在某个风险系数下可以偷窃的最大金额<br>Input<br>第一行给出了一个整数T, 表示有T组测试数据. 对于每一组数据，第一行给出了一个浮点数P, 表示POIUYTREWQ允许被抓的最大概率, 和一个整数N，表示他计划去抢劫的N个银行. 接下来N行, 每行给出一个整数数Mj和浮点数Pj.<br>抢劫银行 j 可获得 Mj 百万美金, 被抓的概率是 Pj .<br>Output<br>对于每组数据，每行输出一个整数，表示POIUYTREWQ在被抓概率小于P的情况下，可抢到的最多的金钱。</p><p>Notes and Constraints<br>0 &lt; T &lt;= 100<br>0.0 &lt;= P &lt;= 1.0<br>0 &lt; N &lt;= 100<br>0 &lt; Mj &lt;= 100<br>0.0 &lt;= Pj &lt;= 1.0<br>你可以认为每家银行都是独立的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">0.04 3</span><br><span class="line">1 0.02</span><br><span class="line">2 0.03</span><br><span class="line">3 0.05</span><br><span class="line">0.06 3</span><br><span class="line">2 0.03</span><br><span class="line">2 0.03</span><br><span class="line">3 0.05</span><br><span class="line">0.10 3</span><br><span class="line">1 0.03</span><br><span class="line">2 0.02</span><br><span class="line">3 0.05</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">int m[maxn];double dp[100005],p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">double pp;int n,sum=0;</span><br><span class="line">cin&gt;&gt;pp&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m[i]&gt;&gt;p[i];</span><br><span class="line">sum+=m[i];</span><br><span class="line">p[i]=1-p[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[0]=1;//这个初始化很重要</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=sum;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]*p[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=sum;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[i]&gt;=1-pp)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h2><p>Description:</p><p>Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to make changes with these coins for a given amount of money. For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-cent coin, two 5-cent coins and one 1-cent coin, one 5-cent coin and six 1-cent coins, or eleven 1-cent coins. So there are four ways of making changes for 11 cents with the above coins. Note that we count that there is one way of making change for zero cent. Write a program to find the total number of different ways of making changes for any amount of money in cents. Your program should be able to handle up to 7489 cents. Input The input file contains any number of lines, each one consisting of a number for the amount of money in cents. Output For each input line, output a line containing the number of different ways of making changes with the above 5 types of coins.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input </span><br><span class="line">11 </span><br><span class="line">26 </span><br><span class="line">Sample Output </span><br><span class="line">4 </span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 10005;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line"></span><br><span class="line">ll a[5] = &#123;1, 5, 10, 25, 50&#125;;</span><br><span class="line">ll dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(cin &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">dp[0] = 1;</span><br><span class="line">for(ll i = 0; i &lt; 5; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j = a[i]; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = dp[j] + dp[j - a[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"><a href="#悼念512汶川大地震遇难同胞——珍惜现在，感恩生活" class="headerlink" title="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"></a>悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</h2><p>Description:<br>急！灾区的食物依然短缺！<br>为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。<br>请问：你用有限的资金最多能采购多少公斤粮食呢？</p><p>后记：<br>人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。<br>月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——<br>感谢父母，他们给予我们生命，抚养我们成人；<br>感谢老师，他们授给我们知识，教我们做人<br>感谢朋友，他们让我们感受到世界的温暖；<br>感谢对手，他们令我们不断进取、努力。<br>同样，我们也要感谢痛苦与艰辛带给我们的财富～<br>Input<br>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。<br>Output<br>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">8 2</span><br><span class="line">2 100 4</span><br><span class="line">4 100 2</span><br><span class="line">Sample Output</span><br><span class="line">400</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 110;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int p[maxx];</span><br><span class="line">int h[maxx];</span><br><span class="line">int c[maxx];</span><br><span class="line">int dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T, n, m;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; p[i] &gt;&gt; h[i] &gt;&gt; c[i];</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = n; j &gt;= 0; j --)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= c[i]; k ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &gt;= p[i] * k)</span><br><span class="line">dp[j] = max(dp[j], dp[j - p[i] * k] + h[i] * k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">外循环i大米种类，中间循环j经费，内循环k该大米数量，递推式即为：dp[j]=max(dp[j],dp[j-p[i]*k]+h[i]*k)。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day13&quot;&gt;&lt;a href=&quot;#Day13&quot; class=&quot;headerlink&quot; title=&quot;Day13&quot;&gt;&lt;/a&gt;Day13&lt;/h1&gt;&lt;p&gt;今天讲的是 &lt;code&gt;背包&lt;/code&gt; 问题&lt;br&gt;背包九讲(自闭快乐~~)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="http://yoursite.com/2019/07/31/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <id>http://yoursite.com/2019/07/31/背包九讲/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T15:22:58.048Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a><center>背包九讲</center></h1><p><center>学习背包问题，肯定是要学习背包就讲的，这篇就整理一个全一点的背包九讲<br>背包问题在实际问题中还是比较重要的<br>记录下来问题多多复习<br>争取熟练掌握<br><img src="/2019/07/31/背包九讲/1.jpg" alt></center></p><a id="more"></a><p><code>以下内容皆是参考的别人的博客内容整理而成</code></p><h2 id="P01-01背包问题"><a href="#P01-01背包问题" class="headerlink" title="P01: 01背包问题"></a>P01: 01背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本思路 </span><br><span class="line">这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 </span><br><span class="line"></span><br><span class="line">用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;。 </span><br><span class="line"></span><br><span class="line">这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。 </span><br><span class="line"></span><br><span class="line">注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </span><br><span class="line"></span><br><span class="line">优化空间复杂度 </span><br><span class="line">以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 </span><br><span class="line"></span><br><span class="line">先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1] [v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v -c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i -1][v-c[i]]的值。伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line">其中的f[v]=max&#123;f[v],f[v-c[i]]&#125;一句恰就相当于我们的转移方程f[i][v]=max&#123;f[i-1][v],f[i- 1][v-c[i]]&#125;，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</span><br></pre></td></tr></table></figure><h2 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本思路 </span><br><span class="line">这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;= v&#125;。这跟01背包问题一样有O(N*V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 </span><br><span class="line"></span><br><span class="line">将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 </span><br><span class="line"></span><br><span class="line">一个简单有效的优化 </span><br><span class="line">完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题求解 </span><br><span class="line">既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c [i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 </span><br><span class="line"></span><br><span class="line">更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。 * O(VN)的算法这个算法使用一维数组，先看伪代码： &lt;pre class&quot;example&quot;&gt; for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 </span><br><span class="line"></span><br><span class="line">这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max&#123;f[i-1][v],f[i][v-c[i]]+w[i]&#125;，将这个方程用一维数组实现，便得到了上面的伪代码。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</span><br></pre></td></tr></table></figure><h2 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本算法 </span><br><span class="line">这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取 n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max&#123;f[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]&#125;。复杂度是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题 </span><br><span class="line">另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 </span><br><span class="line"></span><br><span class="line">方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 </span><br><span class="line"></span><br><span class="line">分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 </span><br><span class="line"></span><br><span class="line">这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 </span><br><span class="line"></span><br><span class="line">O(VN)的算法 </span><br><span class="line">多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">这里我们看到了将一个算法的复杂度由O(V*∑n[i])改进到O(V*∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</span><br></pre></td></tr></table></figure><h2 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">问题 </span><br><span class="line">如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ </span><br><span class="line"></span><br><span class="line">01背包与完全背包的混合 </span><br><span class="line">考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">if 第i件物品是01背包 </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line">else if 第i件物品是完全背包 </span><br><span class="line">for v=0..V </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line">再加上多重背包 </span><br><span class="line">如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n[i])个01背包的物品的方法也已经很优了。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</span><br></pre></td></tr></table></figure><h2 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">问题 </span><br><span class="line">二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。 </span><br><span class="line"></span><br><span class="line">算法 </span><br><span class="line">费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：f [i][v][u]=max&#123;f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]&#125;。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用顺序的循环，当物品有如完全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。 </span><br><span class="line"></span><br><span class="line">物品总个数的限制 </span><br><span class="line">有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。 </span><br><span class="line"></span><br><span class="line">另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</span><br></pre></td></tr></table></figure><h2 id="P06-分组的背包问题"><a href="#P06-分组的背包问题" class="headerlink" title="P06: 分组的背包问题"></a>P06: 分组的背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">问题 </span><br><span class="line">有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">算法 </span><br><span class="line">这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]=max&#123;f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组&#125;。 </span><br><span class="line"></span><br><span class="line">使用一维数组的伪代码如下： </span><br><span class="line"></span><br><span class="line">for 所有的组k </span><br><span class="line">for 所有的i属于组k </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; </span><br><span class="line"></span><br><span class="line">另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</span><br></pre></td></tr></table></figure><h2 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="P07: 有依赖的背包问题"></a>P07: 有依赖的背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简化的问题 </span><br><span class="line">这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 </span><br><span class="line"></span><br><span class="line">算法 </span><br><span class="line">这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 </span><br><span class="line"></span><br><span class="line">按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） </span><br><span class="line"></span><br><span class="line">考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 </span><br><span class="line"></span><br><span class="line">再考虑P06中的一句话：可以对每组中的物品应用P02中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]所有这些值时相应的最大价值f&apos;[0..V-c[i]]。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f&apos;[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。 </span><br><span class="line"></span><br><span class="line">更一般的问题 </span><br><span class="line">更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 </span><br><span class="line"></span><br><span class="line">解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 </span><br><span class="line"></span><br><span class="line">事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。 </span><br><span class="line"></span><br><span class="line">我想说：失败不是什么丢人的事情，从失败中全无收获才是。</span><br></pre></td></tr></table></figure><h2 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="P08: 泛化物品"></a>P08: 泛化物品</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义 </span><br><span class="line">考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。 </span><br><span class="line"></span><br><span class="line">更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。 </span><br><span class="line"></span><br><span class="line">这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。 </span><br><span class="line"></span><br><span class="line">一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c*w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c*w仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。 </span><br><span class="line"></span><br><span class="line">一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 </span><br><span class="line"></span><br><span class="line">泛化物品的和 </span><br><span class="line">如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即f(v)=max&#123;h(k) +l(v-k)|0&lt;=k&lt;=v&#125;。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和 l决定的泛化物品。 </span><br><span class="line"></span><br><span class="line">由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足f(v)=max&#123;h(k)+l(v-k)|0&lt;=k&lt;=v&#125;，则称f是h与l的和，即f=h+l。这个运算的时间复杂度是O(V^2)。 </span><br><span class="line"></span><br><span class="line">泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。 </span><br><span class="line"></span><br><span class="line">背包问题的泛化物品 </span><br><span class="line">一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。 </span><br><span class="line"></span><br><span class="line">综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 Scheme 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。 </span><br><span class="line"></span><br><span class="line">我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。</span><br></pre></td></tr></table></figure><h2 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。 </span><br><span class="line"></span><br><span class="line">例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。 </span><br><span class="line"></span><br><span class="line">还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。 </span><br><span class="line"></span><br><span class="line">下面说一些变化更大的问法。 </span><br><span class="line"></span><br><span class="line">输出方案 </span><br><span class="line">一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 </span><br><span class="line"></span><br><span class="line">还是以01背包为例，方程为f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;。再用一个数组g[i] [v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）： </span><br><span class="line"></span><br><span class="line">i=N </span><br><span class="line">v=V </span><br><span class="line">while(i&gt;0) </span><br><span class="line">if(g[i][v]==0) </span><br><span class="line">print &quot;未选第i项物品&quot; </span><br><span class="line">else if(g[i][v]==1) </span><br><span class="line">print &quot;选了第i项物品&quot; </span><br><span class="line">v=v-c[i] </span><br><span class="line"></span><br><span class="line">另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i] [v]==0改成f[i][v]==f[i-1][v]，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。 </span><br><span class="line"></span><br><span class="line">输出字典序最小的最优方案 </span><br><span class="line">这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 </span><br><span class="line"></span><br><span class="line">一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。 </span><br><span class="line"></span><br><span class="line">在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果f[i][v]==f[i-v]及f[i][v]==f[i-1][f-c[i]]+w[i]同时成立，应该按照后者（即选择了物品i）来输出方案。 </span><br><span class="line"></span><br><span class="line">求方案总数 </span><br><span class="line">对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。 </span><br><span class="line"></span><br><span class="line">对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为f[i][v]=sum&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;，初始条件f[0][0]=1。 </span><br><span class="line"></span><br><span class="line">事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。 </span><br><span class="line"></span><br><span class="line">最优方案的总数 </span><br><span class="line">这里的最优方案是指物品总价值最大的方案。还是以01背包为例。 </span><br><span class="line"></span><br><span class="line">结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">for v=0..V </span><br><span class="line">f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125; </span><br><span class="line">g[i][v]=0 </span><br><span class="line">if(f[i][v]==f[i-1][v]) </span><br><span class="line">inc(g[i][v],g[i-1][v] </span><br><span class="line">if(f[i][v]==f[i-1][v-c[i]]+w[i]) </span><br><span class="line">inc(g[i][v],g[i-1][v-c[i]]) </span><br><span class="line"></span><br><span class="line">如果你是第一次看到这样的问题，请仔细体会上面的伪代码。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。</span><br></pre></td></tr></table></figure><p>不出去看看，又怎么会知道这个世界的魅力！<br><img src="/2019/07/31/背包九讲/2.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;背包九讲&quot;&gt;&lt;a href=&quot;#背包九讲&quot; class=&quot;headerlink&quot; title=&quot;背包九讲&quot;&gt;&lt;/a&gt;&lt;center&gt;背包九讲&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;center&gt;学习背包问题，肯定是要学习背包就讲的，这篇就整理一个全一点的背包九讲&lt;br&gt;背包问题在实际问题中还是比较重要的&lt;br&gt;记录下来问题多多复习&lt;br&gt;争取熟练掌握&lt;br&gt;&lt;img src=&quot;/2019/07/31/背包九讲/1.jpg&quot; alt&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="背包九讲" scheme="http://yoursite.com/categories/ACM/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Day12</title>
    <link href="http://yoursite.com/2019/07/30/Day12/"/>
    <id>http://yoursite.com/2019/07/30/Day12/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-07-31T15:04:25.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h1><p>今天学习的是 记忆化搜索(还是和dp有关)</p><a id="more"></a><p><a href="https://vjudge.net/contest/315672#overview" target="_blank" rel="noopener">OJ</a></p><h2 id="什么是记忆化搜索？"><a href="#什么是记忆化搜索？" class="headerlink" title="什么是记忆化搜索？"></a>什么是记忆化搜索？</h2><p>搜索的低效在于没有能够很好地处理重叠子问题；动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目面前，又显得无奈。记忆化搜索正是在这样的情况下产生的，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起，扬长避短，简单实用，在信息学中有着重要的作用。<br>用一个公式简单地说：记忆化搜索=搜索的形式+动态规划的思想。<br>动态规划的一种变形就是记忆化搜索，就是根据动归方程写出递归式，然后在函数的开头直接返回以前计算过的结果，当然这样做也需要一个存储结构记下前面计算过的结果，所以又称为记忆化搜索。<br>记忆化搜索递归式动态规划</p><h3 id="记忆化搜索的思想"><a href="#记忆化搜索的思想" class="headerlink" title="记忆化搜索的思想"></a>记忆化搜索的思想</h3><pre><code>记忆化搜索的思想是,在搜索过程中，会有很多重复计算,如果我们能记录一些状态的答案，就可以减少重复搜索量 </code></pre><h3 id="记忆化搜索的适用范围"><a href="#记忆化搜索的适用范围" class="headerlink" title="记忆化搜索的适用范围"></a>记忆化搜索的适用范围</h3><pre><code>根据记忆化搜索的思想，它是解决重复计算，而不是重复生成，也就是说，这些搜索必须是在搜索扩展路径的过程中分步计算的题目，也就是“搜索答案与路径相关”的题目，而不能是搜索一个路径之后才能进行计算的题目，必须要分步计算，并且搜索过程中，一个搜索结果必须可以建立在同类型问题的结果上，也就是类似于动态规划解决的那种。 </code></pre><p>也就是说，他的问题表达，不是单纯生成一个走步方案，而是生成一个走步方案的代价等，而且每走一步，在搜索树/图中生成一个新状态，都可以精确计算出到此为止的费用，也就是，可以分步计算，这样才可以套用已经得到的答案</p><h3 id="记忆化搜索的核心实现"><a href="#记忆化搜索的核心实现" class="headerlink" title="记忆化搜索的核心实现"></a>记忆化搜索的核心实现</h3><pre><code> a. 首先，要通过一个表记录已经存储下的搜索结果，一般用哈希表实现  b.状态表示，由于是要用哈希表实现，所以状态最好可以用数字表示，常用的方法是把一个状态连写成一个p进制数字，然后把这个数字对应的十进制数字作为状态 c.在每一状态搜索的开始，高效的使用哈希表搜索这个状态是否出现过，如果已经做过，直接调用答案，回溯 d.如果没有，则按正常方法搜索 </code></pre><h3 id="记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"><a href="#记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。" class="headerlink" title="记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"></a>记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。</h3><h2 id="Function-Run-Fun"><a href="#Function-Run-Fun" class="headerlink" title="Function Run Fun"></a>Function Run Fun</h2><p>Description:<br>We all love recursion! Don’t we?</p><p>Consider a three-parameter recursive function w(a, b, c):</p><p>if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns: 1</p><p>if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns: w(20, 20, 20)</p><p>if a &lt; b and b &lt; c, then w(a, b, c) returns: w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)</p><p>otherwise it returns: w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)</p><p>This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.<br><code>Input</code><br>The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.<br><code>Output</code><br>Print the value for w(a,b,c) for each triple.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">10 4 6</span><br><span class="line">50 50 50</span><br><span class="line">-1 7 18</span><br><span class="line">-1 -1 -1</span><br><span class="line">Sample Output</span><br><span class="line">w(1, 1, 1) = 2</span><br><span class="line">w(2, 2, 2) = 4</span><br><span class="line">w(10, 4, 6) = 523</span><br><span class="line">w(50, 50, 50) = 1048576</span><br><span class="line">w(-1, 7, 18) = 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//注意数组越界问题</span><br><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 500;</span><br><span class="line">//int ans;</span><br><span class="line">//int dp[maxx];</span><br><span class="line">int mp[maxx][maxx][maxx];</span><br><span class="line">int w(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return 1;</span><br><span class="line">if(mp[a][b][c]) return mp[a][b][c];</span><br><span class="line">else if(a &gt; 20 || b &gt; 20 || c &gt; 20) return mp[a][b][c] = w(20, 20, 20);</span><br><span class="line">else if(a &lt; b &amp;&amp; b &lt; c) return mp[a][b][c] = w(a, b, c- 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);</span><br><span class="line">else return mp[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a, b, c;</span><br><span class="line">while(~scanf(&quot;%d %d %d&quot;,&amp;a, &amp;b, &amp;c))</span><br><span class="line">&#123;</span><br><span class="line">if(a == -1 &amp;&amp; b == -1 &amp;&amp; c== -1) break;</span><br><span class="line">printf(&quot;w(%d, %d, %d) = %d\n&quot;,a, b, c,w(a, b, c));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h2><p>Description:<br>Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。<br><code>Input</code><br>第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000)<br><code>Output</code><br>输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">9 1 2</span><br><span class="line">5 6 7</span><br><span class="line">8 4 3</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">Sample Input</span><br><span class="line">4 7</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">1 5 1 1 1 1 1</span><br><span class="line">1 4 3 1 1 1 1</span><br><span class="line">1 5 6 7 8 1 1</span><br><span class="line">Sample Output</span><br><span class="line">7</span><br><span class="line">hint</span><br><span class="line">样例1：7-&gt;6-&gt;4-&gt;3 长度为4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 200;</span><br><span class="line">int mp[maxx][maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int n , m; </span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">-1, 0,</span><br><span class="line">1, 0</span><br><span class="line">&#125;;</span><br><span class="line">int dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">//如果已经找过，退出此次搜索 </span><br><span class="line">if(dp[x][y]) return dp[x][y];</span><br><span class="line">int maxlen = 1;</span><br><span class="line">int len;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = x + d[i][0];</span><br><span class="line">int yy = y + d[i][1];</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; mp[xx][yy] &gt; mp[x][y])</span><br><span class="line">&#123;</span><br><span class="line">//能够遍历一次，步数+1 </span><br><span class="line">len = dfs(xx, yy) + 1;</span><br><span class="line">//不断比较，找该点所能够到达的最大长度 </span><br><span class="line">maxlen = max(maxlen, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y] = maxlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int ans;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(mp, 0, sizeof mp);</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">cin &gt;&gt; mp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">//便利搜索每一个点所能到达的最大距离并保存 </span><br><span class="line">dp[i][j] = dfs(i, j);</span><br><span class="line">//不断比较找出最大值 </span><br><span class="line">ans = max(ans, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="漫步校园"><a href="#漫步校园" class="headerlink" title="漫步校园"></a>漫步校园</h2><p>Description:<br>LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?<br><code>Input</code><br>每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。<br><code>Output</code><br>针对每组测试数据，输出总的路线数(小于2^63)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int x,y,c;</span><br><span class="line">bool friend operator &lt; (node a,node b)&#123;</span><br><span class="line">return a.c &gt; b.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;r,w;</span><br><span class="line">ll ma[330][330];</span><br><span class="line">int vis[330][330];</span><br><span class="line">ll dis[330][330];</span><br><span class="line">ll dp[330][330];  //记忆数组 要用long long  </span><br><span class="line">int Next[4][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;//bfs求终点到其余各点的最短路 </span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">r.x = r.y = n-1;r.c = ma[n-1][n-1];//以终点作为起点 </span><br><span class="line">dis[n-1][n-1] = ma[n-1][n-1];;</span><br><span class="line">vis[n-1][n-1] = 1;</span><br><span class="line">q.push(r);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">r = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">int nx = r.x + Next[i][0];</span><br><span class="line">int ny = r.y + Next[i][1];</span><br><span class="line">if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n || vis[nx][ny]) continue;</span><br><span class="line">w.x = nx;</span><br><span class="line">w.y = ny;</span><br><span class="line">w.c = r.c + ma[nx][ny];</span><br><span class="line">vis[nx][ny] = 1;</span><br><span class="line">q.push(w); </span><br><span class="line">dis[nx][ny] = w.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dfs(int x,int y)</span><br><span class="line">&#123;//dfs求最短路径条数 </span><br><span class="line">if(x == n-1 &amp;&amp; y == n-1)</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if(dp[x][y] != -1) return dp[x][y];</span><br><span class="line">dp[x][y] = 0;</span><br><span class="line">for(int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">int nx = x + Next[i][0];</span><br><span class="line">int ny = y + Next[i][1];</span><br><span class="line">if( nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n || dis[nx][ny] &gt;= dis[x][y]) continue;</span><br><span class="line">dp[x][y] += dfs(nx,ny);</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n)</span><br><span class="line">&#123; </span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j++)</span><br><span class="line">cin &gt;&gt; ma[i][j];</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof vis); </span><br><span class="line">memset(dp,-1,sizeof dp);</span><br><span class="line">bfs();</span><br><span class="line">cout &lt;&lt; dfs(0,0) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Free-Candies"><a href="#Free-Candies" class="headerlink" title="Free Candies"></a>Free Candies</h2><p>Description:<br>Little Bob is playing a game. He wants to win some candies in it - as many as possible. There are 4 piles, each pile contains N candies. Bob is given a basket which can hold at most 5 candies. Each time, he puts a candy at the top of one pile into the basket, and if there’re two candies of the same color in it, he can take both of them outside the basket and put them into his own pocket. When the basket is full and there are no two candies of the same color, the game ends. If the game is played perfectly, the game will end with no candies left in the piles. For example, Bob may play this game like this (N = 5):<br><img src="https://i.loli.net/2019/07/30/5d3fd1fb6077481048.png" alt><br>Note that diﬀerent numbers indicate diﬀerent colors, there are 20 kinds of colors numbered 1..20. ‘Seems so hard…’ Bob got very much puzzled. How many pairs of candies could he take home at most?<br><code>Input</code><br>The input will contain not more than 10 test cases. Each test case begins with a line containing a single integer n(1 ≤ n ≤ 40) representing the height of the piles. In the following n lines, each line contains four integers xi1, xi2, xi3, xi4 (in the range 1..20). Each integer indicates the color of the corresponding candy. The test case containing n = 0 will terminate the input, you should not give an answer to this case.<br><code>Output</code><br>Output the number of pairs of candies that the cleverest little child can take home. Print your answer in a single line for each test case.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 2 3 4 1 5 6 7 2 3 3 3 4 9 8 6 8 7 2 1 1 1 2 3 4 3 1 2 3 4 5 6 7 8 1 2 3 4 0</span><br><span class="line">Sample Output</span><br><span class="line">8 0 3</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int dp[55][55][55][55];   //记忆数组 </span><br><span class="line">bool Basket[555];//标记篮子内的糖果 </span><br><span class="line">int ma[5][55];//存糖果 </span><br><span class="line">int top[5];//记录取到第几个糖果 例如 top[0] = 1 表示已经取到了第0堆的第一个糖果 </span><br><span class="line">int dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[top[0]][top[1]][top[2]][top[3]] != -1) return dp[top[0]][top[1]][top[2]][top[3]];//判断是否搜索 </span><br><span class="line">if(x == 5) return 0;//如果篮子内糖果数为5  游戏结束 </span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(top[i] == n) continue;//top[i] == n 表示第i堆取完，continue即取下一堆 </span><br><span class="line"></span><br><span class="line">int now = ma[i][top[i]]; //now 表示即将要放入篮子的糖果 </span><br><span class="line">top[i]++;//top[i]++为下次取糖果准备，即下一次取第i堆的下一个糖果 </span><br><span class="line"></span><br><span class="line">if(Basket[now])</span><br><span class="line">&#123;//如果篮子中存在与即将要放入篮子的糖果相同的糖果 </span><br><span class="line">Basket[now] = 0;//从篮子中拿出糖果 </span><br><span class="line">ans = max(ans,dfs(x-1) + 1);//更新结果 </span><br><span class="line">Basket[now] = 1;//回溯 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Basket[now] = 1;//如果篮子中不存在这个糖果，将糖果放入篮子 </span><br><span class="line">ans = max(ans,dfs(x+1)) ;  //更新结果 </span><br><span class="line">Basket[now] = 0;//回溯 </span><br><span class="line">&#125;</span><br><span class="line">top[i]--;//回溯 </span><br><span class="line">&#125;</span><br><span class="line">return dp[top[0]][top[1]][top[2]][top[3]] = ans;  //记忆 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 4; j++)</span><br><span class="line">cin &gt;&gt; ma[j][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memset(dp,-1,sizeof dp);</span><br><span class="line">memset(Basket,0,sizeof Basket);</span><br><span class="line">memset(top,0,sizeof top);</span><br><span class="line">cout &lt;&lt; dfs(0) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h2><p>Description:<br>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.</p><p>For example, consider forming “tcraete” from “cat” and “tree”:</p><p>String A: cat<br>String B: tree<br>String C: tcraete</p><p>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming “catrtee” from “cat” and “tree”:</p><p>String A: cat<br>String B: tree<br>String C: catrtee</p><p>Finally, notice that it is impossible to form “cttaree” from “cat” and “tree”.<br><code>Input</code><br>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.</p><p><code>Output</code><br>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">cat tree tcraete</span><br><span class="line">cat tree catrtee</span><br><span class="line">cat tree cttaree</span><br><span class="line">Sample Output</span><br><span class="line">Data set 1: yes</span><br><span class="line">Data set 2: yes</span><br><span class="line">Data set 3: no</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">string str1, str2, str;</span><br><span class="line">bool pos;</span><br><span class="line">bool vis[maxx][maxx];</span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">//如果长度相同的话就回溯，表示结束 </span><br><span class="line">if(x == str1.length() &amp;&amp; y == str2.length())</span><br><span class="line">&#123;</span><br><span class="line">//能够都遍历表示可以 </span><br><span class="line">pos = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(str1[x] != str[z] &amp;&amp; str2[y] != str[z]) return;</span><br><span class="line">if(vis[x][y]) return;</span><br><span class="line">vis[x][y] = 1;</span><br><span class="line">if(str1[x] == str[z]) dfs(x + 1, y, z + 1); </span><br><span class="line">if(str2[y] == str[z]) dfs(x, y + 1, z + 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k = 1;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str;</span><br><span class="line">pos = 0;</span><br><span class="line">dfs(0, 0, 0);</span><br><span class="line">if(pos)</span><br><span class="line">printf(&quot;Data set %d: yes\n&quot;,k ++);</span><br><span class="line">else</span><br><span class="line">printf(&quot;Data set %d: no\n&quot;, k ++);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h2><p>Description:<br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br><code>Input</code><br>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.<br><code>Output</code><br>One integer per line representing the maximum of the total value (this number will be less than 2 31).<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5 10</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line">Sample Output</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e3 + 10;</span><br><span class="line">int w[maxx];</span><br><span class="line">int v[maxx];</span><br><span class="line">int s[maxx][maxx]; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, m;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">memset(s, 0, sizeof s);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i];//骨骼价值 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; //骨骼体积 </span><br><span class="line">//i表示第i个骨骼,j表示背包容量</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">//是否选择第i个就要看容量是否大于它的重量 </span><br><span class="line">if(j &gt;= w[i])</span><br><span class="line">&#123;</span><br><span class="line">//拿，那么就必须要占用当前背包的空间。即用当前背包总容量 j-w[i]，再占用1个物品空间，所以i-1，此时的总价值就是m [i-1][j-w[i]] 的解+当前的价值v[i] ，得到的就是放入当前物品得到的最优解。 </span><br><span class="line">s[i][j] = max(s[i - 1][j], s[i - 1][j-w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">//不拿，那么就还是上一步的解，m[i-1][j]</span><br><span class="line">s[i][j] = s[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s[n][m] &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h2><p>Description:<br>有一种游戏是的玩法是这样的：<br>有一个n*n的格子,每个格子有一个数字。<br>遵循以下规则:</p><ol><li>玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m</li><li>玩家一开始在第一行第一列，并且已经获得该格子的分值</li><li>玩家获得每一次移动到的格子的分值</li><li>玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。</li><li>游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围</li><li>玩家仅能在n*n的格子内移动，超出格子边界属于非法操作</li><li>当玩家不能再次移动时，游戏结束<br>现在问你，玩家所能获得的最大得分是多少？<br><code>Input</code><br>有多组测试数据<br>每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可<br>之后n行，每行n个数字，描述n*n的格子里的数字<br><code>Output</code><br>对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 1</span><br><span class="line">1 2 5</span><br><span class="line">10 11 6</span><br><span class="line">12 12 7</span><br><span class="line">-1 -1</span><br><span class="line">Sample Output</span><br><span class="line">37</span><br></pre></td></tr></table></figure></li></ol><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 200;</span><br><span class="line">int a[maxx][maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int m, n;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0</span><br><span class="line">&#125;;</span><br><span class="line">int dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[x][y]) return dp[x][y];</span><br><span class="line">int maxsorce = 0;</span><br><span class="line">int sorce;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = x + (d[i][0]) * j; </span><br><span class="line">int yy = y + (d[i][1]) * j;</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; a[xx][yy] &gt; a[x][y])</span><br><span class="line">&#123;</span><br><span class="line">sorce = dfs(xx, yy);</span><br><span class="line">maxsorce = max(sorce, maxsorce);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[x][y] = maxsorce + a[x][y];//回溯到x，y的最大和(顺序从大到小) </span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">if(n == -1 &amp;&amp; m == -1) break;</span><br><span class="line">for(int i = 0; i &lt; n ; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(0, 0);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dp[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1.关于移动问题：由于题中移动范围并不是1可以扩大到1*k所以仍然需要构造移动方向，只是需要dfs四周范围为k。 </span><br><span class="line">2.可以从最后一个节点往回遍历，也就是需要先找到最大的值，然后往回找，如何实现呢，用递归。但是需要标记路径不然会爆的。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="送披萨"><a href="#送披萨" class="headerlink" title="送披萨"></a>送披萨</h2><p>Description:<br>何老板开了一家披萨店，有一天突然收到了n个客户的订单。<br>何老板所在的城市只有一条笔直的大街，我们可以将它想象成数轴，其中位置0是何老板的披萨店，第i个客户所在的位置为Pi,每个客户的位置都不同。如果何老板给第i个客户送披萨，客户会支付Ei-Ti块钱，其中Ti是何老板到达他家的时刻。当然，如果到得太晚，会使得Ei-Ti＜0,这时，何老板可以选择不给他送餐，免得他反过来找何老板要钱。<br>何老板店里面只有一个送餐车（单位时间行驶单位长度的距离），因此只能往返送餐，如下图所示就是一条线路，图中第一行的数字是位置Pi,第二行是Ei。<br>你的任务是帮助何老板计算出最大的收益。<br><img src="https://i.loli.net/2019/07/30/5d3fd359c720210349.jpg" alt><br><code>Input</code><br>第一行，一个整数n<br>第二行，n个空格间隔的整数，从左往右给出了每个客户的位置Pi，即P1,P2,……,Pn<br>第三行，n个空格间隔的整数，从左往右给出了每个客户对应的Ei，即E1,E2,……,En<br><code>Output</code><br>一行，一个整数，表示所求的最佳收益。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">-6 -3 -1 2 5</span><br><span class="line"> 27 10 2 5 20</span><br><span class="line">Sample Output</span><br><span class="line">32</span><br><span class="line">Sample Input</span><br><span class="line">6</span><br><span class="line"> 1 2 4 7 11 14</span><br><span class="line"> 3 6 2 5 18 10</span><br><span class="line">Sample Output</span><br><span class="line">13</span><br><span class="line">Sample Input</span><br><span class="line">11</span><br><span class="line">-14 -13 -12 -11 -10 1 2 3 4 5 100</span><br><span class="line"> 200 200 200 200 200 200 200 200 200 200 200</span><br><span class="line">Sample Output</span><br><span class="line">1937</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1 ≤ n ≤ 100</span><br><span class="line">-100,000 ≤ Pi ≤ 100,000  且Pi!=0</span><br><span class="line"> 0＜ Ei ≤ 100,000</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[205][205][205][2];</span><br><span class="line">bool mark[205][205][205][2];</span><br><span class="line">int n;</span><br><span class="line">int pos[205],e[205],start;</span><br><span class="line">int dp(int l,int r,int cnt,int p)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(mark[l][r][cnt][p])return f[l][r][cnt][p];</span><br><span class="line">    mark[l][r][cnt][p]=true;</span><br><span class="line">    if(cnt==0)return f[l][r][cnt][p]=0;</span><br><span class="line">    if(p==0)&#123;</span><br><span class="line">        for(i=1;i&lt;l;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(i,r,cnt-1,0)+e[i]-cnt*abs(pos[l]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=r+1;i&lt;=n+1;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(l,i,cnt-1,1)+e[i]-cnt*abs(pos[l]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(i=1;i&lt;l;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(i,r,cnt-1,0)+e[i]-cnt*abs(pos[r]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=r+1;i&lt;=n+1;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(l,i,cnt-1,1)+e[i]-cnt*abs(pos[r]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[l][r][cnt][p];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,j,ans=0;</span><br><span class="line">    start=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;pos[i];</span><br><span class="line">        if(pos[i]&gt;0&amp;&amp;start==0)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            pos[i+1]=pos[i];</span><br><span class="line">            pos[i]=0;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;e[i];</span><br><span class="line">        if(start==i)&#123;</span><br><span class="line">            e[i+1]=e[i];</span><br><span class="line">            e[i]=0;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=max(ans,dp(start,start,i,0));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day12&quot;&gt;&lt;a href=&quot;#Day12&quot; class=&quot;headerlink&quot; title=&quot;Day12&quot;&gt;&lt;/a&gt;Day12&lt;/h1&gt;&lt;p&gt;今天学习的是 记忆化搜索(还是和dp有关)&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Day11</title>
    <link href="http://yoursite.com/2019/07/29/Day11/"/>
    <id>http://yoursite.com/2019/07/29/Day11/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-30T13:55:31.091Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --><h1 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h1><p>今天学习的是 动态规划(dp) + 最大字段和问题 + 最长公共子序列 + 编辑距离 + 最长递增子序列<br>重点还是动态规划(dp)</p><a id="more"></a><h2 id="动态规划简介："><a href="#动态规划简介：" class="headerlink" title="动态规划简介："></a>动态规划简介：</h2><p>动态规划：就是一个最优化问题，先将问题分解为子问题，并且对于这些分解的子问题自身就是最优的才能在这个基础上得出我们要解决的问题的最优方案，要不然的话就能找到一个更优的解来替代这个解，得出新的最优自问题，这当然是和前提是矛盾的。动态规划不同于 贪心算法，因为贪心算法是从局部最优来解决问题，而动态规划是全局最优的。用动态规划的时候不可能在子问题还没有得到最优解的情况下就做出决策，而是必须等待子问题得到了最优解之后才对当下的情况做出决策，所以往往动态规划都可以用 一个或多个递归式来描述。而贪心算法却是先做出一个决策，然后在去解决子问题。这就是贪心和动态规划的不同。<br>一般遇到一个动态规划类型的问题，都先要确定最优子结构，还有重叠子问题，这两个是动态规划最大的特征，然后就是要写 动态规划的状态方程，这个步骤十分十分的重要的，写动归方程是需要一定的经验的，这可以通过训练来达到目的。接着就是要自底向上的求解问题的，先将最小规模的子问题的最优解求出，一般都用一张表来记录下求得的解，到后来遇到同样的子问题的时候就可以直接查表得到答案，最后就是通过一步一步的迭代得出最后问题的答案了。<br>我的理解最重要的东西就是一定会要一个数组或者其他的存储结构存储得到的子问题的解。这样就可以省很多时间，也就是典型的空间换时间</p><h2 id="The-King’s-Ups-and-Downs"><a href="#The-King’s-Ups-and-Downs" class="headerlink" title="The King’s Ups and Downs"></a>The King’s Ups and Downs</h2><p>Description:<br>The king has guards of all different heights. Rather than line them up in increasing or decreasing height order, he wants to line them up so each guard is either shorter than the guards next to him or taller than the guards next to him (so the heights go up and down along the line). For example, seven guards of heights 160, 162, 164, 166, 168, 170 and 172 cm. could be arranged as:<br><img src="/2019/07/29/Day11/1.png" alt><br>or perhaps:<img src="/2019/07/29/Day11/2.png" alt><br>he king wants to know how many guards he needs so he can have a different up and down order at each changing of the guard for rest of his reign. To be able to do this, he needs to know for a given number of guards, n, how many different up and down orders there are:<br>For example, if there are four guards: 1, 2, 3,4 can be arrange as:<br>1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423<br>For this problem, you will write a program that takes as input a positive integer n, the number of guards and returns the number of up and down orders for n guards of differing heights.<br><code>Input</code><br>The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set consists of single line of input containing two integers. The first integer, D is the data set number. The second integer, n (1 &lt;= n &lt;= 20), is the number of guards of differing heights.<br><code>Output</code><br>For each data set there is one line of output. It contains the data set number (D) followed by a single space, followed by the number of up and down orders for the n guards.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 20</span><br><span class="line">Sample Output</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 10</span><br><span class="line">4 740742376475050</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=25;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll dp[maxn][maxn],ans[maxn];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">dp[1][1]=1;ans[1]=1;</span><br><span class="line">for(int i=2;i&lt;=20;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=2;k&lt;=i;k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][k]=dp[i-1][i+1-k]+dp[i][k-1];</span><br><span class="line">ans[i]+=dp[i][k];</span><br><span class="line">&#125;</span><br><span class="line">ans[i]*=2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int p,m,n;</span><br><span class="line">cin&gt;&gt;p;</span><br><span class="line">while(p--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="数塔"><a href="#数塔" class="headerlink" title="数塔"></a>数塔</h2><p>Description:<br>在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：<br>有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？<br><img src="/2019/07/29/Day11/3.png" alt><br>已经告诉你了，这是个DP的题目，你能AC吗?<br><code>Input</code><br>输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。<br><code>Output</code><br>对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br><span class="line">Sample Output</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1000;</span><br><span class="line">int a[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; i + 1; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = n - 2; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= i; j ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j] = max(a[i + 1][j], a[i + 1][j + 1]) + a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="母牛的故事"><a href="#母牛的故事" class="headerlink" title="母牛的故事"></a>母牛的故事</h2><p>Description:<br>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br><code>Input</code><br>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。<br><code>Output</code><br>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e7;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">a[1] = 1, a[2] = 2, a[3] = 3, a[4] = 4;</span><br><span class="line">for(int i = 5; i &lt; 55; i ++) a[i] = a[i - 1] + a[i - 3];</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="一只小蜜蜂…"><a href="#一只小蜜蜂…" class="headerlink" title="一只小蜜蜂…"></a>一只小蜜蜂…</h2><p>Description:<br>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。<br><img src="/2019/07/29/Day11/4.png" alt><br><code>Input</code><br>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。<br><code>Output</code><br>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e6;</span><br><span class="line">long long a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, x, y;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">a[0] = 1, a[1] = 1, a[2] = 2;</span><br><span class="line">for(int i = 3; i &lt; 60; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i - 1] + a[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; a[y - x] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="超级楼梯"><a href="#超级楼梯" class="headerlink" title="超级楼梯"></a>超级楼梯</h2><p>Description:<br>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？<br><code>Input</code><br>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。<br><code>Output</code><br>对于每个测试实例，请输出不同走法的数量<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e6;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">a[0] = 0;</span><br><span class="line">a[1] = 1;</span><br><span class="line">a[2] = 2;</span><br><span class="line">for(int i = 3; i &lt;= 40; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i - 1] + a[i - 2]; </span><br><span class="line">&#125;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; a[n - 1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Tickets"><a href="#Tickets" class="headerlink" title="Tickets"></a>Tickets</h2><p>Description:<br>现在有n个人要买电影票，如果知道每个人单独买票花费的时间，还有和前一个人一起买花费的时间，问最少花多长时间可以全部买完票。<br><code>Input</code><br>给出 N(1&lt;=N&lt;=10)，表示有N组样例 　　　　给出K (1&lt;=K&lt;=2000)，表示有K个人买票.. 　　　　给出K个数表示这个人单独买票会花的时间..保证每个数 (0s&lt;=Si&lt;=25s) 　　　　给出K-1个数，表示这个人和前面那个人一起买票会花的时间..保证每个数 (0s&lt;=Si&lt;=50s)<br><code>Output</code><br>对于每一组数据，你需要给出电影院售票结束的时间，售票开始的时间为 08:00:00 am. 时间格式为： HH:MM:SS am|pm. 具体看样例输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">20 25</span><br><span class="line">40</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">Sample Output</span><br><span class="line">08:00:40 am</span><br><span class="line">08:00:08 am</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=2005;</span><br><span class="line">int s[maxn],d[maxn],ans[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=k;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int j=2;j&lt;=k;j++)cin&gt;&gt;d[j];</span><br><span class="line">ans[1]=s[1];</span><br><span class="line">for(int i=2;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);</span><br><span class="line">&#125;</span><br><span class="line">int time=ans[k];int h,m,s;</span><br><span class="line">h=time/3600;</span><br><span class="line">m=time%3600/60;</span><br><span class="line">s=time%3600%60;</span><br><span class="line">h+=8;</span><br><span class="line">if(h&lt;=12)</span><br><span class="line">printf(&quot;%02d:%02d:%02d am\n&quot;,h,m,s);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%02d:%02d:%02d pm\n&quot;,h-12,m,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h2><p>Description:<br>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。<br><code>Input</code><br>每行只有一个正整数N，N小于32768。<br><code>Output</code><br>对应每个输入，输出兑换方法数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2934</span><br><span class="line">12553</span><br><span class="line">Sample Output</span><br><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int a[33005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">a[0] = 1;</span><br><span class="line">for(int i = 1; i &lt;= 3; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = i; j &lt;= 33000; j ++)</span><br><span class="line">&#123;</span><br><span class="line">a[j] = max(a[j], a[j] + a[j - i]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ignatius-and-the-Princess-IV"><a href="#Ignatius-and-the-Princess-IV" class="headerlink" title="Ignatius and the Princess IV"></a>Ignatius and the Princess IV</h2><p>Description:<br>给你n个数字，请你找出出现至少(n+1)/2次的数字。<br><code>输入</code><br>本题包含多组数据，请处理到EOF：<br>每组数据包含两行。<br>第一行一个数字N(1&lt;=N&lt;=999999) ，保证N为奇数。<br>第二行为N个用空格隔开的整数。<br><code>输出</code><br>对于每组数据，输出一行，表示要求找到的那个数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">1 3 2 3 3</span><br><span class="line">11</span><br><span class="line">1 1 1 1 1 5 5 5 5 5 5</span><br><span class="line">7</span><br><span class="line">1 1 1 1 1 1 1</span><br><span class="line">样例输出</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[1000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, t, ans;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">ans = 0;</span><br><span class="line">//遍历查找，如果数字相同，加一 </span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">a[t] ++;</span><br><span class="line">if(a[t] &gt;= (n + 1) / 2) ans = t;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="最少拦截系统"><a href="#最少拦截系统" class="headerlink" title="最少拦截系统"></a>最少拦截系统</h2><p>Description:<br>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.<br><code>Input</code><br>输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)<br><code>Output</code><br>对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">8 389 207 155 300 299 170 158 65</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXX=100000+5;</span><br><span class="line">const int INF=INT_MAX;</span><br><span class="line"></span><br><span class="line">int a[MAXX],dp[MAXX];</span><br><span class="line">// a数组为数据，dp[i]表示以a[i]结尾的最长递增子序列长度</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            dp[i]=1; // 初始化为1，长度最短为自身</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=1;</span><br><span class="line">        for(int i=1; i&lt;n; i++)//枚举子序列的终点</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0; j&lt;i; j++)//从头向终点检查每一个元素</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[i]&gt;a[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+1);  // 状态转移</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=max(ans,dp[i]);  // 比较每一个dp[i],最大值为答案</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:52 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day11&quot;&gt;&lt;a href=&quot;#Day11&quot; class=&quot;headerlink&quot; title=&quot;Day11&quot;&gt;&lt;/a&gt;Day11&lt;/h1&gt;&lt;p&gt;今天学习的是 动态规划(dp) + 最大字段和问题 + 最长公共子序列 + 编辑距离 + 最长递增子序列&lt;br&gt;重点还是动态规划(dp)&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Day10</title>
    <link href="http://yoursite.com/2019/07/27/Day10/"/>
    <id>http://yoursite.com/2019/07/27/Day10/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-28T13:55:33.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><p>今天是 又一次 <code>积分赛</code><br>我心态很好，真的很好，，，，真的很好。。。。</p><a id="more"></a><p><a href="https://hpuoj.com/contest/23/" target="_blank" rel="noopener">OJ</a></p><h2 id="再战斐波那契"><a href="#再战斐波那契" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h2><p><code>Problem Description</code><br>Description:<br>小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。<br>可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。<br>已知:<br><img src="https://i.loli.net/2019/07/28/5d3d9d5e7339863828.png" alt><br>输入格式<br>输入包括 T 组，T∈[1,10].<br>接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]).<br>输出格式<br>输出包含 T 行,每行输出一个整数.<br>样例<br><code>input</code><br>3<br>1 2<br>2 3<br>3 4<br><code>output</code><br>1<br>1<br>1</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//gcd(f(m),f(n)) = f(gcd(m,n))这个是规律</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a[1000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">ll x, y;</span><br><span class="line">a[2] = 1, a[1] = 1;</span><br><span class="line">for(int i = 3; i &lt;= 100; i ++) a[i] = a[i - 1] + a[i - 2];</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;x, &amp;y);</span><br><span class="line">printf(&quot;%lld\n&quot;,a[__gcd(x, y)]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="恐怖的怪物"><a href="#恐怖的怪物" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h2><p>Description:<br>一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。<br>此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。<br>上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。<br>如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。<br><img src="https://i.loli.net/2019/07/28/5d3d9e0943f8067086.png" alt><br>秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。<br>注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。<br>输入格式<br>第一行是一个T。（1≤T≤100）<br>接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。<br>输出格式<br>输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。<br>样例<br><code>input</code><br>2<br>2 3<br>0Y0<br>00#<br>3 4<br>R00#<br>00R0<br>0R00<br>output<br>No<br>Yes<br><code>input</code><br>2<br>1 5<br>0Y0R0<br>2 4<br>Y#0R<br>0000<br><code>output</code><br>Yes<br>No<br><code>input</code><br>1<br>5 4<br>Y0F0<br>0000<br>0000<br>0000<br>0000<br><code>output</code><br>No</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define pii pair&lt;int,int&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const ll INF=0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line"></span><br><span class="line">int t,n,m;</span><br><span class="line">char mp[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;</span><br><span class="line">queue&lt;pii&gt;H,F;</span><br><span class="line">queue&lt;pii&gt;que;</span><br><span class="line">void init()&#123;</span><br><span class="line">while(!que.empty()) que.pop();</span><br><span class="line">while(!H.empty()) H.pop();</span><br><span class="line">while(!F.empty()) F.pop();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">vis[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">while(!que.empty())&#123;</span><br><span class="line">int x=que.front().first;</span><br><span class="line">int y=que.front().second;</span><br><span class="line">que.pop();</span><br><span class="line">if(vis[x][y]==8) break;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=x+d[i][0];</span><br><span class="line">int yy=y+d[i][1];</span><br><span class="line">if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&apos;0&apos;) continue;</span><br><span class="line">vis[xx][yy]=vis[x][y]-1;</span><br><span class="line">que.push(pii(xx,yy));</span><br><span class="line">while(vis[xx][yy]==14 &amp;&amp; (!H.empty()))&#123;</span><br><span class="line">que.push(H.front());</span><br><span class="line">H.pop();</span><br><span class="line">&#125;</span><br><span class="line">while(vis[xx][yy]==12 &amp;&amp; (!F.empty()))&#123;</span><br><span class="line">que.push(F.front());</span><br><span class="line">F.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&apos;0&apos;) return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,mp[i]+1);</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">if(mp[i][j]==&apos;Y&apos;) que.push(pii(i,j)),vis[i][j]=15 ;//15</span><br><span class="line">if(mp[i][j]==&apos;H&apos;) H.push(pii(i,j)),vis[i][j]=14;//14</span><br><span class="line">if(mp[i][j]==&apos;F&apos;) F.push(pii(i,j)),vis[i][j]=12;//12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(BFS()) printf(&quot;No\n&quot;);</span><br><span class="line">else printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h2><p>Description:<br>众所周知，《连连看》是一个老少皆宜的游戏。<br>《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。<br>现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。<br>由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。<br>输入格式<br>第一行输入个T,表示T组数据（1≤t≤100）<br>每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）<br>接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。<br>每种棋子只会出现一对，因此数据保证只有一种有效结果。<br>输出格式<br>每组数据输出一行。<br>如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。<br>样例<br><code>input</code><br>3<br>2 2<br>1 2<br>2 1<br>3 4<br>1 6 2 3<br>4 5 3 1<br>4 2 6 5<br>4 4<br>1 2 3 6<br>8 4 7 8<br>5 6 5 7<br>1 2 3 4<br><code>output</code><br>No<br>No<br>Yes</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int mp[200][200];</span><br><span class="line">int n,m;</span><br><span class="line">int sx,sy;</span><br><span class="line">int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//分别对应下，右，左，上</span><br><span class="line">int check(int x,int y)&#123;</span><br><span class="line">if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1)</span><br><span class="line">return 1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int x,int y,int step,int pos)&#123;//pos表示上一步方向</span><br><span class="line">if(step&gt;3) return 0;//如果超过了三步，不符合规则</span><br><span class="line">if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1)&#123;//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等）</span><br><span class="line">mp[x][y]=0;//删去配对字符 </span><br><span class="line">mp[sx][sy]=0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则 </span><br><span class="line">int i,x1,y1;</span><br><span class="line">for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上)   (1.右 2.左)</span><br><span class="line">x1=x+dir[i][0];</span><br><span class="line">y1=y+dir[i][1];</span><br><span class="line">if(check(x1,y1)) continue;//检查是否越界 </span><br><span class="line">if(judge(x1,y1,step+(pos==i?0:1),i))&#123;//找到一个就返回 </span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,times,sum;</span><br><span class="line">int i,j;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">memset(mp,0,sizeof(mp));</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;mp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum=0;</span><br><span class="line">times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到 </span><br><span class="line">i=j=1;</span><br><span class="line">while(sum&lt;n*m &amp;&amp; times&lt;n*m)&#123;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">times++;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1))&#123;</span><br><span class="line">sum+=2;</span><br><span class="line">times=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(sum==n*m)&#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Points-in-rectangle"><a href="#Points-in-rectangle" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h2><p>Description:<br>在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。<br>输入格式<br>第一行输入n,a(1≤a\&lt;n≤1e3)。<br>第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。<br>输出格式<br>第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。<br>样例<br><code>input</code><br>6 1<br>5<br>1 2<br>1 3<br>2 3<br>3 4<br>4 5<br><code>output</code><br>4<br>4 5<br>3 4<br>2 3<br>1 2</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, a;</span><br><span class="line">int m;</span><br><span class="line">struct node&#123;</span><br><span class="line">int xo, yo;</span><br><span class="line">&#125;biao[10001];</span><br><span class="line">node biao1[10001];</span><br><span class="line">int cmp(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">if(a.xo == b.xo) return a.yo &gt; b.yo;</span><br><span class="line">return a.xo &gt; b.xo;</span><br><span class="line">&#125;</span><br><span class="line">int cnt;</span><br><span class="line">bool solve(node point)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return point.yo &gt;= -point.xo + a &amp;&amp; point.yo &gt;= point.xo - a &amp;&amp; point.yo &lt;= point.xo + a &amp;&amp; point.yo &lt;= -point.xo + 2 * n - a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; a &gt;&gt; m;</span><br><span class="line">cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; biao[i].xo &gt;&gt; biao[i].yo;</span><br><span class="line">if(solve(biao[i]))</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">biao1[i].xo = biao[i].xo;</span><br><span class="line">biao1[i].yo = biao[i].yo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(biao1, biao1 + m, cmp);</span><br><span class="line">if(cnt == 0) puts(&quot;-1&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">for(int i = 0; i &lt; cnt; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; biao1[i].xo &lt;&lt; &quot; &quot; &lt;&lt; biao1[i].yo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>code2:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e3+100;</span><br><span class="line">struct point&#123;</span><br><span class="line">long long x,y;</span><br><span class="line">bool friend operator&lt;(point a,point b)&#123;</span><br><span class="line">if(a.x==b.x) return a.y&gt;b.y;</span><br><span class="line">return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">long long n,a;</span><br><span class="line">bool check(point P)&#123;</span><br><span class="line">return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//freopen(&quot;17.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//freopen(&quot;17.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">vector&lt;point&gt; re;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">int m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">if(check(p[i])) re.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(re.begin(),re.end());</span><br><span class="line">if(re.empty())&#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;re.size()&lt;&lt;endl;</span><br><span class="line">for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&apos; &apos;&lt;&lt;v.y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Numbers-of-interval"><a href="#Numbers-of-interval" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h2><p>Description:<br><img src="https://i.loli.net/2019/07/28/5d3da6d6aee4330530.png" alt></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e6;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a[maxx];</span><br><span class="line">ll b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">b[i] = a[i] + b[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">ll ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int pos = lower_bound(b + 1, b + n + 1, k + b[i - 1]) - b;</span><br><span class="line">ans += (n - pos + 1);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这题很巧妙，利用了前缀和与二分查找中的lower_bound</span><br><span class="line">首先是前缀和，不断相加前面每一个数的值，(比普通的定义一个变量相加更好用)存值，方便后便用到 </span><br><span class="line">找到第一个大于等于要求数的值，然后后边的数肯定都大，只要计数就行了 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="剪纸"><a href="#剪纸" class="headerlink" title="剪纸"></a>剪纸</h2><p>Description:<br>中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。<br>2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。<br>剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：<br><img src="https://i.loli.net/2019/07/28/5d3da765b1bc845726.png" alt><br>假设剪后的形状为一个三角形，则展开效果为：<br><img src="https://i.loli.net/2019/07/28/5d3da7671a20c72428.png" alt><br>现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。<br>输入格式<br>多组输入，处理到文件结束。<br>每组输入第一行两个数字n,m（1≤n,m≤100)。<br>接下来n行，每行m个字符，表示对折且剪切后的图形。<br>保证输入字符只包含 ‘.’ 和 ‘<em>’ 。<br>输出格式<br>输出展开后的图形。<br>样例<br><code>input</code><br>3 3<br>**. </em>..<br>…<br><code>output</code><br>……<br>..<strong>..<br>.**</strong>.<br>.<strong>**.<br>..</strong>..<br>……</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//F</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1000+10;</span><br><span class="line">char mmp[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(mmp, &apos;.&apos;, sizeof mmp);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; mmp[i][j];</span><br><span class="line">if(mmp[i][j] == &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">mmp[i + n][j + m] = &apos;*&apos;;</span><br><span class="line">mmp[i][j] = &apos;.&apos;;</span><br><span class="line">&#125;</span><br><span class="line">//cout &lt;&lt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">//puts(&quot;&quot;);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">&#125;    </span><br><span class="line">for(int i = 0; i &lt; n * 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m * 2; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(mmp[i][j] != &apos;*&apos;) mmp[i][j] = &apos;.&apos;;</span><br><span class="line">if(mmp[i][j] == &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">mmp[2 * n - i - 1][j] = &apos;*&apos;;</span><br><span class="line">mmp[i][2 * m - j - 1] = &apos;*&apos;;</span><br><span class="line">mmp[2 * n - i - 1][2 * m - j - 1] = &apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 2 * n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 2 * m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Fake-hpuoj-predictor"><a href="#Fake-hpuoj-predictor" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h2><p>Description:<br>总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。<br>具体算法为：<br><img src="https://i.loli.net/2019/07/28/5d3da85871d0767682.png" alt><br>其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。<br>本场比赛的积分公式即为<br><img src="https://i.loli.net/2019/07/28/5d3da86c66e9925370.png" alt><br>RA代表上轮比赛结束后的积分。<br>K为积分系数,对于不同等级的选手的K是不同的。<br>SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。<br>EAi代表A与第i个选手比赛获胜的期望。<br>对于HPU Online Judge，用户等级表为:<br><img src="https://i.loli.net/2019/07/28/5d3da86da0dab96224.png" alt><br>codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。<br>那么最终codancer打完本场比赛后的rating为<br><img src="https://i.loli.net/2019/07/28/5d3da878ae7f273328.png" alt><br>现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。<br>输入格式<br>单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。<br>接下来对于每场比赛：<br>第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。<br>接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。<br>输出格式<br>输出codancer最终的rating，向上取整。<br>样例<br><code>input</code><br>3<br>5<br>tourist 2000<br>capryang 1900<br>boctorio 1800<br>dicer 1800<br>codancer<br>2<br>codancer<br>rookie 200<br>2<br>wzy 1500<br>codancer<br><code>output</code><br>12</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line">int n,m,a;</span><br><span class="line">struct node&#123;</span><br><span class="line">char name[30];</span><br><span class="line">double rating;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">double cal(double rating)&#123;</span><br><span class="line">if(rating&lt;1350) return 15.0;</span><br><span class="line">else if(rating&lt;1500) return 20.0;</span><br><span class="line">else if(rating&lt;1600) return 25.0;</span><br><span class="line">else if(rating&lt;1700) return 30.0;</span><br><span class="line">else if(rating&lt;1800) return 35.0;</span><br><span class="line">else return 50.0;</span><br><span class="line">&#125;</span><br><span class="line">double Rating(double rating)&#123;</span><br><span class="line">double k=cal(rating);</span><br><span class="line">double ea=0,sa=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue; </span><br><span class="line">ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0));</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">sa=n-1-i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">double now_rating=rating+k*(sa-ea);</span><br><span class="line">//return now_rating;</span><br><span class="line">return ceil(now_rating);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">double codancerNB_rating=0.0;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,p[i].name);</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">p[i].rating=codancerNB_rating;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%lf&quot;,&amp;p[i].rating);</span><br><span class="line">&#125;</span><br><span class="line">codancerNB_rating=Rating(codancerNB_rating);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="花花与三猫Catlive"><a href="#花花与三猫Catlive" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h2><p>Description:<br>“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的：<br>游戏刚开始的时候，中分和李白相距L步，相对而望。<br>老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等）<br>在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。<br>当老父亲的骰子掷到1的时候，中分可以向李白走一步。<br>当老母亲的骰子掷到m的时候，李白可以向中分走一步。<br>当中分和李白相遇的时候，游戏结束。<br>可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？<br>结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。<br>输入格式<br>第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。<br>接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。<br>输出格式<br>输出包括T行，每行一个答案。<br>样例<br><code>input</code><br>2<br>1 2<br>2 1<br><code>output</code><br>1<br>1</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MOD = 1e9 + 7;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    int L, M;</span><br><span class="line">    while(T--)</span><br><span class="line">&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>code2:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//为啥多了几行，学长的意思是打cf的，防止被hack，哈哈</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">const int MOD = 1e9 + 7;</span><br><span class="line">int qpow(int a, int b, int mod)&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res = 1LL * res * a % mod;</span><br><span class="line">        a = 1LL * a * a % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int inv(int p, int mod)&#123;</span><br><span class="line">    return qpow(p, mod - 2, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    int L, M;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Same-String"><a href="#Same-String" class="headerlink" title="Same String"></a>Same String</h2><p>Description:<br>有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。<br>输入格式<br>第一行输入一个n(1≤n≤100)，代表字符串的长度。<br>第二行和第三行输入两个字符串s1,s2。<br>第四行输入一个m(1≤m≤325)，代表有m组关系。<br>接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。<br>输出格式<br>如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。<br>样例<br><code>input</code><br>6<br>aabbcc<br>cdbcad<br>4<br>a c<br>c a<br>a d<br>b c<br><code>output</code><br>YES</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">typedef long long ll;</span><br><span class="line">bool f[26][26];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,m;</span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">char u,v;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">f[u-&apos;a&apos;][v-&apos;a&apos;]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;26;j++)&#123;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">for(int k=0;k&lt;26;k++)&#123;</span><br><span class="line">f[i][k]|=(f[i][j]&amp;f[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool check=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(s1[i]!=s2[i])&#123;</span><br><span class="line">if(f[s1[i]-&apos;a&apos;][s2[i]-&apos;a&apos;]==0)&#123;</span><br><span class="line">check=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(check)&#123;</span><br><span class="line">puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">// &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day10&quot;&gt;&lt;a href=&quot;#Day10&quot; class=&quot;headerlink&quot; title=&quot;Day10&quot;&gt;&lt;/a&gt;Day10&lt;/h1&gt;&lt;p&gt;今天是 又一次 &lt;code&gt;积分赛&lt;/code&gt;&lt;br&gt;我心态很好，真的很好，，，，真的很好。。。。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Day9</title>
    <link href="http://yoursite.com/2019/07/26/Day9/"/>
    <id>http://yoursite.com/2019/07/26/Day9/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-27T15:04:15.774Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h1><p>今天是 dfs 和 bfs 加训<br>继续学习 dfs 和 bfs，毕竟这一块还是非常重要的</p><a id="more"></a><p>OJ链接：<a href="https://vjudge.net/contest/314510#overview" target="_blank" rel="noopener">https://vjudge.net/contest/314510#overview</a></p><h2 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h2><p><code>Problem Description</code><br>Background<br>Mr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?<br>The Problem<br>Your task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.<br>For people not familiar with chess, the possible knight moves are shown in Figure 1.<br><img src="https://i.loli.net/2019/07/27/5d3c67890610a60979.jpg" alt></p><p><code>Input</code><br>The input begins with the number n of scenarios on a single line by itself.<br>Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l <em>l. The second and third line contain pair of integers {0, …, l-1}</em>{0, …, l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.<br><code>Output</code><br>For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">0 0</span><br><span class="line">7 0</span><br><span class="line">100</span><br><span class="line">0 0</span><br><span class="line">30 50</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">Sample Output</span><br><span class="line">5</span><br><span class="line">28</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">int c, d;</span><br><span class="line">int ans, n;</span><br><span class="line">int vis[400][400];</span><br><span class="line">int dd[8][2] = &#123;</span><br><span class="line">-2, 1,</span><br><span class="line">-1, 2,</span><br><span class="line">1, 2,</span><br><span class="line">2, 1,</span><br><span class="line">-2, -1,</span><br><span class="line">-1, -2,</span><br><span class="line">1, -2,</span><br><span class="line">2, -1</span><br><span class="line">&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, step; </span><br><span class="line">&#125;;</span><br><span class="line">void bfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = x, e1.y = y, e1.step = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == c &amp;&amp; e1.y == d)</span><br><span class="line">&#123;</span><br><span class="line">ans = e1.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 8; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + dd[i][0];</span><br><span class="line">e2.y = e1.y + dd[i][1];</span><br><span class="line">if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; n &amp;&amp; vis[e2.x][e2.y] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[e2.x][e2.y] = 1;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">int a, b;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">bfs(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="变形课"><a href="#变形课" class="headerlink" title="变形课"></a>变形课</h2><p><code>Problem Description</code><br>呃……变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.<br>Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.<br><code>Input</code><br>测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.<br><code>Output</code><br>如果Harry可以完成他的作业,就输出”Yes.”,否则就输出”No.”(不要忽略了句号)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">so</span><br><span class="line">soon</span><br><span class="line">river</span><br><span class="line">goes</span><br><span class="line">them</span><br><span class="line">got</span><br><span class="line">moon</span><br><span class="line">begin</span><br><span class="line">big</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Yes.</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">Harry 可以念这个咒语:&quot;big-got-them&quot;.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">string ss;</span><br><span class="line">bool vis[1000 + 10];</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">int flag;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;a[1000 + 10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(a[x].y == &apos;m&apos;)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = 0; j &lt; i; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[x].y == a[j].x &amp;&amp; vis[j] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">dfs(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">flag = 0;</span><br><span class="line">i = 0;</span><br><span class="line">while(cin &gt;&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">if(ss[0] != &apos;0&apos;)</span><br><span class="line">&#123;</span><br><span class="line">a[i].x = ss[0];</span><br><span class="line">a[i].y = ss[ss.size() - 1];</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">for(int j = 0; j &lt; i; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[j].x == &apos;b&apos;)</span><br><span class="line">&#123;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">dfs(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;Yes.&quot;);</span><br><span class="line">else puts(&quot;No.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Pet"><a href="#Pet" class="headerlink" title="Pet"></a>Pet</h2><p><code>Problem Description</code><br>一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。<br><code>Input</code><br>输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。<br><code>Output</code><br>对于每组数据，输出可能找到仓鼠的站点数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">10 2</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 8</span><br><span class="line">6 9</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">bfs解法:</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int n, d;</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(0);</span><br><span class="line">vis[0] = 1;</span><br><span class="line">dis[0] = 0;</span><br><span class="line">int cnt = 0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[f] &gt; d)</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(vis[v[f][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">dis[v[f][i]] = dis[f] + 1;</span><br><span class="line">vis[v[f][i]] = 1;</span><br><span class="line">q.push(v[f][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//ios::sync_with_stdio(false);</span><br><span class="line">int T;</span><br><span class="line">int a, b;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;T))</span><br><span class="line">&#123;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;d);</span><br><span class="line">for(int i = 0; i &lt; n; i ++) v[i].clear();</span><br><span class="line">for(int i = 0;i &lt; n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a, &amp;b);</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs解法:</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1e5 + 50 ;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;G[maxn] ;</span><br><span class="line">int ans ;</span><br><span class="line">int n ,m ; </span><br><span class="line">int vis[maxn] ;</span><br><span class="line"></span><br><span class="line">void dfs(int st ,int l)</span><br><span class="line">&#123;</span><br><span class="line">if ( l &gt; m ) ans ++ ;</span><br><span class="line">int len = G[st].size() ;</span><br><span class="line">for (int i = 0 ; i &lt; len ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">if ( !vis[G[st][i]] )</span><br><span class="line">&#123;</span><br><span class="line">dfs(G[st][i] ,l + 1 ) ;</span><br><span class="line">vis[G[st][i]] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int t ; </span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;t)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">while ( t -- )</span><br><span class="line">&#123;</span><br><span class="line">ans = 0 ;</span><br><span class="line">int a ,b ;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n ,&amp;m);</span><br><span class="line">for (int i = 0 ; i &lt;= n ; i ++ ) G[i].clear() ,vis[i] = 0 ;</span><br><span class="line">for (int i = 1 ; i &lt;= n - 1 ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a ,&amp;b ) ;</span><br><span class="line">G[a].push_back(b) ;</span><br><span class="line">//G[b].push_back(a) ;</span><br><span class="line">&#125;</span><br><span class="line">dfs(0 ,0 ) ;</span><br><span class="line">printf(&quot;%d\n&quot;,ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h2><p><code>Problem Description</code><br>蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。<br><code>Input</code><br>第一个输入数据是T，表示数据的组数。<br>每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。<br><code>Output</code><br>对应每组数据输出最小移动距离。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Sample Output</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">思路：桶排原理记录每张牌的位置，遍历每张牌，枚举所有可能位置。</span><br><span class="line">将牌的大小作为下标。然后依次遍历。。。</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX = 0x3f3f3f3f;</span><br><span class="line">char a[100];</span><br><span class="line">char visit[100];</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line">void dfs(int num, int sum)</span><br><span class="line">&#123;</span><br><span class="line">    if (num==9)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sum&lt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(visit[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i] = 1;</span><br><span class="line">            for(int j=i+1; j&lt;=10; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(visit[j]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(num+1, sum + abs(a[j]-a[i]));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visit[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T, x;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1; i&lt;=10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            a[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(visit, 0, sizeof(visit));</span><br><span class="line">        ans = MAX;</span><br><span class="line">        dfs(0, 0);</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h2><p><code>Problem Description</code><br>给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？<br><code>Input</code><br>第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。<br><code>Output</code><br>每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 5</span><br><span class="line">...**</span><br><span class="line">*.**.</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">*....</span><br><span class="line">1 1 1 1 3</span><br><span class="line">5 5</span><br><span class="line">...**</span><br><span class="line">*.**.</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">*....</span><br><span class="line">2 1 1 1 3</span><br><span class="line">Sample Output</span><br><span class="line">no</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e2 + 10;</span><br><span class="line">int n, m, a1, b1, a2, b2, k;</span><br><span class="line">char a[maxx][maxx];</span><br><span class="line">bool vis[maxx][maxx];</span><br><span class="line">int flag;</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0,</span><br><span class="line">0, 1,</span><br><span class="line">0, -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2, e3;</span><br><span class="line">e1.x = a1 - 1, e1.y = b1 - 1, e1.step = -1;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == a2 - 1 &amp;&amp; e1.y == b2 - 1 &amp;&amp; e1.step &lt;= k)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">while(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; a[e2.x][e2.y] == &apos;.&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(vis[e2.x][e2.y] == 0)</span><br><span class="line">&#123;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">vis[e2.x][e2.y] = 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">e3.x = e2.x + d[i][0];</span><br><span class="line">e3.y = e2.y + d[i][1];</span><br><span class="line">e2 = e3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T); </span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d %d %d %d %d&quot;,&amp;k, &amp;b1, &amp;a1, &amp;b2, &amp;a2);</span><br><span class="line">flag = 0;</span><br><span class="line">bfs();</span><br><span class="line">if(flag) puts(&quot;yes&quot;);</span><br><span class="line">else puts(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Kaitou-Kid-The-Phantom-Thief-2"><a href="#Kaitou-Kid-The-Phantom-Thief-2" class="headerlink" title="Kaitou Kid - The Phantom Thief (2)"></a>Kaitou Kid - The Phantom Thief (2)</h2><p><code>Problem Description</code><br>破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。<br><code>Input</code><br>输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：</p><p>‘S’：入口<br>‘E’：出口<br>‘J’：放有宝石的区域，至少出现一次<br>‘.’：空白区域<br>‘#’：墙<br><code>Output</code><br>对每组测试数据，输出至少要封锁的区域数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 5 5</span><br><span class="line">SJJJJ</span><br><span class="line">..##J</span><br><span class="line">.JJJJ</span><br><span class="line">.J...</span><br><span class="line">EJ...</span><br><span class="line">5 5 6</span><br><span class="line">SJJJJ</span><br><span class="line">..##J</span><br><span class="line">.JJJJ</span><br><span class="line">.J...</span><br><span class="line">EJ...</span><br><span class="line">Sample Output</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char mapp[10][10];</span><br><span class="line">int visit[10][10];</span><br><span class="line">int dir[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">int n,m,o;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">int flag;</span><br><span class="line"></span><br><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">int d;</span><br><span class="line">int flag;</span><br><span class="line">&#125;;</span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(visit,0,sizeof(visit));</span><br><span class="line">stu x,y;</span><br><span class="line">queue&lt;stu&gt;root;</span><br><span class="line">x.x=sx;x.y=sy;x.flag=1;x.d=0;</span><br><span class="line">visit[x.x][x.y]=1;</span><br><span class="line">root.push(x);</span><br><span class="line">while(root.size())</span><br><span class="line">&#123;</span><br><span class="line">x=root.front();</span><br><span class="line">root.pop();</span><br><span class="line">if(x.x==ex&amp;&amp;x.y==ey&amp;&amp;x.flag==2&amp;&amp;x.d&lt;=o) return 0;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">y.x=x.x+dir[i][0];</span><br><span class="line">y.y=x.y+dir[i][1];</span><br><span class="line">y.d=x.d+1;</span><br><span class="line">if(mapp[y.x][y.y]==&apos;J&apos;) y.flag=2;</span><br><span class="line">else y.flag=x.flag;</span><br><span class="line">if(y.x&lt;0||y.x&gt;=n||y.y&lt;0||y.y&gt;=m||visit[y.x][y.y]==y.flag||mapp[y.x][y.y]==&apos;#&apos;||y.d&gt;o) continue;</span><br><span class="line">visit[y.x][y.y]=y.flag;</span><br><span class="line">root.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(bfs()) flag=1;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">char ma=mapp[i][j];</span><br><span class="line">if(ma==&apos;.&apos;||ma==&apos;J&apos;)</span><br><span class="line">&#123;</span><br><span class="line">mapp[i][j]=&apos;#&apos;;</span><br><span class="line">if(x&gt;0) dfs(x-1);</span><br><span class="line">if(flag) return;</span><br><span class="line">mapp[i][j]=ma;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin.sync_with_stdio(false);</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;o;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;mapp[i][j];</span><br><span class="line">if(mapp[i][j]==&apos;S&apos;) sx=i,sy=j;</span><br><span class="line">if(mapp[i][j]==&apos;E&apos;) ex=i,ey=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">flag=0;</span><br><span class="line">re=1&lt;&lt;30;</span><br><span class="line">for(int i=0;i&lt;=4;i++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i);</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A计划"><a href="#A计划" class="headerlink" title="A计划"></a>A计划</h2><p><code>Problem Description</code><br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用<em>表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br><code>Input</code><br>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N</em>M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N<em>M表示迷宫的第一层的布置情况，后N</em>M表示迷宫第二层的布置情况。<br><code>Output</code><br>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5 5 14</span><br><span class="line">S*#*.</span><br><span class="line">.#...</span><br><span class="line">.....</span><br><span class="line">****.</span><br><span class="line">...#.</span><br><span class="line"></span><br><span class="line">..*.P</span><br><span class="line">#.*..</span><br><span class="line">***..</span><br><span class="line">...*.</span><br><span class="line">*.#..</span><br><span class="line">Sample Output</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">int n, m, p;</span><br><span class="line">int ans;</span><br><span class="line">char a[2][30][30];</span><br><span class="line">bool vis[2][30][30];</span><br><span class="line">//int step[2][30][30];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">int t;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.t &gt; b.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = 0, e1.y = 0, e1.z = 0, e1.t = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y][e1.z] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.z == e.z &amp;&amp; e1.x == e.x &amp;&amp; e1.y == e.y)</span><br><span class="line">&#123;</span><br><span class="line">return e1.t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">e2.z = e1.z;</span><br><span class="line">if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; vis[e2.z][e2.x][e2.y] == 0 &amp;&amp; a[e2.z][e2.x][e2.y] != &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(a[e2.z][e2.x][e2.y] == &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">e2.z = 1 - e2.z;</span><br><span class="line">if(a[e2.z][e2.x][e2.y] == &apos;*&apos; || a[e2.z][e2.x][e2.y] == &apos;#&apos;) continue;</span><br><span class="line">&#125;</span><br><span class="line">e2.t = e1.t + 1;</span><br><span class="line">if(e2.t &gt; p) continue;//必须剪枝 </span><br><span class="line">q.push(e2);</span><br><span class="line">vis[e2.z][e2.x][e2.y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(int k = 0; k &lt; m; k ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j][k];</span><br><span class="line">if(a[i][j][k] == &apos;P&apos;)</span><br><span class="line">&#123;</span><br><span class="line">e.z = i;</span><br><span class="line">e.x = j;</span><br><span class="line">e.y = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = bfs();</span><br><span class="line">//cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">if(ans != -1 &amp;&amp; ans &lt;= p) puts(&quot;YES&quot;);</span><br><span class="line">else puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a>Nightmare</h2><p><code>Problem Description</code><br>Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.</p><p>Given the layout of the labyrinth and Ignatius’ start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.</p><p>Here are some rules:</p><ol><li>We can assume the labyrinth is a 2 array.</li><li>Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.</li><li>If Ignatius get to the exit when the exploding time turns to 0, he can’t get out of the labyrinth.</li><li>If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can’t use the equipment to reset the bomb.</li><li>A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.</li><li>The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.<br><code>Input</code><br>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.<br>There are five integers which indicate the different type of area in the labyrinth:<br>0: The area is a wall, Ignatius should not walk on it.<br>1: The area contains nothing, Ignatius can walk on it.<br>2: Ignatius’ start position, Ignatius starts his escape from this position.<br>3: The exit of the labyrinth, Ignatius’ target position.<br>4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.<br><code>Output</code><br>For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">3 3</span><br><span class="line">2 1 1</span><br><span class="line">1 1 0</span><br><span class="line">1 1 3</span><br><span class="line">4 8</span><br><span class="line">2 1 1 0 1 1 1 0</span><br><span class="line">1 0 4 1 1 0 4 1</span><br><span class="line">1 0 0 0 0 0 0 1</span><br><span class="line">1 1 1 4 1 1 1 3</span><br><span class="line">5 8</span><br><span class="line">1 2 1 1 1 1 1 4 </span><br><span class="line">1 0 0 0 1 0 0 1 </span><br><span class="line">1 4 1 0 1 1 0 1 </span><br><span class="line">1 0 0 0 0 3 0 1 </span><br><span class="line">1 1 4 1 1 1 1 1 </span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">13</span><br></pre></td></tr></table></figure></li></ol><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a[10][10];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step,time;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">int ans;</span><br><span class="line">node now,mid;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(now.time&lt;=0)continue;</span><br><span class="line">if(a[now.x][now.y]==3)</span><br><span class="line">&#123;</span><br><span class="line">ans=now.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">mid.time=now.time-1;</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0)continue;</span><br><span class="line">if(a[mid.x][mid.y]==4)</span><br><span class="line">&#123;</span><br><span class="line">a[mid.x][mid.y]=0;</span><br><span class="line">mid.time=6;</span><br><span class="line">&#125;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">if(a[i][j]==2)</span><br><span class="line">&#123;</span><br><span class="line">now.x=i,now.y=j,now.step=0,now.time=6;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="胜利大逃亡"><a href="#胜利大逃亡" class="headerlink" title="胜利大逃亡"></a>胜利大逃亡</h2><p><code>Problem Description</code><br>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><img src="https://i.loli.net/2019/07/27/5d3c67ba74b7b52137.jpg" alt><br><code>Input</code><br>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p><p>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.<br><code>Output</code><br>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">3 3 4 20</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br><span class="line">Sample Output</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,k;</span><br><span class="line">int s[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,z,step;</span><br><span class="line">&#125;;</span><br><span class="line">node mz,mid,ne;</span><br><span class="line">int d[6][3]=&#123;1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1&#125;,ans;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">mz.x=mz.y=mz.z=mz.step=0;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(mz);</span><br><span class="line">vis[0][0][0]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(mid.step&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">return  ;</span><br><span class="line">&#125;</span><br><span class="line">if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line">ans=mid.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)</span><br><span class="line">&#123;</span><br><span class="line">ne.x=mid.x+d[i][0];</span><br><span class="line">ne.y=mid.y+d[i][1];</span><br><span class="line">ne.z=mid.z+d[i][2];</span><br><span class="line">if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1)</span><br><span class="line">continue;</span><br><span class="line">ne.step=mid.step+1;</span><br><span class="line">vis[ne.x][ne.y][ne.z]=1;</span><br><span class="line">q.push(ne);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=-1;</span><br><span class="line">scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;c;k++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%1d&quot;,&amp;s[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A-strange-lift"><a href="#A-strange-lift" class="headerlink" title="A strange lift"></a>A strange lift</h2><p><code>Problem Description</code><br>计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。<br>那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？<br><code>Input</code><br>输入由几个测试用例组成，每个测试用例包含两行。<br>第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。<br>单个0表示输入的结束。<br><code>Output</code><br>对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 5</span><br><span class="line">3 3 1 2 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a,b,meizi;</span><br><span class="line">int s[250][250],ans;</span><br><span class="line">int vis[250],step[250];</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,step[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line">if(mid==b)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">ans=step[mid];</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl;</span><br><span class="line">if(s[mid][i]&amp;&amp;vis[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=1;</span><br><span class="line">step[i]=step[mid]+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(step,0,sizeof(step));</span><br><span class="line">memset(s,0,sizeof(s));</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;meizi;</span><br><span class="line">if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n)s[i][meizi+i]=1;</span><br><span class="line">if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n)  s[i][i-meizi]=1;</span><br><span class="line">&#125;</span><br><span class="line">bfs(a);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day9&quot;&gt;&lt;a href=&quot;#Day9&quot; class=&quot;headerlink&quot; title=&quot;Day9&quot;&gt;&lt;/a&gt;Day9&lt;/h1&gt;&lt;p&gt;今天是 dfs 和 bfs 加训&lt;br&gt;继续学习 dfs 和 bfs，毕竟这一块还是非常重要的&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自我感想</title>
    <link href="http://yoursite.com/2019/07/25/%E5%BF%83%E6%80%81/"/>
    <id>http://yoursite.com/2019/07/25/心态/</id>
    <published>2019-07-25T05:44:12.262Z</published>
    <updated>2019-08-07T14:42:50.447Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="心态"><a href="#心态" class="headerlink" title="心态"></a><center>心态</center></h1><p><center>人们常说：心态决定命运<br>今天，写下这篇文章也是想给自己指明方向<br>面朝大海，春暖花开<br><img src="/2019/07/25/心态/2.jpg" alt><br><a id="more"></a></center></p><h2 id="学习的目的"><a href="#学习的目的" class="headerlink" title="学习的目的"></a>学习的目的</h2><p>说实话，每个人都喜欢玩乐，但是，学习，只是让自己去获得某样东西<br>也许，可以是知识，也可以是技能，又或者是友谊等等</p><p>也有人说，学习是件痛苦的事<br>但我想说的只有一点，那就是</p><p>别逼着自己去学习<br>在学习之前，思考并问一下自己，是不是真的想获得某样东西~<br>可以说，没有人不想获得“超能力”，但是这些“超能力”又该怎么来<br>那就是我们的学习</p><p>很多人把学习固定化了，认为那就是学习书本上的知识<br>那样错了！学习不该有范围，因为学习是我们自己与生俱来的能力</p><p>我们总是想要去拥有些什么，然后就会不由自主地去选择学习</p><p>所有说，我们不能因为一些其他的事情而把自己的心态给坏了<br>保持一个良好的心态是我们能够成功的保证</p><p>永远永远永远要端正好自己的态度<br>切记不可半途而废，要做就一定要做到自己所能做到的最好！！！</p><h2 id="树立自己的目标"><a href="#树立自己的目标" class="headerlink" title="树立自己的目标"></a>树立自己的目标</h2><p>曾经很多次，我自己问过我自己，到底想要获得什么，亦或是成为什么样的人<br>也是每一次，都没有一个准确的回复，可能还是不能够很好地定位自己吧</p><p>给自己一个定位，的却是一件不容易的事情<br>毕竟每个人的人生都有无限个可能，想走什么样的路，成就什么样的人生<br>这只能由我们自己去决定</p><p>可能我们会为了某一件事而冲动，亦或是感触良多，从而自发的有了树立目标的冲动<br>也许这就是我们以后要走的路了，是啊~每一个人都不容易</p><h2 id="留给自己的话"><a href="#留给自己的话" class="headerlink" title="留给自己的话"></a>留给自己的话</h2><p>每个人都是在这个世界上第一次的活着<br>那么为什么不好好的为了自己活一次<br>是的，我们不知道结局或是怎样，我们只是为了自己的喜欢而选择去怎么样的生活</p><p>也许我们可能会在这条路上不断地抱怨，不自觉的去和别人对比，但是我只是想给自己说一句话<br>就算对比了，我能得到什么？？是失望亦或是开心？？但是这些没有用呀！！</p><p>为什么不好好的活在当下，喜欢什么就去做什么~<br>是啊，我们现在是没有什么能力，但是我们年轻呀，这就是我们最大的资本</p><p>千万不要比人说什么你就信什么，还是那句话，生而为人，都是第一次<br>别人又有什么能力对你指手画脚的呢？</p><p>为了自己，好好地活过每一天……<br>放慢脚步，去领略这个世界的美丽……<br>面对自己，活出人生的意义……<br><img src="/2019/07/25/心态/1.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;心态&quot;&gt;&lt;a href=&quot;#心态&quot; class=&quot;headerlink&quot; title=&quot;心态&quot;&gt;&lt;/a&gt;&lt;center&gt;心态&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;center&gt;人们常说：心态决定命运&lt;br&gt;今天，写下这篇文章也是想给自己指明方向&lt;br&gt;面朝大海，春暖花开&lt;br&gt;&lt;img src=&quot;/2019/07/25/心态/2.jpg&quot; alt&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
      <category term="想法" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/%E6%83%B3%E6%B3%95/"/>
    
    
      <category term="想法" scheme="http://yoursite.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Day8</title>
    <link href="http://yoursite.com/2019/07/25/Day8/"/>
    <id>http://yoursite.com/2019/07/25/Day8/</id>
    <published>2019-07-24T16:00:00.000Z</published>
    <updated>2019-07-25T13:58:21.613Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><p>今天学习了 树的直径<br>树的直径-&gt;双重BFS/DFS跑图<br>学的效果整体还行<br><a id="more"></a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h3><p>树（tree）是包含n（n&gt;0）个结点的有穷集，其中：<br>每个元素称为结点（node）；<br>有一个特定的结点被称为根结点或树根（root）；<br>除根结点之外的其余数据元素被分为m（m≥0）个互不相交<br>的集合T1，T2，…Tm−1，其中每一个集合Tm−1（1≤i≤m）<br>本身也是一棵树，被称作原树的子树（subtree）。</p><h3 id="树的直径的定义"><a href="#树的直径的定义" class="headerlink" title="树的直径的定义"></a>树的直径的定义</h3><p>树中距离最大的两个结点之间的距离称为树的直径。</p><h3 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h3><p>两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的<br>点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到<br>离它最远的点，此点就是最长路的另一个端点，于是就找到了树<br>的直径。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>假设此树的最长路径是从s到t,我们选择的点为u。<br>反证法：假设搜到的点是v。<br>1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛<br>盾。<br>2、v不在这条最长路径上，我们在最长路径上选择一个点为po，<br>则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]<br>+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。<br>也许你想说u本身就在最长路径，或则其它的一些情况，但其实<br>都能用类似于上面的反证法来证明的。<br>综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路<br>径长度</p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>POJ 2631<br>POJ 1985<br>POJ 1383</p><h3 id="带权图相关代码模板-用的时候要合理变动"><a href="#带权图相关代码模板-用的时候要合理变动" class="headerlink" title="带权图相关代码模板(用的时候要合理变动)"></a>带权图相关代码模板(用的时候要合理变动)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;cstring&gt;</span><br><span class="line"># include &lt;queue&gt;</span><br><span class="line"># include &lt;vector&gt;</span><br><span class="line">const int maxn =100020;</span><br><span class="line">using namespace std ;</span><br><span class="line">int dis[maxn], ans ;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;pair&lt;int ,int&gt; &gt; V[maxn];</span><br><span class="line"></span><br><span class="line">int bfs(int x)&#123;</span><br><span class="line">memset(dis ,0 , sizeof(dis));</span><br><span class="line">memset(vis ,0 , sizeof(vis));</span><br><span class="line">queue&lt;int &gt; Q ;</span><br><span class="line">Q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line">int point=0;</span><br><span class="line">while (!Q.empty())&#123;</span><br><span class="line">int F = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">if(dis[F] &gt; ans )&#123;</span><br><span class="line">ans = dis[F];</span><br><span class="line">point = F;</span><br><span class="line">&#125;</span><br><span class="line">pair &lt;int ,int &gt; t ;</span><br><span class="line">for (int i =0; i &lt; V [F].size (); i ++)&#123;</span><br><span class="line">t = V[F][i];</span><br><span class="line">if(vis[t.first]==0)&#123;</span><br><span class="line">vis[t.first]=1;</span><br><span class="line">dis[t.first]=dis[F] + t.second ;</span><br><span class="line">Q.push (t.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int x,y,z ;</span><br><span class="line">输入</span><br><span class="line">ans=0;</span><br><span class="line">int point=bfs(1);</span><br><span class="line">ans=0;</span><br><span class="line">bfs(point);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl ;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OJ链接：<a href="https://vjudge.net/contest/313488#overview" target="_blank" rel="noopener">https://vjudge.net/contest/313488#overview</a></p><h2 id="Labyrinth"><a href="#Labyrinth" class="headerlink" title="Labyrinth"></a>Labyrinth</h2><p><code>Problem Description</code><br>The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.<br><code>Input</code><br>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.<br>The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.<br><code>Output</code><br>Your program must print exactly one line of output for each test case. The line must contain the sentence “Maximum rope length is X.” where Xis the length of the longest path between any two free blocks, measured in blocks.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">###</span><br><span class="line">#.#</span><br><span class="line">###</span><br><span class="line">7 6</span><br><span class="line">#######</span><br><span class="line">#.#.###</span><br><span class="line">#.#.###</span><br><span class="line">#.#.#.#</span><br><span class="line">#.....#</span><br><span class="line">#######</span><br><span class="line">Sample Output</span><br><span class="line">Maximum rope length is 0.</span><br><span class="line">Maximum rope length is 8.</span><br><span class="line">Hint</span><br><span class="line">Huge input, scanf is recommended. </span><br><span class="line">If you use recursion, maybe stack overflow. and now C++/c &apos;s stack size is larger than G++/gcc</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n, m;</span><br><span class="line">char a[2000][3000];</span><br><span class="line">int dis[2000][2000];</span><br><span class="line">int ans;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0,</span><br><span class="line">0, 1,</span><br><span class="line">0, -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;first, second;</span><br><span class="line"></span><br><span class="line">void bfs(node first)</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(dis, -1, sizeof dis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = first.x, e1.y = first.y, dis[e1.x][e1.y] = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; a[e2.x][e2.y] != &apos;#&apos; &amp;&amp; dis[e2.x][e2.y] == -1)</span><br><span class="line">&#123;</span><br><span class="line">q.push(e2);</span><br><span class="line">dis[e2.x][e2.y] = dis[e1.x][e1.y] + 1;</span><br><span class="line">if(ans &lt; dis[e2.x][e2.y])</span><br><span class="line">&#123;</span><br><span class="line">ans = dis[e2.x][e2.y];</span><br><span class="line">second.x = e2.x;</span><br><span class="line">second.y = e2.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j] == &apos;.&apos;)</span><br><span class="line">&#123;</span><br><span class="line">first.x = i;</span><br><span class="line">first.y = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs(first);</span><br><span class="line">bfs(second);</span><br><span class="line">printf(&quot;Maximum rope length is %d.\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cow-Marathon"><a href="#Cow-Marathon" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h2><p><code>Problem Description</code><br>After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.<br>有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.<br><code>Input</code></p><ul><li>Lines 1…..: Same input format as “Navigation Nightmare”.<br><code>Output</code></li><li>Line 1: An integer giving the distance between the farthest pair of farms.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">7 6</span><br><span class="line">1 6 13 E</span><br><span class="line">6 3 9 E</span><br><span class="line">3 5 7 S</span><br><span class="line">4 1 3 N</span><br><span class="line">2 4 20 W</span><br><span class="line">4 7 2 S</span><br><span class="line">Sample Output</span><br><span class="line">52</span><br><span class="line">Hint</span><br><span class="line">The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.</span><br></pre></td></tr></table></figure></li></ul><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn = 5e5 + 10;//数组不要太大，不然会超时 </span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn];</span><br><span class="line">int ans, en;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector &lt;pair&lt;int,int&gt; &gt;V[maxn];</span><br><span class="line">int bfs(int x) </span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line"> memset(vis,0,sizeof(vis));</span><br><span class="line"> queue&lt;int&gt; q;</span><br><span class="line"> q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line"> en = 0;</span><br><span class="line"> while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"> int f = q.front();</span><br><span class="line"> q.pop();</span><br><span class="line"> if(dis[f] &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line"> ans = dis[f];</span><br><span class="line">en = f;</span><br><span class="line">&#125;</span><br><span class="line"> pair&lt;int,int &gt; t;</span><br><span class="line"> for(int i = 0; i &lt; V[f].size();i ++)</span><br><span class="line">&#123;</span><br><span class="line"> t = V[f][i];</span><br><span class="line"> if(vis[t.first] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first] = 1;</span><br><span class="line"> dis[t.first] = dis[f] + t.second;</span><br><span class="line"> q.push(t.first);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return en;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">char c[100];</span><br><span class="line">int n, m;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0;i &lt; n; i ++)</span><br><span class="line">V[i].clear();//注意每次用完vector之后要清空 </span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d %d %s&quot;,&amp;x,&amp;y,&amp;z,&amp;c);</span><br><span class="line">V[x].push_back(make_pair(y,z));</span><br><span class="line"> V[y].push_back(make_pair(x,z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(1);</span><br><span class="line"> bfs(en);</span><br><span class="line"> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Roads-in-the-North"><a href="#Roads-in-the-North" class="headerlink" title="Roads in the North"></a>Roads in the North</h2><p><code>Problem Description</code><br>Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.<br>Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.</p><p>The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.<br><code>Input</code><br>Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.<br><code>Output</code><br>You are to output a single integer: the road distance between the two most remote villages in the area.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 6</span><br><span class="line">1 4 5</span><br><span class="line">6 3 9</span><br><span class="line">2 6 8</span><br><span class="line">6 1 7</span><br><span class="line">Sample Output</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">typedef long long ll;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt;v[maxx];</span><br><span class="line">int ans;</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int en; //不要用end，是一个保留字 </span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">//每次bfs都要初始化 </span><br><span class="line">ans = 0;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">//套用bfs模板 </span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">vis[x] = 1;</span><br><span class="line">q.push(x);</span><br><span class="line">en = 0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">//随着ans的不断更新，直到找到一个端点，标记下来 </span><br><span class="line">if(dis[f] &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line">ans = dis[f];</span><br><span class="line">en = f;//一段的开始 </span><br><span class="line">&#125;</span><br><span class="line">//创建新的数对，表示的是与v[]相连的点 </span><br><span class="line">pair&lt;int , int&gt; p;</span><br><span class="line">//遍历所有地点 ，根据距离，寻找一端的点 </span><br><span class="line">for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">p = v[f][i];//表示 寻找这个点在图中的所有可能 </span><br><span class="line">if(vis[p.first] == 0) //如果这个地点没有经过 </span><br><span class="line">&#123;</span><br><span class="line">vis[p.first] = 1;//先标记 </span><br><span class="line">dis[p.first] = dis[f] + p.second;//加上距离 ，更新ans </span><br><span class="line">q.push(p.first);//入队，寻找这个点的所有可能性 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">return en;//将一端的标记返回出去 </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">while(~scanf(&quot;%d %d %d&quot;,&amp;x, &amp;y, &amp;z))</span><br><span class="line">&#123;</span><br><span class="line">//存图，意思就是将与x,y相连的点和对应的权值存储起来，因为是双向的，所以权值一样 </span><br><span class="line">v[x].push_back(make_pair(y, z));</span><br><span class="line">v[y].push_back(make_pair(x, z));</span><br><span class="line">&#125;</span><br><span class="line">//第一次bfs随便找个点去找到整个图的一个端点 </span><br><span class="line">bfs(1);</span><br><span class="line">//第二次bfs从一个端点出发去找另一个端点，即为树的直径 </span><br><span class="line">bfs(en);</span><br><span class="line">//输出答案ans </span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">题意：</span><br><span class="line">有10000个村庄，有很多条路，现在这些路已经把村庄都连了起来，求最远的两个村庄的路的距离。</span><br><span class="line"></span><br><span class="line">思路，把每一边都历遍一下，找到两个距离最远的村庄。</span><br><span class="line"></span><br><span class="line">这里有一个结论，在图中，要找到距离最远的两点，先随便从一个点入手BFS，找到距离这个点最远的点，在从这个点BFS找到距离这点最远的点，这两点之间的距离就是这棵树的直径。所以直接进行BFS搜索就行了。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h2><p><code>Problem Description</code><br>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.</p><p><img src="https://i.loli.net/2019/07/25/5d393d850e3b759478.jpg" alt></p><p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p><p><code>Input</code><br>输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过10^9。输入行中的数字用空格分隔。<br><code>Output</code><br>对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">提示</span><br><span class="line">示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">typedef long long ll;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; v[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int diss[maxx];</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x] = 1;</span><br><span class="line">int point;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(ans &lt; dis[f])</span><br><span class="line">&#123;</span><br><span class="line">ans = dis[f];</span><br><span class="line">point = f;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(vis[v[f][i].first] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[v[f][i].first] = 1;</span><br><span class="line">dis[v[f][i].first] = v[f][i].second + dis[f];</span><br><span class="line">q.push(v[f][i].first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int a, b;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt;= n; i ++) v[i].clear();</span><br><span class="line">for(int i = 1; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">v[i + 1].push_back(make_pair(a, b));</span><br><span class="line">v[a].push_back(make_pair(i + 1, b));</span><br><span class="line">&#125;</span><br><span class="line">int point;</span><br><span class="line">point = bfs(bfs(1));</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) diss[i] = dis[i];</span><br><span class="line">bfs(point);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; max(dis[i], diss[i]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Farthest-Nodes-in-a-Tree"><a href="#Farthest-Nodes-in-a-Tree" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h2><p><code>Problem Description</code><br>Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.<br><code>Input</code><br>Input starts with an integer T (≤ 10), denoting the number of test cases.<br>Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.<br><code>Output</code><br>For each case, print the case number and the maximum distance.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">0 1 20</span><br><span class="line">1 2 30</span><br><span class="line">2 3 50</span><br><span class="line">5</span><br><span class="line">0 2 20</span><br><span class="line">2 1 10</span><br><span class="line">0 3 29</span><br><span class="line">0 4 50</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 100</span><br><span class="line">Case 2: 80</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//e</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn = 5e5 + 10;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn];</span><br><span class="line">int ans, en;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector &lt;pair&lt;int,int&gt; &gt;V[maxn];</span><br><span class="line">int bfs(int x) </span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(dis,0,sizeof(dis));</span><br><span class="line"> memset(vis,0,sizeof(vis));</span><br><span class="line"> queue&lt;int&gt;q;</span><br><span class="line"> q.push(x);</span><br><span class="line">vis[x]=1;</span><br><span class="line"> en = 0;</span><br><span class="line"> while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"> int f = q.front();</span><br><span class="line"> q.pop();</span><br><span class="line"> if(dis[f] &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line"> ans = dis[f];</span><br><span class="line">en = f;</span><br><span class="line">&#125;</span><br><span class="line"> pair&lt;int,int &gt; t;</span><br><span class="line"> for(int i = 0; i &lt; V[f].size();i ++)</span><br><span class="line">&#123;</span><br><span class="line"> t = V[f][i];</span><br><span class="line"> if(vis[t.first] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first] = 1;</span><br><span class="line"> dis[t.first] = dis[f] + t.second;</span><br><span class="line"> q.push(t.first);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return en;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">int T, n;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">int k = 1;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0;i &lt; n; i ++)</span><br><span class="line">V[i].clear();//注意每次用完vector之后要清空 </span><br><span class="line">for(int i = 0; i &lt; n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">V[x].push_back(make_pair(y,z));</span><br><span class="line"> V[y].push_back(make_pair(x,z));</span><br><span class="line">&#125;</span><br><span class="line">bfs(0);</span><br><span class="line"> bfs(en);</span><br><span class="line"> printf(&quot;Case %d: %d\n&quot;,k ++, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day8&quot;&gt;&lt;a href=&quot;#Day8&quot; class=&quot;headerlink&quot; title=&quot;Day8&quot;&gt;&lt;/a&gt;Day8&lt;/h1&gt;&lt;p&gt;今天学习了 树的直径&lt;br&gt;树的直径-&amp;gt;双重BFS/DFS跑图&lt;br&gt;学的效果整体还行&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Day7</title>
    <link href="http://yoursite.com/2019/07/24/Day7/"/>
    <id>http://yoursite.com/2019/07/24/Day7/</id>
    <published>2019-07-23T16:00:00.000Z</published>
    <updated>2019-07-24T16:39:08.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><p>今天学习的是dfs<br>常规操作~~~~没写完题<br>这次不是debug了，是真的不会(太菜了。。。)<br><code>未完待续</code><br><a id="more"></a></p><p>链接：<a href="https://vjudge.net/contest/313683#overview" target="_blank" rel="noopener">https://vjudge.net/contest/313683#overview</a></p><h2 id="Oil-Deposits"><a href="#Oil-Deposits" class="headerlink" title="Oil Deposits"></a>Oil Deposits</h2><p><code>Problem Description</code><br>The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.<br><code>Input</code><br>The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either <code>*&#39;, representing the absence of oil, or</code>@’, representing an oil pocket.<br><code>Output</code><br>For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 1</span><br><span class="line">*</span><br><span class="line">3 5</span><br><span class="line">*@*@*</span><br><span class="line">**@**</span><br><span class="line">*@*@*</span><br><span class="line">1 8</span><br><span class="line">@@****@*</span><br><span class="line">5 5 </span><br><span class="line">****@</span><br><span class="line">*@@*@</span><br><span class="line">*@**@</span><br><span class="line">@@@*@</span><br><span class="line">@@**@</span><br><span class="line">0 0 </span><br><span class="line">Sample Output</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//板子题，8个方向</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 101;</span><br><span class="line">char a[mod][mod];</span><br><span class="line">int vis[mod][mod];</span><br><span class="line">int ans;</span><br><span class="line">int n, m;</span><br><span class="line">int d[8][2] = &#123;</span><br><span class="line">-1, 1,</span><br><span class="line">-1, 0,</span><br><span class="line">-1, -1,</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">1, 1,</span><br><span class="line">1, 0,</span><br><span class="line">1, -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void DFS(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x &lt; 0 || y &lt; 0 || x &gt;=n || y &gt;= m)</span><br><span class="line">return ;</span><br><span class="line">int xx, yy;</span><br><span class="line">//vis[x][y] = 1;</span><br><span class="line">for(int i = 0; i &lt; 8; i ++)</span><br><span class="line">&#123;</span><br><span class="line">xx = x + d[i][0];</span><br><span class="line">yy = y + d[i][1];</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] != &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">a[xx][yy] = &apos;*&apos;;</span><br><span class="line">DFS(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx, sy;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">//memset(vis, 0, sizeof(vis));</span><br><span class="line">ans = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j] == &apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ans ++;</span><br><span class="line">DFS(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="How-Many-Equations-Can-You-Find"><a href="#How-Many-Equations-Can-You-Find" class="headerlink" title="How Many Equations Can You Find"></a>How Many Equations Can You Find</h2><p><code>Problem Description</code><br>Now give you an string which only contains 0, 1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9.You are asked to add the sign ‘+’ or ’-’ between the characters. Just like give you a string “12345”, you can work out a string “123+4-5”. Now give you an integer N, please tell me how many ways can you find to make the result of the string equal to N .You can only choose at most one sign between two adjacent characters.<br><code>Input</code><br>Each case contains a string s and a number N . You may be sure the length of the string will not exceed 12 and the absolute value of N will not exceed 999999999999.<br><code>Output</code><br>The output contains one line for each data set : the number of ways you can find to make the equation.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">123456789 3</span><br><span class="line">21 1</span><br><span class="line">Sample Output</span><br><span class="line">18</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//每一位都可能放或者不放算术符</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 200 + 10;</span><br><span class="line">char str[MAXN][MAXN];</span><br><span class="line">bool vis[MAXN][MAXN];</span><br><span class="line">char s[100100];</span><br><span class="line">ll n,m,len;</span><br><span class="line">ll ans;</span><br><span class="line">void DFS(int sum,int m)&#123;</span><br><span class="line">if(m==len)&#123;</span><br><span class="line">if(sum==n)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">ll mm=0;</span><br><span class="line">for(int i=m;i&lt;len;i++)&#123;</span><br><span class="line">mm=mm*10+(s[i]-&apos;0&apos;);</span><br><span class="line">DFS(sum+mm,i+1);</span><br><span class="line">if(m!=0)&#123;</span><br><span class="line">DFS(sum-mm,i+1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">while(scanf(&quot;%s%lld&quot;,s,&amp;n)!=EOF)&#123;</span><br><span class="line">ans=0;</span><br><span class="line">len=strlen(s);</span><br><span class="line">DFS(0,0);</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p><code>Problem Description</code><br>在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。<br>你的任务是，对于给定的N，求出有多少种合法的放置方法。</p><p><code>Input</code><br>共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。<br><code>Output</code><br>共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">92</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">//第一种写法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[3][20], p[20];// vis用来存储↖↑↗在此三个方向都不能有皇后 p[n]用来存储解 </span><br><span class="line">int n;</span><br><span class="line">int num;</span><br><span class="line"></span><br><span class="line">void DFS(int row)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">if(row == n + 1)  //已经够n行了</span><br><span class="line">&#123;</span><br><span class="line">num ++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(vis[0][row - i + n] == 0 &amp;&amp; vis[1][i] == 0 &amp;&amp; vis[2][row + i] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[0][row - i + n] = vis[1][i] = vis[2][row + i] = 1;//变值 </span><br><span class="line">DFS(row + 1);</span><br><span class="line">vis[0][row - i + n] = vis[1][i] = vis[2][row + i] = 0;//回溯 </span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">for(n = 1; n &lt;= 10; n ++)  //打表防超时</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">num = 0;</span><br><span class="line">DFS(1);</span><br><span class="line">p[n] = num;</span><br><span class="line">&#125; </span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二种</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 12;</span><br><span class="line">int a[N], cnt;</span><br><span class="line">//x，i表示行，y,a[i]表示列，用check来表示是否可以放置 </span><br><span class="line">bool check(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt; x; i ++)</span><br><span class="line">&#123;</span><br><span class="line">//abs(x - i) == abs(a[i] - y)表示的是(x-i)/(a[i]-y)的斜率的绝对值是否为1 </span><br><span class="line">if(a[i] == y || abs(x - i) == abs(a[i] - y))</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int x, int m)</span><br><span class="line">&#123;</span><br><span class="line">//x越界的时候,同时也表示到底了,回溯 </span><br><span class="line">if(x &gt; m)</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(check(x, i))</span><br><span class="line">&#123;</span><br><span class="line">a[x] = i;</span><br><span class="line">DFS(x + 1, m);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//ans用来存放数据，不打表的话可能超时 </span><br><span class="line">int i, ans[11];</span><br><span class="line">//打表并深搜 </span><br><span class="line">for(int i = 1; i &lt; 11; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cnt = 0;</span><br><span class="line">DFS(1, i);</span><br><span class="line">ans[i] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">while(cin &gt;&gt; i)</span><br><span class="line">&#123;</span><br><span class="line">if(i == 0) return 0;</span><br><span class="line">cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第三种</span><br><span class="line">//行，列，两个对角，共四个数组，每次存入都要查看是否已经存放过</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF=0x3f3f3f3f;</span><br><span class="line">int a[105],b[105],c[105],d[105];//a:行,b:列,c:左下到右上,d:左上到右下</span><br><span class="line">int i,ans=0;</span><br><span class="line">void DFS(int x)&#123;</span><br><span class="line">    if(x==i+1)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=1;j&lt;=i;j++)&#123;</span><br><span class="line">        if(!b[j]&amp;&amp;!c[j+x]&amp;&amp;!d[x-j+i])&#123;</span><br><span class="line">            a[x]=j;</span><br><span class="line">            b[j]=1;</span><br><span class="line">            c[j+x]=1;</span><br><span class="line">            d[x-j+i]=1;</span><br><span class="line">            DFS(x+1);</span><br><span class="line">            b[j]=0;</span><br><span class="line">            c[j+x]=0;</span><br><span class="line">            d[x-j+i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int num[15];</span><br><span class="line">    int n;</span><br><span class="line">    for(i=1;i&lt;11;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=0;</span><br><span class="line">        DFS(1);</span><br><span class="line">        num[i]=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;num[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Fox-And-Two-Dots"><a href="#Fox-And-Two-Dots" class="headerlink" title="Fox And Two Dots"></a>Fox And Two Dots</h2><p><code>Problem Description</code><br>Fox Ciel is playing a mobile puzzle game called “Two Dots”. The basic levels are played on a board of size n × m cells, like this:<br><img src="https://i.loli.net/2019/07/25/5d3886308e5f626454.png" alt><br>Each cell contains a dot that has some color. We will use different uppercase Latin characters to express different colors.<br>The key of this game is to find a cycle that contain dots of same color. Consider 4 blue dots on the picture forming a circle as an example. Formally, we call a sequence of dots d1, d2, …, dk a cycle if and only if it meets the following condition:<br>These k dots are different: if i ≠ j then di is different from dj.<br>k is at least 4.<br>All dots belong to the same color.<br>For all 1 ≤ i ≤ k - 1: di and di + 1 are adjacent. Also, dk and d1 should also be adjacent. Cells x and y are called adjacent if they share an edge.<br>Determine if there exists a cycle on the field.<br><code>Input</code><br>The first line contains two integers n and m (2 ≤ n, m ≤ 50): the number of rows and columns of the board.<br>Then n lines follow, each line contains a string consisting of m characters, expressing colors of dots in each line. Each character is an uppercase Latin letter.<br><code>Output</code><br>Output “Yes” if there exists a cycle, and “No” otherwise.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input </span><br><span class="line">3 4</span><br><span class="line">AAAA</span><br><span class="line">ABCA</span><br><span class="line">AAAA</span><br><span class="line">Output </span><br><span class="line">Yes</span><br><span class="line">Input </span><br><span class="line">3 4</span><br><span class="line">AAAA</span><br><span class="line">ABCA</span><br><span class="line">AADA</span><br><span class="line">Output </span><br><span class="line">No</span><br><span class="line">Input </span><br><span class="line">4 4</span><br><span class="line">YYYR</span><br><span class="line">BYBY</span><br><span class="line">BBBY</span><br><span class="line">BBBY</span><br><span class="line">Output </span><br><span class="line">Yes</span><br><span class="line">Input </span><br><span class="line">7 6</span><br><span class="line">AAAAAB</span><br><span class="line">ABBBAB</span><br><span class="line">ABAAAB</span><br><span class="line">ABABBB</span><br><span class="line">ABAAAB</span><br><span class="line">ABBBAB</span><br><span class="line">AAAAAB</span><br><span class="line">Output </span><br><span class="line">Yes</span><br><span class="line">Input </span><br><span class="line">2 13</span><br><span class="line">ABCDEFGHIJKLM</span><br><span class="line">NOPQRSTUVWXYZ</span><br><span class="line">Output </span><br><span class="line">No</span><br><span class="line">Note</span><br><span class="line">In first sample test all &apos;A&apos; form a cycle.</span><br><span class="line">In second sample there is no such cycle.</span><br><span class="line">The third sample is displayed on the picture above (&apos;Y&apos; = Yellow, &apos;B&apos; = Blue, &apos;R&apos; = Red).</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">//d</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[55][55];</span><br><span class="line">char a[55][55];</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">-1, 0,</span><br><span class="line">1, 0,</span><br><span class="line">0, 1,</span><br><span class="line">0, -1</span><br><span class="line">&#125;;</span><br><span class="line">int n, m, k;</span><br><span class="line">//四个变量表示当前坐标点和上一个坐标点 </span><br><span class="line">void DFS(int x, int y, int cx, int cy)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if(vis[x][y] == 1)</span><br><span class="line">&#123;</span><br><span class="line">//想要表示成环,只需要走以前走过的点就行了，也就是走到了标记过的点 </span><br><span class="line">k = 1;//表示成环 </span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">vis[x][y] = 1;</span><br><span class="line">int xx, yy;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">xx = x + d[i][0];</span><br><span class="line">yy = y + d[i][1];</span><br><span class="line">// 表示不能往回走并且不能越界 </span><br><span class="line">if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; a[xx][yy] == a[x][y] &amp;&amp; (xx != cx || yy != cy))</span><br><span class="line">&#123;</span><br><span class="line">DFS(xx, yy , x, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">k = 0;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">//全部遍历，找寻可能点 </span><br><span class="line">if(vis[i][j] == 1) continue;</span><br><span class="line">DFS(i, j, i, j);</span><br><span class="line">//找到了点，退出循环 </span><br><span class="line">if(k == 1) break;</span><br><span class="line">&#125;</span><br><span class="line">if(k == 1) break;</span><br><span class="line">&#125;</span><br><span class="line">if(k == 1) puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h2><p><code>Problem Description</code><br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。<br><code>Input</code><br>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。<br><code>Output</code><br>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2 1</span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line">4 4</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line">-1 -1</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int MAXN = 200 + 10;</span><br><span class="line">char str[MAXN][MAXN];</span><br><span class="line">bool vis[MAXN];</span><br><span class="line">int n,k;</span><br><span class="line">ll ans;</span><br><span class="line">int d[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;</span><br><span class="line">void DFS(int x,int num)&#123;</span><br><span class="line">if(num==k)&#123;</span><br><span class="line">ans++;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=x;i&lt;n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">if(str[i][j]==&apos;#&apos;&amp;&amp;!vis[j])&#123;</span><br><span class="line">vis[j]=true;</span><br><span class="line">DFS(i+1,num+1);</span><br><span class="line">vis[j]=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF&amp;&amp;n!=-1&amp;&amp;k!=-1)&#123;</span><br><span class="line">memset(str,0,sizeof(str));</span><br><span class="line">memset(vis,false,sizeof(vis));</span><br><span class="line">ans=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">DFS(0,0);</span><br><span class="line">printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Sudoku"><a href="#Sudoku" class="headerlink" title="Sudoku"></a>Sudoku</h2><p><code>Problem Description</code><br>Sudoku is a very simple task. A square table with 9 rows and 9 columns is divided to 9 smaller squares 3x3 as shown on the Figure. In some of the cells are written decimal digits from 1 to 9. The other cells are empty. The goal is to fill the empty cells with decimal digits from 1 to 9, one digit per cell, in such way that in each row, in each column and in each marked 3x3 subsquare, all the digits from 1 to 9 to appear. Write a program to solve a given Sudoku-task.</p><p><img src="https://i.loli.net/2019/07/25/5d38882dd65f851048.jpg" alt></p><p><code>Input</code><br>The input data will start with the number of the test cases. For each test case, 9 lines follow, corresponding to the rows of the table. On each line a string of exactly 9 decimal digits is given, corresponding to the cells in this line. If a cell is empty it is represented by 0.<br><code>Output</code><br>For each test case your program should print the solution in the same format as the input data. The empty cells have to be filled according to the rules. If solutions is not unique, then the program may print any one of them.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">103000509</span><br><span class="line">002109400</span><br><span class="line">000704000</span><br><span class="line">300502006</span><br><span class="line">060000050</span><br><span class="line">700803004</span><br><span class="line">000401000</span><br><span class="line">009205800</span><br><span class="line">804000107</span><br><span class="line">Sample Output</span><br><span class="line">143628579</span><br><span class="line">572139468</span><br><span class="line">986754231</span><br><span class="line">391542786</span><br><span class="line">468917352</span><br><span class="line">725863914</span><br><span class="line">237481695</span><br><span class="line">619275843</span><br><span class="line">854396127</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//每个为0的格子都可能放1~9放完后再查看每一行，列，每个小九宫格中是否含有这个数，如果没有则继续DFS下个格子</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int a[10][10];</span><br><span class="line">int check(int n,int num)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;9;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int j=n%9;</span><br><span class="line">        if(a[i][j]==num)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=0;j&lt;9;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        int i=n/9;</span><br><span class="line">        if(a[i][j]==num)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ii=n/9/3*3;</span><br><span class="line">    int jj=n%9/3*3;</span><br><span class="line">    for(int i=ii;i&lt;ii+3;i++)</span><br><span class="line">        for(int j=jj;j&lt;jj+3;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i][j]==num)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int temp;</span><br><span class="line">int DFS(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&gt;=81)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=1;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[n/9][n%9]!=0)</span><br><span class="line">        DFS(n+1);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1;i&lt;=9;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(check(n,i)==1)</span><br><span class="line">            &#123;</span><br><span class="line">                a[n/9][n%9]=i;</span><br><span class="line">                DFS(n+1);</span><br><span class="line">                if(temp==1)</span><br><span class="line">                    return 0;</span><br><span class="line">                a[n/9][n%9]=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=0;</span><br><span class="line">        for(int i=0;i&lt;9;i++)</span><br><span class="line">            for(int j=0;j&lt;9;j++)</span><br><span class="line">            scanf(&quot;%1d&quot;,&amp;a[i][j]);</span><br><span class="line">        DFS(0);</span><br><span class="line">        for(int i=0;i&lt;9;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;9;j++)</span><br><span class="line">                printf(&quot;%d&quot;,a[i][j]);</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h2><p><code>Problem Description</code><br>把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。<br><code>Input</code><br>第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。<br><code>Output</code><br>对输入的每组数据M和N，用一行输出相应的K。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">7 3</span><br><span class="line">Sample Output</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">//#include&lt;&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">int solve(int m, int n)</span><br><span class="line">&#123;</span><br><span class="line">if(m == 0 || n == 1) return 1;</span><br><span class="line">if(n &gt; m) return solve(m, m);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return solve(m, n - 1) + solve(m - n, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin &gt;&gt; t; </span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n; </span><br><span class="line">int ans = solve(m, n);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//PS：苹果可以为0， 盘子不能为0（毕竟是放苹果） </span><br><span class="line">/*</span><br><span class="line">分析：</span><br><span class="line">如果盘子比苹果多，那么一定会有盘子是空的，即为 solve(m, m); </span><br><span class="line">那么这就是一种情况</span><br><span class="line">如果盘子比苹果少，那么可以分为：</span><br><span class="line">1. 假设没有空盘子，那么上面都有苹果，那么可以看成一开始每个盘子上都有一个苹果 </span><br><span class="line">   然后我们每次加一个苹果，就剩下m - n个苹果，直到放完为止 </span><br><span class="line"> 即为  solve(m - n, n)</span><br><span class="line">2. 假设有空盘子，那么每次拿走一个空盘子  即为: solve(m, n - 1);</span><br><span class="line"></span><br><span class="line">结果即为这两种情况的和 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="Tempter-of-the-Bone"><a href="#Tempter-of-the-Bone" class="headerlink" title="Tempter of the Bone"></a>Tempter of the Bone</h2><p><code>Problem Description</code><br>小明做了一个很久很久的梦，醒来后他竟发现自己和朋友在一个摇摇欲坠的大棋盘上，他们必须得想尽一切办法逃离这里。<br>经过长时间的打探，小明发现，自己所在的棋盘格子上有个机关，上面写着“你只有一次机会，出发后t秒大门会为你敞开”，而他自己所在的棋盘是大小为 N*M 的长方形，他可以向上下左右四个方向移动（不可走有障碍点）。棋盘中有一扇门。根据机关的提示，小明顿时明白了，他和朋友必须在第 t 秒到门口。而这一切，没有回头路！因为一旦他移动了，他刚才所在的点就会消失，并且他不能在一个点上停留超过一秒，不然格子会爆炸。大逃亡开始了，请问小明和朋友能安全的逃出这奇怪的棋盘吗？<br><code>Input</code><br>输入多组测试数据。每个测试用例的第一行包含三个整数 N、M 和 T ( 1 &lt; N , M &lt; 7 ; 0 &lt; T &lt; 50 )，分别表示棋盘的大小和门打开的时间。接下来的N行给出棋盘布局，每一行包含M个字符。其中<br>“.”: 无障碍点<br>“X”: 障碍点<br>“S”: 起点<br>“D”: 门<br>输入以 3 个 0 结束。这个测试用例不需要处理。<br>输入数据中的空格有些问题，请不要使用getchar()，如果一定要用可以选择scanf(“%s”,) 自动忽略空格<br><code>Output</code><br>对于每组样例输出一行。<br>如果小明能够安全逃出，输出 “YES” ，否则输出 “NO”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">..XD</span><br><span class="line">....</span><br><span class="line">3 4 5</span><br><span class="line">S.X.</span><br><span class="line">..X.</span><br><span class="line">...D</span><br><span class="line">0 0 0</span><br><span class="line">Sample Output</span><br><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, t;</span><br><span class="line">char a[30][30]; </span><br><span class="line">int vis[40][40];</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">-1, 0,</span><br><span class="line">1, 0,</span><br><span class="line">0, 1,</span><br><span class="line">0, -1</span><br><span class="line">&#125;;</span><br><span class="line">int flag;</span><br><span class="line">int ex, ey;</span><br><span class="line">void DFS(int sx, int sy, int ans)</span><br><span class="line">&#123;</span><br><span class="line">int xx, yy;</span><br><span class="line">//很重要，可以减少步骤，也是如何使一旦找到需要的路线就可以连续return出</span><br><span class="line">if(flag)</span><br><span class="line">return;</span><br><span class="line">if(sx == ex &amp;&amp; sy == ey &amp;&amp; ans == t)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//剪枝的核心 </span><br><span class="line">int tem = t - ans - abs(ex - sx) - abs(ey - sy);</span><br><span class="line">//剪枝：如果剩余的步数已经不足以走到出口，且必须是偶数，偶数-偶数=偶数，奇数-奇数=偶数，</span><br><span class="line">if(tem &lt; 0 || tem &amp; 1)</span><br><span class="line">return; </span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">xx = sx + d[i][0];</span><br><span class="line">yy = sy + d[i][1];</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; vis[xx][yy] == 0 &amp;&amp; a[xx][yy] != &apos;X&apos;)</span><br><span class="line">&#123;</span><br><span class="line">vis[xx][yy] = 1;</span><br><span class="line">DFS(xx, yy, ans + 1);</span><br><span class="line">if(flag) </span><br><span class="line">return;</span><br><span class="line">vis[xx][yy] = 0;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int wall, sx, sy;</span><br><span class="line">while(~scanf(&quot;%d %d %d&quot;,&amp;n, &amp;m, &amp;t))</span><br><span class="line">&#123;</span><br><span class="line">flag = 0, wall = 0;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0 &amp;&amp; t == 0) break;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">if(a[i][j] == &apos;S&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx = i;</span><br><span class="line">sy = j;</span><br><span class="line">&#125;</span><br><span class="line">if(a[i][j] == &apos;D&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ex = i;</span><br><span class="line">ey = j;</span><br><span class="line">&#125;</span><br><span class="line">if(a[i][j] == &apos;X&apos;)</span><br><span class="line">&#123;</span><br><span class="line">wall ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(t &gt; n * m - wall - 1)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;NO&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">vis[sx][sy] = 1;</span><br><span class="line">DFS(sx, sy, 0);</span><br><span class="line">if(flag) puts(&quot;YES&quot;);</span><br><span class="line">else puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">关于奇偶剪枝：</span><br><span class="line">不利用奇偶剪枝的话一直TLE，现在对于奇偶剪枝不理解，暂时记住公式，t-cnt为目前剩余的时间，abs(x-dx)+abs(y-dy)为从当前改点到终点（门)所需要的最短步数，剩余时间为偶数（奇数），就需要走偶数步（奇数步），</span><br><span class="line"></span><br><span class="line">奇数-偶数 = 奇数</span><br><span class="line"></span><br><span class="line">而奇数-奇数= 偶数，偶数-偶数=偶数</span><br><span class="line"></span><br><span class="line">所以只有当剩余的时间与目前位置到终点的最短步数奇偶性相同时，才有可能恰好在t时刻到大门的地方（因为中间会有墙，需根据题目条件继续判定，奇偶剪枝只是把范围缩小了）</span><br><span class="line"></span><br><span class="line">还有就是开头时间步数可移动位置的数量关系，也属于剪枝 勿忘</span><br><span class="line">abs(x-dx)+abs(y-dy)为从当前改点到终点（门)所需要的最短步数，但他会根据总时间的需要进行绕行，奇数步绕行后也是奇数步，偶数步绕行后也是偶数步，故他们之间奇偶性是相同的</span><br><span class="line">2.此题一开始还有个纠结的问题，就是深搜如何搜到符合条件的路径后就直接退出，一开始不知道怎么解决，因为觉得深搜利用了递归，无法return一下，就直接结束，此时用一个ans来解决就OK了，当搜索多条路径时，记得要还原</span><br><span class="line">需要在可能有变化找到结果标志flag及时return，</span><br><span class="line">3.对于下一步要走的路径（1）先确定下一步要走哪个格 用for函数和方向数组（2)通过book标记数组和map地图数组判断这个位置</span><br><span class="line">是否可以走（越界·是否是墙，是否已经测试或者走过）（3）标记这个位置已经走过（4）进入下一位置，传入这一数组（4）将以标记的数组撤回，以便下次再次搜索（6）将</span><br><span class="line">改变的值再改回来</span><br><span class="line">4.注意数组变量是否混合，每一个数组或者变量名是否改变</span><br><span class="line">5，记得初始化，尤其是while函数</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h2><p><code>Problem Description</code><br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br><code>Input</code><br>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)<br><code>Output</code><br>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">45</span><br><span class="line">59</span><br><span class="line">6</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char a[30][30];</span><br><span class="line">int vis[30][30];</span><br><span class="line">int m, n;</span><br><span class="line">int ans;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0</span><br><span class="line">&#125;;</span><br><span class="line">void DFS(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx, yy;</span><br><span class="line">vis[x][y] = 1;</span><br><span class="line"></span><br><span class="line">if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m)</span><br><span class="line">return ;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">xx = x + d[i][0];</span><br><span class="line">yy = y + d[i][1];</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; vis[xx][yy] == 0 &amp;&amp; a[xx][yy] != &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans ++;</span><br><span class="line">DFS(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int sx, sy;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;m, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(m == 0 &amp;&amp; n == 0) break;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">ans = 1;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">if(a[i][j] == &apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">sx = i;</span><br><span class="line">sy = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">DFS(sx, sy);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day7&quot;&gt;&lt;a href=&quot;#Day7&quot; class=&quot;headerlink&quot; title=&quot;Day7&quot;&gt;&lt;/a&gt;Day7&lt;/h1&gt;&lt;p&gt;今天学习的是dfs&lt;br&gt;常规操作~~~~没写完题&lt;br&gt;这次不是debug了，是真的不会(太菜了。。。)&lt;br&gt;&lt;code&gt;未完待续&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Day6</title>
    <link href="http://yoursite.com/2019/07/23/Day6/"/>
    <id>http://yoursite.com/2019/07/23/Day6/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2019-08-05T14:25:24.171Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>今天学习的是 BFS + 存图方法</p><p>BFS:学起来很容易，但是DEBUG是真的累<br>由于自己比较笨，debug时间太长，没写完<br><code>知识点待补</code><br><a id="more"></a></p><p>OJ链接：<a href="https://vjudge.net/contest/313171#overview" target="_blank" rel="noopener">https://vjudge.net/contest/313171#overview</a></p><h2 id="BFS：广度优先搜索"><a href="#BFS：广度优先搜索" class="headerlink" title="BFS：广度优先搜索"></a>BFS：广度优先搜索</h2><p>链接：</p><h2 id="存图方式"><a href="#存图方式" class="headerlink" title="存图方式"></a>存图方式</h2><p><a href="https://blog.csdn.net/acdreamers/article/details/16902023" target="_blank" rel="noopener">链式前向星</a></p><blockquote><p>在了解什么是链式前向星之前，我们先来看一下什么是前向星。前向星其实就是一种边集数组。我们先把每条边的起点按照从小<br>到大的顺序排序如果起点一样，那么就按照终点从小到达来排序。并记录下以某个点为起点的所有边在数组中的起始位置和边<br>的数量,那么前向星就构造好了。</p></blockquote><h2 id="Rescue"><a href="#Rescue" class="headerlink" title="Rescue"></a>Rescue</h2><p><code>Problem Description</code><br>Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.</p><p>Angel’s friends want to save Angel. Their task is: approach Angel. We assume that “approach Angel” is to get to the position where Angel stays. When there’s a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.</p><p>You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.)<br><code>Input</code><br>First line contains two integers stand for N and M.</p><p>Then N lines follows, every line has M characters. “.” stands for road, “a” stands for Angel, and “r” stands for each of Angel’s friend.</p><p>Process to the end of the file.<br><code>Output</code><br>For each test case, your program should output a single integer, standing for the minimal time needed. If such a number does no exist, you should output a line containing “Poor ANGEL has to stay in the prison all his life.”<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">7 8</span><br><span class="line">#.#####.</span><br><span class="line">#.a#..r.</span><br><span class="line">#..#x...</span><br><span class="line">..#..#.#</span><br><span class="line">#...##..</span><br><span class="line">.#......</span><br><span class="line">........</span><br><span class="line">Sample Output</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char a[300][300];</span><br><span class="line">int vis[300][300];</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y;</span><br><span class="line">int step;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step &gt; b.step;</span><br><span class="line">&#125;</span><br><span class="line">//重载运算符，用于自定义优先队列 的排序 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;;</span><br><span class="line">void BFS(int x1, int y1, int x2, int y2)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">//先将全部初始化，方便后面标记 </span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">//优先队列 </span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = x1, e1.y = y1, e1.step = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[x1][y1] = 1;</span><br><span class="line">int ans = -1;//表示不可能只走0步 </span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == x2 &amp;&amp; e1.y == y2)</span><br><span class="line">&#123;</span><br><span class="line">ans = e1.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">//遍历寻找，如果不符合条件就continue </span><br><span class="line">if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= m || vis[e2.x][e2.y] == 1 || a[e2.x][e2.y] == &apos;#&apos;)</span><br><span class="line">continue;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(a[e2.x][e2.y] == &apos;x&apos;) e2.step = e1.step + 2;</span><br><span class="line">else e2.step = e1.step + 1;</span><br><span class="line">&#125;</span><br><span class="line">//遍历完一定要把新的数加入队列！！ </span><br><span class="line">q.push(e2);</span><br><span class="line">vis[e2.x][e2.y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(ans == -1) puts(&quot;Poor ANGEL has to stay in the prison all his life.&quot;);</span><br><span class="line">else cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x1, y1, x2, y2;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">//双重for循环来寻找开始的点和 结束的点 </span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j] == &apos;a&apos;)</span><br><span class="line">&#123;</span><br><span class="line">x1 = i;</span><br><span class="line">y1 = j;</span><br><span class="line">&#125;</span><br><span class="line">if(a[i][j] == &apos;r&apos;)</span><br><span class="line">&#123;</span><br><span class="line">x2 = i;</span><br><span class="line">y2 = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS(x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Red-and-Black"><a href="#Red-and-Black" class="headerlink" title="Red and Black"></a>Red and Black</h2><p><code>Problem Description</code><br>There is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.</p><p>Write a program to count the number of black tiles which he can reach by repeating the moves described above.<br><code>Input</code><br>The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.</p><p>There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.</p><p>‘.’ - a black tile<br>‘#’ - a red tile<br>‘@’ - a man on a black tile(appears exactly once in a data set)<br><code>Output</code><br>For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself).<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6 9</span><br><span class="line">....#.</span><br><span class="line">.....#</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">#@...#</span><br><span class="line">.#..#.</span><br><span class="line">11 9</span><br><span class="line">.#.........</span><br><span class="line">.#.#######.</span><br><span class="line">.#.#.....#.</span><br><span class="line">.#.#.###.#.</span><br><span class="line">.#.#..@#.#.</span><br><span class="line">.#.#####.#.</span><br><span class="line">.#.......#.</span><br><span class="line">.#########.</span><br><span class="line">...........</span><br><span class="line">11 6</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..###</span><br><span class="line">..#..#..#@.</span><br><span class="line">..#..#..#..</span><br><span class="line">..#..#..#..</span><br><span class="line">7 7</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">###.###</span><br><span class="line">...@...</span><br><span class="line">###.###</span><br><span class="line">..#.#..</span><br><span class="line">..#.#..</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">45</span><br><span class="line">59</span><br><span class="line">6</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 300;</span><br><span class="line">int n, m;//n表示行 ,m表示列</span><br><span class="line">char a[mod][mod];</span><br><span class="line">int vis[mod][mod];</span><br><span class="line">int d[4][2] = &#123;0, 1, 0, -1, 1, 0, -1, 0&#125;; </span><br><span class="line"></span><br><span class="line">//struct node&#123;</span><br><span class="line">//int x, y;</span><br><span class="line">//int step;</span><br><span class="line">//用优先队列的时候加上friend bool operator </span><br><span class="line">//friend bool operator &lt; (node a, node b)</span><br><span class="line">//&#123;</span><br><span class="line">//return a.step &gt; b.step;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;;</span><br><span class="line">//优先队列的BFS</span><br><span class="line">//void BFS(int x1, int y1)</span><br><span class="line">//&#123;</span><br><span class="line">//memset(vis, 0, sizeof(vis));</span><br><span class="line">//</span><br><span class="line">//priority_queue&lt;node&gt; q; </span><br><span class="line">//node e1, e2;</span><br><span class="line">//e1.x = x1, e1.y = y1;</span><br><span class="line">//q.push(e1);</span><br><span class="line">//vis[e1.x][e1.y] = 1;</span><br><span class="line">//int num = 1;</span><br><span class="line">//while(!q.empty())</span><br><span class="line">//&#123;</span><br><span class="line">//e1 = q.top();</span><br><span class="line">//q.pop(); </span><br><span class="line">//for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">//&#123;</span><br><span class="line">//e2.x = e1.x + d[i][0];</span><br><span class="line">//e2.y = e1.y + d[i][1];</span><br><span class="line">//if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= m || vis[e2.x][e2.y] == 1 || a[e2.x][e2.y] == &apos;#&apos;) continue;</span><br><span class="line">//else num ++;//e2.step = e1.step + 1; </span><br><span class="line">//q.push(e2);</span><br><span class="line">//vis[e2.x][e2.y] = 1;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//不是优先队列的BFS</span><br><span class="line">//struct node&#123;</span><br><span class="line">//int x, y;</span><br><span class="line">//int step;</span><br><span class="line">//&#125;;</span><br><span class="line">//void BFS(int x1, int y1)</span><br><span class="line">//&#123;</span><br><span class="line">//memset(vis, 0, sizeof(vis));</span><br><span class="line">//</span><br><span class="line">//queue&lt;node&gt; q;</span><br><span class="line">//node e1, e2;</span><br><span class="line">//e1.x = x1, e1.y = y1;</span><br><span class="line">//q.push(e1);</span><br><span class="line">//vis[e1.x][e1.y] = 1;</span><br><span class="line">//int num = 1;</span><br><span class="line">//while(!q.empty())</span><br><span class="line">//&#123;</span><br><span class="line">//e1 = q.top();</span><br><span class="line">//q.pop(); </span><br><span class="line">//for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">//&#123;</span><br><span class="line">//e2.x = e1.x + d[i][0];</span><br><span class="line">//e2.y = e1.y + d[i][1];</span><br><span class="line">//if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= m || vis[e2.x][e2.y] == 1 || a[e2.x][e2.y] == &apos;#&apos;) continue;</span><br><span class="line">//else num ++; </span><br><span class="line">//q.push(e2);</span><br><span class="line">//vis[e2.x][e2.y] = 1;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//int main()</span><br><span class="line">//&#123;</span><br><span class="line">//</span><br><span class="line">//int x1, y1, x2, y2;</span><br><span class="line">//while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n))</span><br><span class="line">//&#123;</span><br><span class="line">//if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">//for(int i = 0; i &lt; n; i ++)</span><br><span class="line">//&#123;</span><br><span class="line">//scanf(&quot;%s&quot;,&amp;a[i]);</span><br><span class="line">//&#125;</span><br><span class="line">//for(int i = 0; i &lt; n; i ++)</span><br><span class="line">//&#123;</span><br><span class="line">//for(int j = 0; j &lt; m; j ++)</span><br><span class="line">//&#123;</span><br><span class="line">//if(a[i][j] == &apos;@&apos;)</span><br><span class="line">//&#123;</span><br><span class="line">//x1 = i;</span><br><span class="line">//y1 = j;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//BFS(x1, y1);</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//return 0;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//DFS </span><br><span class="line">int num;</span><br><span class="line">void DFS(int x1, int y1)</span><br><span class="line">&#123;</span><br><span class="line">int xx, yy;</span><br><span class="line">a[x1][y1] = &apos;#&apos;;</span><br><span class="line">num ++;</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">xx = x1 + d[i][0];</span><br><span class="line">yy = y1 + d[i][1];</span><br><span class="line">if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 || yy &gt;= m || a[xx][yy] == &apos;#&apos;) continue;</span><br><span class="line">else DFS(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x1, y1;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;, &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j] == &apos;@&apos;)</span><br><span class="line">&#123;</span><br><span class="line">x1 = i;</span><br><span class="line">y1 = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">num = 0;</span><br><span class="line">DFS(x1, y1);</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Battle-City"><a href="#Battle-City" class="headerlink" title="Battle City"></a>Battle City</h2><p><code>Problem Description</code><br>Many of us had played the game “Battle city” in our childhood, and some people (like me) even often play it on computer now.<br><img src="/2019/07/23/Day6/1.jpg" alt></p><p>What we are discussing is a simple edition of this game. Given a map that consists of empty spaces, rivers, steel walls and brick walls only. Your task is to get a bonus as soon as possible suppose that no enemies will disturb you (See the following picture).<br><img src="/2019/07/23/Day6/2.jpg" alt></p><p>Your tank can’t move through rivers or walls, but it can destroy brick walls by shooting. A brick wall will be turned into empty spaces when you hit it, however, if your shot hit a steel wall, there will be no damage to the wall. In each of your turns, you can choose to move to a neighboring (4 directions, not 8) empty space, or shoot in one of the four directions without a move. The shot will go ahead in that direction, until it go out of the map or hit a wall. If the shot hits a brick wall, the wall will disappear (i.e., in this turn). Well, given the description of a map, the positions of your tank and the target, how many turns will you take at least to arrive there?<br><code>Input</code><br>The input consists of several test cases. The first line of each test case contains two integers M and N (2 &lt;= M, N &lt;= 300). Each of the following M lines contains N uppercase letters, each of which is one of ‘Y’ (you), ‘T’ (target), ‘S’ (steel wall), ‘B’ (brick wall), ‘R’ (river) and ‘E’ (empty space). Both ‘Y’ and ‘T’ appear only once. A test case of M = N = 0 indicates the end of input, and should not be processed.<br><code>Output</code><br>For each test case, please output the turns you take at least in a separate line. If you can’t arrive at the target, output “-1” instead.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 4</span><br><span class="line">YBEB</span><br><span class="line">EERE</span><br><span class="line">SSTE</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 350;</span><br><span class="line">const int INF = 5;</span><br><span class="line"></span><br><span class="line">char a[mod][mod];</span><br><span class="line">int vis[mod][mod];</span><br><span class="line">int n, k;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y;</span><br><span class="line">int step;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step &gt; b.step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1&#125;;</span><br><span class="line">void BFS(int x1, int y1, int x2, int y2)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = x1, e1.y = y1, e1.step = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[x1][y1] = 1;</span><br><span class="line">int ans = -1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == x2 &amp;&amp; e1.y == y2)</span><br><span class="line">&#123;</span><br><span class="line">ans = e1.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">if(e2.x &lt; 0 || e2.x &gt;= n || e2.y &lt; 0 || e2.y &gt;= k || vis[e2.x][e2.y] == 1) continue;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(a[e2.x][e2.y] == &apos;S&apos; || a[e2.x][e2.y] == &apos;R&apos;) continue;</span><br><span class="line">if(a[e2.x][e2.y] == &apos;B&apos;) e2.step = e1.step + 2;</span><br><span class="line">else e2.step = e1.step + 1;</span><br><span class="line">&#125;</span><br><span class="line">q.push(e2);</span><br><span class="line">vis[e2.x][e2.y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(ans == -1) puts(&quot;-1&quot;);</span><br><span class="line">else cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x1, x2, y1, y2;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;k))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; k == 0) break;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; k; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j] == &apos;Y&apos;)</span><br><span class="line">&#123;</span><br><span class="line">x1 = i;</span><br><span class="line">y1 = j;</span><br><span class="line">&#125;</span><br><span class="line">if(a[i][j] == &apos;T&apos;)</span><br><span class="line">&#123;</span><br><span class="line">x2 = i;</span><br><span class="line">y2 = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS(x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Catch-That-Cow"><a href="#Catch-That-Cow" class="headerlink" title="Catch That Cow"></a>Catch That Cow</h2><p><code>Problem Description</code><br>农夫知道一头牛的位置，想要抓住它。农夫和牛都于数轴上 ，农夫起始位于点 N(0&lt;=N&lt;=100000) ，牛位于点 K(0&lt;=K&lt;=100000) 。农夫有两种移动方式： 1、从 X移动到 X-1或X+1 ，每次移动花费一分钟 2、从 X移动到 2*X ，每次移动花费一分钟 假设牛没有意识到农夫的行动，站在原地不。最少要花多少时间才能抓住牛？<br><code>Input</code><br>一行: 以空格分隔的两个字母: N 和 K<br><code>Output</code><br>一行: 农夫抓住牛需要的最少时间，单位分钟<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 17</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">Hint</span><br><span class="line">农夫使用最短时间抓住牛的方案如下: 5-10-9-18-17, 需要4分钟.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int vis[mod];</span><br><span class="line">int n, k;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x;</span><br><span class="line">int step;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step &gt; b.step;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void BFS(int x1, int x2)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = x1, e1.step = 0;</span><br><span class="line"></span><br><span class="line">vis[e1.x] = 1;</span><br><span class="line">q.push(e1);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == x2) break;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if(e1.x - 1 &gt; 0 &amp;&amp; vis[e1.x - 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x - 1;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">vis[e2.x] = 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">if(e1.x + 1 &lt;= 100000 &amp;&amp; vis[e1.x + 1] == 0)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + 1;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">vis[e2.x] = 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">if(e1.x * 2 &lt;= 100000 &amp;&amp; vis[e1.x * 2] == 0)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x * 2;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">vis[e2.x] = 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; e1.step &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;k))</span><br><span class="line">&#123;</span><br><span class="line">if(n &gt; k) cout &lt;&lt; n - k &lt;&lt; endl;</span><br><span class="line">else BFS(n, k);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Dungeon-Master"><a href="#Dungeon-Master" class="headerlink" title="Dungeon Master"></a>Dungeon Master</h2><p><code>Problem Description</code><br>你被困在一个三维的空间中,现在要寻找最短路径逃生！<br>空间由立方体单位构成<br>你每次向上下前后左右移动一个单位需要一分钟<br>你不能对角线移动并且四周封闭<br>是否存在逃出生天的可能性？如果存在，则需要多少时间？<br><code>Input - 输入</code><br>输入第一行是一个数表示空间的数量。<br>每个空间的描述的第一行为L，R和C（皆不超过30）。<br>L表示空间的高度。<br>R和C分别表示每层空间的行与列的大小。<br>随后L层地牢，每层R行，每行C个字符。<br>每个字符表示空间的一个单元。’#’表示不可通过单元，’.’表示空白单元。你的起始位置在’S’，出口为’E’。<br>每层空间后都有一个空行。L，R和C均为0时输入结束。<br><code>Output - 输出</code><br>每个空间对应一行输出。<br>如果可以逃生，则输出如下<br>Escaped in x minute(s).<br>x为最短脱离时间。<br>如果无法逃生，则输出如下<br>Trapped!<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Sample Input - 输入样例</span><br><span class="line">3 4 5</span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line">1 3 3</span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">0 0 0</span><br><span class="line">Sample Output - 输出样例</span><br><span class="line">Escaped in 11 minute(s).</span><br><span class="line">Trapped!</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 30;</span><br><span class="line"></span><br><span class="line">int L, R, C;</span><br><span class="line">char a[mod][mod][mod];</span><br><span class="line">int vis[mod][mod][mod];</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">int t;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.t &gt; b.t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;s, e, e1;</span><br><span class="line">//判断是否到达终点 </span><br><span class="line">bool yes(node sss)</span><br><span class="line">&#123;</span><br><span class="line">if(sss.x == e.x &amp;&amp; sss.y == e.y &amp;&amp; sss.z == e.z)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断该点是否越界 </span><br><span class="line">bool check(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">if(x &gt;= 0 &amp;&amp; x &lt; L &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; R &amp;&amp; z &gt;= 0 &amp;&amp; z &lt; C &amp;&amp; !vis[x][y][z] &amp;&amp; (a[x][y][z] == &apos;.&apos; || a[x][y][z] == &apos;E&apos;))</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">int d[6][3] = &#123;</span><br><span class="line">1, 0, 0,</span><br><span class="line">-1, 0, 0,</span><br><span class="line">0, 1, 0,</span><br><span class="line">0, -1, 0,</span><br><span class="line">0, 0, 1,</span><br><span class="line">0, 0, -1</span><br><span class="line">&#125;;</span><br><span class="line">int ans;</span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node e2;</span><br><span class="line">e1.x = s.x, e1.y = s.y, e1.z = s.z, e1.t = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y][e1.z] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(yes(e1))</span><br><span class="line">&#123;</span><br><span class="line">ans = e1.t;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 6; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">e2.z = e1.z + d[i][2];</span><br><span class="line">if(check(e2.x, e2.y, e2.z))</span><br><span class="line">&#123;</span><br><span class="line">e2.t = e1.t + 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">vis[e2.x][e2.y][e2.z] = 1;</span><br><span class="line">&#125;</span><br><span class="line">else continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d %d %d&quot;,&amp;L, &amp;R, &amp;C))</span><br><span class="line">&#123;</span><br><span class="line">if(L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) break;</span><br><span class="line">for(int i = 0; i &lt; L; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; R; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; C; k ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; L; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; R; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; C; k ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i][j][k] == &apos;S&apos;)</span><br><span class="line">&#123;</span><br><span class="line">s.x = i;</span><br><span class="line">s.y = j;</span><br><span class="line">s.z = k;</span><br><span class="line">&#125;</span><br><span class="line">if(a[i][j][k] == &apos;E&apos;)</span><br><span class="line">&#123;</span><br><span class="line">e.x = i;</span><br><span class="line">e.y = j;</span><br><span class="line">e.z = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BFS();</span><br><span class="line">if(e1.x == e.x &amp;&amp; e1.y == e.y &amp;&amp; e1.z == e.z)</span><br><span class="line">printf(&quot;Escaped in %d minute(s).\n&quot;, ans);</span><br><span class="line">else</span><br><span class="line">printf(&quot;Trapped!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Robot-Motion"><a href="#Robot-Motion" class="headerlink" title="Robot Motion"></a>Robot Motion</h2><p><code>Problem Description</code><br><img src="/2019/07/23/Day6/3.jpg" alt> <img src="/2019/07/23/Day6/4.jpg" alt><br>A robot has been programmed to follow the instructions in its path. Instructions for the next direction the robot is to move are laid down in a grid. The possible instructions are</p><p>N north (up the page)<br>S south (down the page)<br>E east (to the right on the page)<br>W west (to the left on the page)</p><p>For example, suppose the robot starts on the north (top) side of Grid 1 and starts south (down). The path the robot follows is shown. The robot goes through 10 instructions in the grid before leaving the grid.</p><p>Compare what happens in Grid 2: the robot goes through 3 instructions only once, and then starts a loop through 8 instructions, and never exits.</p><p>You are to write a program that determines how long it takes a robot to get out of the grid or how the robot loops around.<br><code>Input</code><br>There will be one or more grids for robots to navigate. The data for each is in the following form. On the first line are three integers separated by blanks: the number of rows in the grid, the number of columns in the grid, and the number of the column in which the robot enters from the north. The possible entry columns are numbered starting with one at the left. Then come the rows of the direction instructions. Each grid will have at least one and at most 10 rows and columns of instructions. The lines of instructions contain only the characters N, S, E, or W with no blanks. The end of input is indicated by a row containing 0 0 0.<br><code>Output</code><br>For each grid in the input there is one line of output. Either the robot follows a certain number of instructions and exits the grid on any one the four sides or else the robot follows the instructions on a certain number of locations once, and then the instructions on some number of locations repeatedly. The sample input below corresponds to the two grids above and illustrates the two forms of output. The word “step” is always immediately followed by “(s)” whether or not the number before it is 1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 6 5</span><br><span class="line">NEESWE</span><br><span class="line">WWWESS</span><br><span class="line">SNWWWW</span><br><span class="line">4 5 1</span><br><span class="line">SESWE</span><br><span class="line">EESNW</span><br><span class="line">NWEEN</span><br><span class="line">EWSEN</span><br><span class="line">0 0 0</span><br><span class="line">Sample Output</span><br><span class="line">10 step(s) to exit</span><br><span class="line">3 step(s) before a loop of 8 step(s)</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[12][12];</span><br><span class="line">int vis[12][12];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b,c;</span><br><span class="line">while(scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;c))</span><br><span class="line">&#123;</span><br><span class="line">if(a==0&amp;&amp;b==0&amp;&amp;c==0)break;</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">cin&gt;&gt;s[i][j];</span><br><span class="line">int x=0,y=c-1,step=0;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">step++;</span><br><span class="line">if(s[x][y]==&apos;N&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">x--;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;S&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;W&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">y--;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[x][y]==&apos;E&apos;&amp;&amp;!vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">vis[x][y]=step;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">if(x&lt;0||x==a||y&lt;0||y==b)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d step(s) to exit\n&quot;,step);break;</span><br><span class="line">&#125;</span><br><span class="line">else if(vis[x][y])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d step(s) before a loop of %d step(s)\n&quot;,vis[x][y]-1,step+1-vis[x][y]);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Number-Transformation"><a href="#Number-Transformation" class="headerlink" title="Number Transformation"></a>Number Transformation</h2><p><code>Problem Description</code><br>In this problem, you are given an integer number s. You can transform any integer number A to another integer number B by adding x to A. This x is an integer number which is a prime factor of A (please note that 1 and A are not being considered as a factor of A). Now, your task is to find the minimum number of transformations required to transform s to another integer number t.<br><code>Input</code><br>Input starts with an integer T (≤ 500), denoting the number of test cases.<br>Each case contains two integers: s (1 ≤ s ≤ 100) and t (1 ≤ t ≤ 1000).<br><code>Output</code><br>For each case, print the case number and the minimum number of transformations needed. If it’s impossible, then print -1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">6 12</span><br><span class="line">6 13</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 2</span><br><span class="line">Case 2: -1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line"></span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, step;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.step &gt; b.step; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool vis[10010];</span><br><span class="line">int p[10010];</span><br><span class="line">int s, t, k, ans;</span><br><span class="line"></span><br><span class="line">void prime(int n)</span><br><span class="line">&#123;</span><br><span class="line">k = 0;</span><br><span class="line">int m;</span><br><span class="line">m = n;</span><br><span class="line">for(int i = 2; i &lt;= sqrt(n); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(n % i == 0)</span><br><span class="line">&#123;</span><br><span class="line">p[++ k] = i;</span><br><span class="line">while(n % i == 0) n /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n &gt; 1 &amp;&amp; m != n) p[++ k] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = s, e1.step = 0;</span><br><span class="line">vis[s] = 1;</span><br><span class="line">q.push(e1);</span><br><span class="line">bool flag = 0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == t)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">ans = min(ans, e1.step);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">memset(p, 0, sizeof(p));</span><br><span class="line">prime(e1.x);</span><br><span class="line">for(int i = 1; i &lt;= k; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + p[i];</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">if(e2.x &lt;= t &amp;&amp; !vis[e2.x])</span><br><span class="line">&#123;</span><br><span class="line">vis[e2.x] = 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">else puts(&quot;-1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, kase = 0;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">ans = INF;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">printf(&quot;Case %d: &quot;, ++ kase);</span><br><span class="line">if(s == t)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;0&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(s &gt; t)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;-1&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">BFS();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h2><p><code>Problem Description</code><br>A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br>Of course you know that it is vice versa. So you offer him to write a program that solves the “difficult” part.<br>Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b.<br><code>Input</code><br>The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.<br><code>Output</code><br>For each test case, print one line saying “To get from xx to yy takes n knight moves.”.<br><img src="/2019/07/23/Day6/5.png" alt><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">e2 e4</span><br><span class="line">a1 b2</span><br><span class="line">b2 c3</span><br><span class="line">a1 h8</span><br><span class="line">a1 h7</span><br><span class="line">h8 a1</span><br><span class="line">b1 c3</span><br><span class="line">f6 f6</span><br><span class="line">Sample Output</span><br><span class="line">To get from e2 to e4 takes 2 knight moves.</span><br><span class="line">To get from a1 to b2 takes 4 knight moves.</span><br><span class="line">To get from b2 to c3 takes 2 knight moves.</span><br><span class="line">To get from a1 to h8 takes 6 knight moves.</span><br><span class="line">To get from a1 to h7 takes 5 knight moves.</span><br><span class="line">To get from h8 to a1 takes 6 knight moves.</span><br><span class="line">To get from b1 to c3 takes 1 knight moves.</span><br><span class="line">To get from f6 to f6 takes 0 knight moves.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define max_v 30</span><br><span class="line">int vis[max_v][max_v];</span><br><span class="line">int dir[8][2]= &#123;1,-2,2,-1,2,1,1,2,-1,2,-2,1,-2,-1,-1,-2&#125;;</span><br><span class="line">int ans;</span><br><span class="line">int sx, sy, fx, fy;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis, 0, sizeof(vis));</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    node e1, e2;</span><br><span class="line">    e1.x = sx;</span><br><span class="line">    e1.y = sy;</span><br><span class="line">    e1.step = 0;</span><br><span class="line">    vis[e1.x][e1.y] = 1;</span><br><span class="line">    q.push(e1);</span><br><span class="line"></span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        e1 = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        if(e1.x == fx &amp;&amp; e1.y == fy)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = e1.step;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 8; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            e2.x = e1.x + dir[i][0];</span><br><span class="line">            e2.y = e1.y + dir[i][1];</span><br><span class="line"></span><br><span class="line">            if(e2.x &gt;= 1 &amp;&amp; e2.y &gt;= 1 &amp;&amp; e2.x &lt;= 8 &amp;&amp; e2.y &lt;= 8 &amp;&amp; vis[e2.x][e2.y] == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                e2.step = e1.step + 1;</span><br><span class="line">                vis[e2.x][e2.y] = 1;</span><br><span class="line">                q.push(e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char x1, x2;</span><br><span class="line">    int y1, y2;</span><br><span class="line">    </span><br><span class="line">    while(~scanf(&quot;%c%d %c%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2))</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        sx=x1-&apos;a&apos;+1;</span><br><span class="line">        sy=y1;</span><br><span class="line">        fx=x2-&apos;a&apos;+1;</span><br><span class="line">        fy=y2;</span><br><span class="line">        BFS();</span><br><span class="line">        printf(&quot;To get from %c%d to %c%d takes %d knight moves.\n&quot;,x1, y1, x2, y2, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day6&quot;&gt;&lt;a href=&quot;#Day6&quot; class=&quot;headerlink&quot; title=&quot;Day6&quot;&gt;&lt;/a&gt;Day6&lt;/h1&gt;&lt;p&gt;今天学习的是 BFS + 存图方法&lt;/p&gt;&lt;p&gt;BFS:学起来很容易，但是DEBUG是真的累&lt;br&gt;由于自己比较笨，debug时间太长，没写完&lt;br&gt;&lt;code&gt;知识点待补&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Day5</title>
    <link href="http://yoursite.com/2019/07/22/Day5/"/>
    <id>http://yoursite.com/2019/07/22/Day5/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-07-22T16:15:03.488Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>今天学习的是二分 + 贪心<br>额，又是艰难的一天<br>题写不完，只能慢慢补题了</p><a id="more"></a><h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><p>二分查找法作为一种常见的查找方法，将原本是线性时间提升到了对数时间范围，大大缩短了搜索时间，但它有一个前提，就是必须在有序数据中进行查找。</p><h2 id="最基本的二分查找"><a href="#最基本的二分查找" class="headerlink" title="最基本的二分查找"></a>最基本的二分查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] A, int target, int n)&#123;</span><br><span class="line">    int low = 0, high = n, mid;</span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line">        mid = low + (high - low) / 2;</span><br><span class="line">        if(A[mid] == target)&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;else if(A[mid] &gt; target)&#123;</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><blockquote><p>循环的判定条件是：low &lt;= high<br>为了防止数值溢出，mid = low + (high - low)/2<br>当 A[mid]不等于target时，high = mid - 1或low = mid + 1</p></blockquote><h2 id="查找目标值区域的左边界-查找与目标值相等的第一个位置-查找第一个不小于目标值数的位置"><a href="#查找目标值区域的左边界-查找与目标值相等的第一个位置-查找第一个不小于目标值数的位置" class="headerlink" title="查找目标值区域的左边界/查找与目标值相等的第一个位置/查找第一个不小于目标值数的位置"></a>查找目标值区域的左边界/查找与目标值相等的第一个位置/查找第一个不小于目标值数的位置</h2><p>A = [1,3,3,5, 7 ,7,7,7,8,14,14]<br>target = 7<br>return 4<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearchLowerBound(int[] A, int target, int n)&#123;</span><br><span class="line">    int low = 0, high = n, mid;</span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line">        mid = low + (high - low) / 2;</span><br><span class="line">        if(target &lt;= A[mid])&#123;</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(low &lt; A.length &amp;&amp; A[low] == target)</span><br><span class="line">        return low;</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="查找目标值区域的右边界-查找与目标值相等的最后一个位置-查找最后一个不大于目标值数的位置"><a href="#查找目标值区域的右边界-查找与目标值相等的最后一个位置-查找最后一个不大于目标值数的位置" class="headerlink" title="查找目标值区域的右边界/查找与目标值相等的最后一个位置/查找最后一个不大于目标值数的位置"></a>查找目标值区域的右边界/查找与目标值相等的最后一个位置/查找最后一个不大于目标值数的位置</h2><p>A = [1,3,3,5,7,7,7, 7 ,8,14,14]<br>target = 7<br>return 7<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearchUpperBound(int[] A, int target, int n)&#123;</span><br><span class="line">    int low = 0, high = n, mid;</span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line">        mid = low + (high - low) / 2;</span><br><span class="line">        if(target &gt;= A[mid])&#123;</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(high &gt;= 0 &amp;&amp; A[high] == target)</span><br><span class="line">        return high;</span><br><span class="line">    else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="查找最后一个小于目标值的数-查找比目标值小但是最接近目标值的数"><a href="#查找最后一个小于目标值的数-查找比目标值小但是最接近目标值的数" class="headerlink" title="查找最后一个小于目标值的数/查找比目标值小但是最接近目标值的数"></a>查找最后一个小于目标值的数/查找比目标值小但是最接近目标值的数</h2><p>A = [1,3,3, 5 ,7,7,7,7,8,14,14]<br>target = 7<br>return 3<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int low = 0, high = n, mid;</span><br><span class="line">while(low &lt;= high)&#123;</span><br><span class="line">    mid = low + (high - low) / 2;</span><br><span class="line">    if(target &lt;= A[mid])&#123;</span><br><span class="line">        high = mid - 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        low = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return high &lt; 0 ? -1 : high;</span><br></pre></td></tr></table></figure><p></p><h2 id="查找第一个大于目标值的数-查找比目标值大但是最接近目标值的数"><a href="#查找第一个大于目标值的数-查找比目标值大但是最接近目标值的数" class="headerlink" title="查找第一个大于目标值的数/查找比目标值大但是最接近目标值的数"></a>查找第一个大于目标值的数/查找比目标值大但是最接近目标值的数</h2><p>A = [1,3,3,5,7,7,7,7, 8 ,14,14]<br>target = 7<br>return 8<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int low = 0, high = n, mid;</span><br><span class="line">while(low &lt;= high)&#123;</span><br><span class="line">    mid = low + (high - low) / 2;</span><br><span class="line">    if(target &gt;= A[mid])&#123;</span><br><span class="line">        low = mid + 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        high = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return low &gt; n ? -1 : low;</span><br></pre></td></tr></table></figure><p></p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="基本认识："><a href="#基本认识：" class="headerlink" title="基本认识："></a>基本认识：</h2><p>在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><h2 id="经典例题："><a href="#经典例题：" class="headerlink" title="经典例题："></a>经典例题：</h2><p>哈夫曼树构造价值问题：<a href="https://blog.csdn.net/likunkun__/article/details/80258515" target="_blank" rel="noopener">https://blog.csdn.net/likunkun__/article/details/80258515</a><br>不完全（可拆分）背包问题：<a href="https://blog.csdn.net/likunkun__/article/details/80145612" target="_blank" rel="noopener">https://blog.csdn.net/likunkun__/article/details/80145612</a><br>海岸雷达问题：<a href="https://blog.csdn.net/likunkun__/article/details/80230259" target="_blank" rel="noopener">https://blog.csdn.net/likunkun__/article/details/80230259</a><br>普通字符串变换成回文字符串问题：<a href="https://blog.csdn.net/likunkun__/article/details/80230341" target="_blank" rel="noopener">https://blog.csdn.net/likunkun__/article/details/80230341</a></p><h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><p>1.建立数学模型来描述问题。<br>2.把求解的问题分成若干个子问题。<br>3.对每一子问题求解，得到子问题的局部最优解。<br>4.把子问题的解局部最优解合成原来解问题的一个解。</p><h2 id="使用的问题"><a href="#使用的问题" class="headerlink" title="使用的问题"></a>使用的问题</h2><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p><h2 id="贪心策略的选择"><a href="#贪心策略的选择" class="headerlink" title="贪心策略的选择"></a>贪心策略的选择</h2><p>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><p>OJ链接：<a href="https://cn.vjudge.net/contest/313049#overview" target="_blank" rel="noopener">https://cn.vjudge.net/contest/313049#overview</a></p><h2 id="Pie"><a href="#Pie" class="headerlink" title="Pie"></a>Pie</h2><p><code>Problem Description</code><br>My birthday is coming up and traditionally I’m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.</p><p>My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.</p><p>What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.<br><code>Input</code><br>One line with a positive integer: the number of test cases. Then for each test case:<br>—One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.<br>—One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.<br><code>Output</code><br>For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3).<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">3 3</span><br><span class="line">4 3 3</span><br><span class="line">1 24</span><br><span class="line">5</span><br><span class="line">10 5</span><br><span class="line">1 4 2 3 4 5 6 5 4 2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define PI acos(-1)     // acos(-1) -1的反余弦函数值,等于3.141593 </span><br><span class="line">using namespace std;</span><br><span class="line">int T, n, m, t;</span><br><span class="line">double a[10020];</span><br><span class="line">bool fun(double x)</span><br><span class="line">&#123;</span><br><span class="line">double ans = 0;</span><br><span class="line">for(int i = 0; i &lt; x; i ++)</span><br><span class="line">&#123;</span><br><span class="line">ans += (int)(a[i] / x);// 为了防止每个人能分到&quot;最大的馅饼&quot;，</span><br><span class="line">// 拿每个馅饼的体积去除以单个馅饼能分给每一个人最大的体积，这样得到的就是所有人分到的最大的馅饼体积的和</span><br><span class="line">&#125;</span><br><span class="line">if(ans &gt;= m + 1) return 1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">double ans = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">a[i] = t * t * PI;</span><br><span class="line">&#125;</span><br><span class="line">sort(a, a + n);</span><br><span class="line">double l = 0,r = a[n - 1];</span><br><span class="line">double mid = (l + r) / 2;</span><br><span class="line">while(r - l &gt;= 0.0000001)</span><br><span class="line">&#123;</span><br><span class="line">if(fun(mid)) l = mid;</span><br><span class="line">else r = mid;</span><br><span class="line">mid = (r + l) / 2;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.4lf\n&quot;,mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">分馅饼，馅饼高度都为1，所以馅饼的体积V=π*r*r*1=π*r*r;分到最大馅饼的体积是：所有馅饼体积之和/（F+1）；</span><br><span class="line">（为什么不能是直接所有馅饼之和/（F+1）呢？因为每人只能分到一块，如果讲究平均分的话，一个人分到的就是拼凑起来的“最大的体积”，</span><br><span class="line">一个人甚至可能得到超过一块馅饼）最小即为0，然后我们对这两个最大最小值采用二分方法，求出中间符合最大的体积。那么怎么判断那个值就是最大的体积呢？</span><br><span class="line">让每个馅饼的体积/能分到最大的体积=能分到的人数，然后将每个馅饼能分到的人数相加，将该人数与F+1做判断比较，然后就是熟悉的套路了。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="Best-Cow-Line"><a href="#Best-Cow-Line" class="headerlink" title="Best Cow Line"></a>Best Cow Line</h2><p><code>Problem Description</code><br>FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.<br>The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.<br>FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.<br>FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.<br>Given the initial order of his cows, determine the least lexicographic string of initials he can make this way.<br><code>Input</code></p><ul><li>Line 1: A single integer: N</li><li>Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original line<br><code>Output</code><br>The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6</span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line">D</span><br><span class="line">B</span><br><span class="line">C</span><br><span class="line">B</span><br><span class="line">Sample Output</span><br><span class="line">ABCBCD</span><br></pre></td></tr></table></figure></li></ul><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char a [2010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int s = 0, e = n - 1, flag = 0;</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">while(s &lt;= e)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt;= e - s; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[s + i] &lt; a[e - i])</span><br><span class="line">&#123;</span><br><span class="line">ans ++;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(a[s + i] &gt; a[e - i])</span><br><span class="line">&#123;</span><br><span class="line">flag = 0;</span><br><span class="line">ans ++;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) cout &lt;&lt; a[s ++];</span><br><span class="line">else cout &lt;&lt; a[e --];</span><br><span class="line">if(ans % 80 == 0) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Trailing-Zeroes-III"><a href="#Trailing-Zeroes-III" class="headerlink" title="Trailing Zeroes (III)"></a>Trailing Zeroes (III)</h2><p><code>Problem Description</code><br>You task is to find minimal natural number N, so that N! contains exactly Q zeroes on the trail in decimal notation. As you know N! = 1<em>2</em>…*N. For example, 5! = 120, 120 contains one zero on the trail.<br><code>Input</code><br>Input starts with an integer T (≤ 10000), denoting the number of test cases.<br>Each case contains an integer Q (1 ≤ Q ≤ 108) in a line.<br><code>Output</code><br>For each case, print the case number and N. If no solution is found then print ‘impossible’.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 5</span><br><span class="line">Case 2: 10</span><br><span class="line">Case 3: impossible</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e9;</span><br><span class="line">ll f(ll n)</span><br><span class="line">&#123;</span><br><span class="line">ll ans = 0;</span><br><span class="line">while(n)</span><br><span class="line">&#123;</span><br><span class="line">ans += n / 5;</span><br><span class="line">n = n / 5;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, q;</span><br><span class="line">ll ans;</span><br><span class="line">int Case=0;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">Case ++;</span><br><span class="line">int l = 1, r = maxx;</span><br><span class="line">ll mid;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line">while(l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; 1;</span><br><span class="line">if(f(mid) == q)</span><br><span class="line">&#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - 1; </span><br><span class="line">&#125;</span><br><span class="line">else if(f(mid) &lt; q) l = mid + 1;</span><br><span class="line">else r = mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">if(ans) printf(&quot;Case %d: %lld&quot;,Case, ans);</span><br><span class="line">else printf(&quot;Case %d: impossible&quot;,Case);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="The-Frog’s-Games"><a href="#The-Frog’s-Games" class="headerlink" title="The Frog’s Games"></a>The Frog’s Games</h2><p><code>Problem Description</code><br>The annual Games in frogs’ kingdom started again. The most famous game is the Ironfrog Triathlon. One test in the Ironfrog Triathlon is jumping. This project requires the frog athletes to jump over the river. The width of the river is L (1&lt;= L &lt;= 1000000000). There are n (0&lt;= n &lt;= 500000) stones lined up in a straight line from one side to the other side of the river. The frogs can only jump through the river, but they can land on the stones. If they fall into the river, they<br>are out. The frogs was asked to jump at most m (1&lt;= m &lt;= n+1) times. Now the frogs want to know if they want to jump across the river, at least what ability should they have. (That is the frog’s longest jump distance).<br><code>Input</code><br>The input contains several cases. The first line of each case contains three positive integer L, n, and m.<br>Then n lines follow. Each stands for the distance from the starting banks to the nth stone, two stone appear in one place is impossible.<br><code>Output</code><br>For each case, output a integer standing for the frog’s ability at least they should have.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6 1 2</span><br><span class="line">2</span><br><span class="line">25 3 3</span><br><span class="line">11 </span><br><span class="line">2</span><br><span class="line">18</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补</p><h2 id="湫湫系列故事——消灭兔子"><a href="#湫湫系列故事——消灭兔子" class="headerlink" title="湫湫系列故事——消灭兔子"></a>湫湫系列故事——消灭兔子</h2><p><code>Problem Description</code><br>湫湫减肥<br>越减越肥！<br><br>最近，减肥失败的湫湫为发泄心中郁闷，在玩一个消灭免子的游戏。<br>游戏规则很简单，用箭杀死免子即可。<br>箭是一种消耗品，已知有M种不同类型的箭可以选择，并且每种箭都会对兔子造成伤害，对应的伤害值分别为Di（1 &lt;= i &lt;= M），每种箭需要一定的QQ币购买。<br>假设每种箭只能使用一次，每只免子也只能被射一次，请计算要消灭地图上的所有兔子最少需要的QQ币。<br><code>Input</code><br>输入数据有多组，每组数据有四行；<br>第一行有两个整数N，M（1 &lt;= N, M &lt;= 100000），分别表示兔子的个数和箭的种类；<br>第二行有N个正整数，分别表示兔子的血量Bi（1 &lt;= i &lt;= N）；<br>第三行有M个正整数，表示每把箭所能造成的伤害值Di（1 &lt;= i &lt;= M）；<br>第四行有M个正整数，表示每把箭需要花费的QQ币Pi（1 &lt;= i &lt;= M）。</p><p>特别说明：<br>1、当箭的伤害值大于等于兔子的血量时，就能将兔子杀死；<br>2、血量Bi，箭的伤害值Di，箭的价格Pi，均小于等于100000。<br><code>Output</code><br>如果不能杀死所有兔子，请输出”No”，否则，请输出最少的QQ币数，每组输出一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">1 2 3</span><br><span class="line">3 4</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3 4</span><br><span class="line">1 2 3 1</span><br><span class="line">Sample Output</span><br><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补</p><h2 id="Strange-fuction"><a href="#Strange-fuction" class="headerlink" title="Strange fuction"></a>Strange fuction</h2><p><code>Problem Description</code><br>Now, here is a fuction:<br>F(x) = 6 <em>x^7+8</em>x^6+7<em>x^3+5</em>x^2-y*x (0 &lt;= x &lt;=100)<br>Can you find the minimum value when x is between 0 and 100.<br><code>Input</code><br>The first line of the input contains an integer T(1&lt;=T&lt;=100) which means the number of test cases. Then T lines follow, each line has only one real numbers Y.(0 &lt; Y &lt;1e10)<br><code>Output</code><br>Just the minimum value (accurate up to 4 decimal places),when x is between 0 and 100.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">Sample Output</span><br><span class="line">-74.4291</span><br><span class="line">-178.8534</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double mod = 1e-6;</span><br><span class="line"></span><br><span class="line">double qiu_y(double x)</span><br><span class="line">&#123;</span><br><span class="line">return 42 * pow(x, 6.0) + 48 * pow(x, 5.0) + 21 * pow(x, 2.0) + 10 * x;</span><br><span class="line">&#125;</span><br><span class="line">double f(double x, double y)</span><br><span class="line">&#123;</span><br><span class="line">return 6 * pow(x, 7) + 8 * pow(x, 6) + 7 * pow(x, 3) + 5 * pow(x, 2) - x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">double l, r, mid, y, res;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; y;</span><br><span class="line">l = 0.0, r = 100.0;</span><br><span class="line">while(r - l &gt; mod)</span><br><span class="line">&#123;</span><br><span class="line">mid = (r + l) / 2;</span><br><span class="line">res = qiu_y(mid);</span><br><span class="line">if(res &lt; y)</span><br><span class="line">&#123;</span><br><span class="line">l = mid + 1e-8;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">r = mid - 1e-8;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%0.4lf\n&quot;,f(mid, y));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">相当于y是个常数求 F(x) = 6 * x^7+8*x^6+7*x^3+5*x^2-y*x (0 &lt;= x &lt;=100)这个函数的最小值，令F&apos; = 0，得出x，y的方程，</span><br><span class="line">用二分法解方程得x0(易证得x0&gt;=0 &amp;&amp; x0&lt;=100)，则F&apos;(x0) = 0,由F&apos;&apos; 在[0-100]上恒大于0，</span><br><span class="line">所以F&apos;在[0-100]上单增，所以F&apos;(x)&lt;0(x&lt;x0),F&apos;(x)&gt;0(x&gt;x0),所以F(x)在x=x0处取得最小值，所以本题主要就是二分求解方程的x0，然后直接带入x0，y计算即可。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="Can-you-find-it"><a href="#Can-you-find-it" class="headerlink" title="Can you find it?"></a>Can you find it?</h2><p><code>Problem Description</code><br>Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X.<br><code>Input</code><br>There are many cases. Every data case is described as followed: In the first line there are three integers L, N, M, in the second line there are L integers represent the sequence A, in the third line there are N integers represent the sequences B, in the forth line there are M integers represent the sequence C. In the fifth line there is an integer S represents there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500, 1&lt;=S&lt;=1000. all the integers are 32-integers.<br><code>Output</code><br>For each case, firstly you have to print the case number as the form “Case d:”, then for the S queries, you calculate if the formula can be satisfied or not. If satisfied, you print “YES”, otherwise print “NO”.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">10</span><br><span class="line">Sample Output</span><br><span class="line">Case 1:</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补</p><h2 id="pairs"><a href="#pairs" class="headerlink" title="pairs"></a>pairs</h2><p><code>Problem Description</code><br>John has n<br>points on the X axis, and their coordinates are (x[i],0),(i=0,1,2,…,n−1)<br>He wants to know how many pairs&lt;a,b&gt;<br>that |x[b]−x[a]|≤k.(a&lt;b)</p><p><code>Input</code><br>The first line contains a single integer T<br>(about 5), indicating the number of cases.<br>Each test case begins with two integers n,k(1≤n≤100000,1≤k≤109),<br>Next n<br>lines contain an integer x<a href="−109≤x[i]≤109">i</a>,<br>means the X coordinates.<br><code>Output</code><br>For each case, output an integer means how many pairs&lt;a,b&gt;<br>that |x[b]−x[a]|≤k<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 5</span><br><span class="line">-100</span><br><span class="line">0</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">5 300</span><br><span class="line">-100</span><br><span class="line">0</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补</p><h2 id="Radar-Installation"><a href="#Radar-Installation" class="headerlink" title="Radar Installation"></a>Radar Installation</h2><p><code>Problem Description</code><br>Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d.</p><p>We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates.</p><p><img src="https://i.loli.net/2019/07/22/5d35ca862696094171.png" alt><br>Figure A Sample Input of Radar Installations<br><code>Input</code><br>The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases.</p><p>The input is terminated by a line containing pair of zeros<br><code>Output</code><br>For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">-3 1</span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line">1 2</span><br><span class="line">0 2</span><br><span class="line"></span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 2</span><br><span class="line">Case 2: 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补</p><h2 id="Aggressive-cows"><a href="#Aggressive-cows" class="headerlink" title="Aggressive cows"></a>Aggressive cows</h2><p><code>Problem Description</code><br>Farmer John has built a new long barn, with N (2 &lt;= N &lt;= 100,000) stalls. The stalls are located along a straight line at positions x1,…,xN (0 &lt;= xi &lt;= 1,000,000,000).</p><p>His C (2 &lt;= C &lt;= N) cows don’t like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, FJ want to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?<br><code>Input</code></p><ul><li><p>Line 1: Two space-separated integers: N and C</p></li><li><p>Lines 2..N+1: Line i+1 contains an integer stall location, xi<br><code>Output</code></p></li><li>Line 1: One integer: the largest minimum distance<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">Hint</span><br><span class="line">OUTPUT DETAILS: </span><br><span class="line"></span><br><span class="line">FJ can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3. </span><br><span class="line"></span><br><span class="line">Huge input data,scanf is recommended.</span><br></pre></td></tr></table></figure></li></ul><p>code:<br>待补</p><h2 id="River-Hopscotch"><a href="#River-Hopscotch" class="headerlink" title="River Hopscotch"></a>River Hopscotch</h2><p><code>Problem Description</code><br>Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, L units away from the start (1 ≤ L ≤ 1,000,000,000). Along the river between the starting and ending rocks, N (0 ≤ N ≤ 50,000) more rocks appear, each at an integral distance Di from the start (0 &lt; Di &lt; L).<br>To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.<br>Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to M rocks (0 ≤ M ≤ N).<br>FJ wants to know exactly how much he can increase the shortest distance <em>before</em> he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of M rocks.<br><code>Input</code><br>Line 1: Three space-separated integers: L, N, and M<br>Lines 2.. N+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.<br><code>Output</code><br>Line 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing M rocks<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">25 5 2</span><br><span class="line">2</span><br><span class="line">14</span><br><span class="line">11</span><br><span class="line">21</span><br><span class="line">17</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">Hint</span><br><span class="line">Before removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day5&quot;&gt;&lt;a href=&quot;#Day5&quot; class=&quot;headerlink&quot; title=&quot;Day5&quot;&gt;&lt;/a&gt;Day5&lt;/h1&gt;&lt;p&gt;今天学习的是二分 + 贪心&lt;br&gt;额，又是艰难的一天&lt;br&gt;题写不完，只能慢慢补题了&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Day4</title>
    <link href="http://yoursite.com/2019/07/21/Day4/"/>
    <id>http://yoursite.com/2019/07/21/Day4/</id>
    <published>2019-07-21T14:27:57.680Z</published>
    <updated>2019-07-22T14:46:13.085Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p><code>第一次积分赛</code><br>今天打了第一次积分赛，有点小激动<br>虽然没有大佬们那样NB吧，但至少咱们没爆零(以前的事谁有能记得清楚，是不？)<br>归根结底，还是自己太菜了<br>总结一下，积分赛还是学到了很多知识的<br>不一一列举了，都会在代码中体现的(主要是很多新函数的加入！！！)<br><a id="more"></a></p><p>OJ链接：<a href="https://hpuoj.com/contest/22/" target="_blank" rel="noopener">https://hpuoj.com/contest/22/</a><br>PS：我们学校OJ不太厉害，可能登不上去。。。</p><h2 id="Nth-power-of-n"><a href="#Nth-power-of-n" class="headerlink" title="Nth power of n"></a>Nth power of n</h2><p><code>Problem Description</code><br>求 n^n 的个位数。</p><p><code>输入格式</code><br>多组输入，处理到文件结束。<br>每组数据输入一个 n。(1≤n≤1e9)</p><p><code>输出格式</code><br>输出 nn 的个位数。</p><p>样例<br>input<br>1<br>2<br>3<br>output<br>1<br>4<br>7</p><p>Solve:<br>快速幂即可，答案即为 n^n%10<br>复杂度 O(nlog(n))</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">ll quick_pow(ll a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">ll res = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = res * a % mod;</span><br><span class="line">a = a * a % mod;</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; quick_pow(n, n) % 10 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="复读机的力量"><a href="#复读机的力量" class="headerlink" title="复读机的力量"></a>复读机的力量</h2><p><code>Problem Description</code><br>Codancer: “我好菜啊！”<br>Dicer: “我好菜啊！”<br>Todest: “我好菜啊！”<br>CaprYang: “我好菜啊！”<br>…<br>大佬们又开始装弱了，真正的菜鸡瑟瑟发抖不敢说话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>我们规定一个人是复读机当且仅当他说的每一句话都是复读前一个人说的话。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。<br>规定一个复读机的熟练度为复读数量的多少。现在给你一段聊天记录，请你找出其中的复读机们。</p><p><code>输入格式</code><br>输入T组,(1≤T≤10)<br>每组第一行输入一个正整数N,表示聊天记录的长度（1≤N≤10000）。<br>接下来N行，每行两个字符串，前一个字符串为姓名，后一个字符为聊天记录。<br>保证所有字符串长度不超过50，保证所有字符串只包含小写字母.</p><p><code>输出格式</code><br>如果没有复读机，输出 “Unbelievable!”(不包含引号）<br>否则按照熟练度从大到小输出所有的复读机，如果熟练度相同，按照字典序从小到大输出。</p><p>样例<br>input<br>1<br>4<br>codancer iamsovegetable<br>dicer iamsovegetable<br>todest iamsovegetable<br>capryang iamsovegetable<br>output<br>capryang<br>dicer<br>todest<br>提示<br>数据保证上面大佬们说的话都是瞎话。</p><p>Solve:<br>只要有一次某个人不是复读的就不是复读机<br>第一个人一定不是复读机<br>使用 map&lt;string,bool&gt; 判断这个人是否是复读机<br>使用 map&lt;string,int&gt; 记录这个人复读的次数<br>用结构体记录排序<br>复杂度 O(n * log(n))</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">string x,y;</span><br><span class="line">&#125;p[10005];</span><br><span class="line">struct nod&#123;</span><br><span class="line">string na;</span><br><span class="line">int fo;</span><br><span class="line">&#125;pp[10005];</span><br><span class="line">bool cmp(nod m,nod n)</span><br><span class="line">&#123;</span><br><span class="line">if(m.fo==n.fo)return m.na&lt;n.na;</span><br><span class="line">return m.fo&gt;n.fo;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,n;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">string x,y;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">set&lt;string&gt; se;</span><br><span class="line">map&lt;string,int&gt; ma;</span><br><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">se.insert(p[i].x);</span><br><span class="line">ma[p[i].x]=1;</span><br><span class="line">&#125;</span><br><span class="line">ma[p[0].x]=0;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(p[i].y==p[i-1].y)</span><br><span class="line">mp[p[i].x]++;</span><br><span class="line">if(p[i].y!=p[i-1].y)</span><br><span class="line">ma[p[i].x]=0;</span><br><span class="line">&#125;</span><br><span class="line">int pos=0;</span><br><span class="line">for(set&lt;string&gt;::iterator it=se.begin();it!=se.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">if(ma[*it])</span><br><span class="line">&#123;</span><br><span class="line">pp[pos].na=*it;</span><br><span class="line">pp[pos].fo=mp[*it];</span><br><span class="line">pos++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(pos==0) puts(&quot;Unbelievable!&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">sort(pp,pp+pos,cmp);</span><br><span class="line">for(int i=0;i&lt;pos;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;pp[i].na&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>官方code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">struct peo&#123;</span><br><span class="line">string name;</span><br><span class="line">int num;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;peo&gt; all;</span><br><span class="line">map&lt;string,bool&gt; jud;</span><br><span class="line">map&lt;string,int&gt; num;</span><br><span class="line">string a[N],b[N];</span><br><span class="line">set&lt;string&gt; name;</span><br><span class="line">bool cmp(peo a,peo b)&#123;</span><br><span class="line">if(a.num==b.num) return a.name&lt;b.name;</span><br><span class="line">return a.num&gt;b.num;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">int n;</span><br><span class="line">jud.clear();num.clear();name.clear();all.clear();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],jud[a[i]]=1,num[a[i]]=0,name.insert(a[i]);</span><br><span class="line">jud[a[1]]=0;</span><br><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">if(b[i]!=b[i-1])&#123;</span><br><span class="line">jud[a[i]]=0;</span><br><span class="line">&#125;</span><br><span class="line">num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">for(auto v:name)&#123;</span><br><span class="line">if(jud[v]) all.push_back(&#123;v,num[v]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sort(all.begin(),all.end(),cmp);</span><br><span class="line">if(all.size()==0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Unbelievable!&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">for(auto v:all) cout&lt;&lt;v.name&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="无穷的小数"><a href="#无穷的小数" class="headerlink" title="无穷的小数"></a>无穷的小数</h2><p><code>Problem Description</code><br>在十进制下，我们能够很轻易地判断一个小数的位数是有穷的或无穷的，但是把这个小数用二进制表示出的情况下其有穷性和无穷性就会发生改变，比如<br>十进制下的 0.5 ,在二进制下的值为 0.1 ；<br>十进制下的 0.75 ,在二进制下的值为 0.11 ；<br>十进制下的 0.6 ,在二进制下的值为 0.1001100……<br>给你一个十进制的小数，判断其在二进制表示下小数位数是否无穷。</p><p><code>输入格式</code><br>多组输入，处理到文件结束<br>每组数据输入一个六位的小数 n.(0≤n\&lt;1)</p><p><code>输出格式</code><br>如果在二进制下小数位数是有穷的，输出”YES”,否则输出”NO”.</p><p>样例<br>input<br>0.500000<br>0.600000<br>0.750000<br>output<br>YES<br>NO<br>YES</p><p>Solve:<br>由于只有后六位，先乘上 106 防止爆精度。<br>按照最普通的算法，每次乘以 2 再对 106 取余<br>当循环次数超过某一个值时，即可判定为无穷</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double n;</span><br><span class="line">while(~scanf(&quot;%lf&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">int flag = 0;</span><br><span class="line">while(i &lt;= 10)</span><br><span class="line">&#123;</span><br><span class="line">n *= 2;</span><br><span class="line">if(n == int(n))</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">小数转换成二进制就是每次乘以2直到等于1.如果一个小数在二进制表示下小数位数是无穷的，意思就是无论它乘以几次2，都不会正好等于1。我们只需要乘以2一定的次数，如果出现1，就不是无穷的，反之即无穷的。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><p>官方code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">double y;</span><br><span class="line">while(scanf(&quot;%lf&quot;,&amp;y)!=EOF)&#123;</span><br><span class="line">y*=10000000;</span><br><span class="line">bool flag=0;</span><br><span class="line">long long x=(long long)y;</span><br><span class="line">int num=0;</span><br><span class="line">while(1)&#123;</span><br><span class="line">    if(x==0) break;</span><br><span class="line">if(num&gt;=200)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">x=2*x;</span><br><span class="line">if(x&gt;=10000000) x-=10000000;</span><br><span class="line">if(x==0) break;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;NO&quot;);</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Special-String"><a href="#Special-String" class="headerlink" title="Special String"></a>Special String</h2><p><code>Problem Description</code><br>我们定义一个字符串S为Special String只要这个字符串满足下面这些条件:<br>1.这个串是回文的，即把这个字符串正着读和反着读相同，如abba和aca，而ba和abca则不是。<br>2.26个小写字母必须全部出现<br>3.这个串的长度为偶数。<br>对于给定的S,判断它是否是Special String.</p><p><code>输入格式</code><br>输入一个只由小写字母组成的字符串S。(1≤|S|≤1e5)</p><p><code>输出格式</code><br>如果这个字符串是Special String，输出”YE5”,否则输出”N0”</p><p>样例<br>input<br>aaaa<br>output<br>N0<br>input<br>abcdefghijklmnopqrstuvwxyzzyxwvutsrqponmlkjihgfedcba<br>output<br>YE5</p><p>PS:如果这一题不过的，请仔细看题，仔细看题！！！<br>Solve:<br>签到题，按题意要求模拟即可<br>是 YE5 和 N0</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">if(s.size() % 2 != 0)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;N0&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br><span class="line">int len = s.size();</span><br><span class="line">int ans = len - 1;</span><br><span class="line"></span><br><span class="line">set&lt;char&gt; st;</span><br><span class="line">set&lt;char&gt; :: iterator it;</span><br><span class="line">int flag = 0;</span><br><span class="line">for(int i = 0; i &lt;= len / 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">st.insert(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(it = st.begin(); it != st.end(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = &apos;a&apos;; i &lt;= &apos;z&apos;; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(st.count(i) == 0) flag = 1;//不是全部有 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0;i &lt;= len / 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i] != s[ans --])</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;N0&quot;);</span><br><span class="line">else puts(&quot;YE5&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>官方code：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">bool check(string s)&#123;</span><br><span class="line">string c=s;</span><br><span class="line">reverse(c.begin(), c.end());</span><br><span class="line">return s==c;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int,int&gt; pii;</span><br><span class="line">int main()&#123;</span><br><span class="line">pii.first=1;</span><br><span class="line">pii.second=2;</span><br><span class="line">pii=make_pair(1,2);</span><br><span class="line">//cout&lt;&lt;pii.first&lt;&lt;&apos; &apos;&lt;&lt;pii.second&lt;&lt;endl;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">bool flag=0;</span><br><span class="line">int l=s.length();</span><br><span class="line">if(l&amp;1) flag=1;</span><br><span class="line">if(!check(s)) flag=1;</span><br><span class="line">int num[27];</span><br><span class="line">memset(num,0,sizeof(num));</span><br><span class="line">for(int i=0;i&lt;l;i++)&#123;</span><br><span class="line">num[s[i]-&apos;a&apos;]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">if(num[i]==0)&#123;</span><br><span class="line">flag=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) cout&lt;&lt;&quot;N0&quot;&lt;&lt;endl;</span><br><span class="line">else cout&lt;&lt;&quot;YE5&quot;&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Max-Gcd"><a href="#Max-Gcd" class="headerlink" title="Max Gcd"></a>Max Gcd</h2><p><code>Problem Description</code><br>一个数组a，现在你需要删除某一项使得它们的gcd最大，求出这个最大值。</p><p><code>输入格式</code><br>第一行输入一个正整数n，表示数组的大小，接下来一行n个数，第i个数为ai。(2≤n≤1e5,1≤ai≤1e9)</p><p><code>输出格式</code><br>输出删除掉某个数以后的gcd的最大值。</p><p>样例<br>input<br>4<br>2 4 8 1<br>output<br>2<br>input<br>4<br>1 2 3 4<br>output<br>1<br>提示<br>样例一：删除第四个元素后，2,4,8的最大公因子为2。<br>样例二：无论删除哪一个，最大公因子都为1。</p><p>Solve:<br>维护前缀 gcd 数组 pre 和后缀 gcd 数组 od<br>删除第 i 个数之后剩余数的 gcd 即为 gcd(prei−1, odi+1)<br>线性枚举即可, 复杂度 O(n)</p><p>两个都是官方的,学习一下新知识<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//前缀后缀解法 </span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 100;</span><br><span class="line">long long a[N];</span><br><span class="line">long long pre[N], sa[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">pre[1] = a[1], sa[n] = a[n];</span><br><span class="line">for(int i = 2; i &lt;= n; i ++) pre[i] = __gcd(pre[i - 1], a[i]);</span><br><span class="line">for(int i = n - 1; i &gt;= 1; i --) sa[i] = __gcd(sa[i + 1], a[i]);</span><br><span class="line">long long ans = max(pre[n - 1], sa[2]);</span><br><span class="line">for(int i = 2; i &lt;= n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">ans = max(ans, __gcd(pre[i - 1],sa[i + 1]));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//贪心解法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e5 + 10;</span><br><span class="line">int a[maxn];</span><br><span class="line">bool cmp(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">return x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">return b ? gcd(b,a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for (int i = 0;i &lt; n;i ++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">sort(a,a + n,cmp);</span><br><span class="line">int ans = a[0],now = a[0];</span><br><span class="line">for (int i = 1;i &lt; n;i ++)</span><br><span class="line">&#123;</span><br><span class="line">ans = max(gcd(ans,a[i]),now);</span><br><span class="line">now = gcd(now,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Count-Prime-Pairs"><a href="#Count-Prime-Pairs" class="headerlink" title="Count Prime Pairs"></a>Count Prime Pairs</h2><p><code>Problem Description</code><br>对于数组a，如果i≠j并且ai+aj是一个质数，那么我们就称(i,j)为质数对，计算数组中质数对的个数。</p><p><code>输入格式</code><br>第一行输入一个n，表示数组的长度,接下来n个整数，第i个数代表ai。<br>(1≤n≤100000,0≤ai≤100)</p><p><code>输出格式</code><br>输出数组中质数对的个数。</p><p>样例<br>input<br>3<br>1 2 3<br>output<br>4<br>提示<br>样例说明：a1+a2,a2+a1,a2+a3,a3+a2都为质数，总共有四对。</p><p>Solve:<br>注意到 ai 的范围很小，我们可以先打出 [1, 200] 以内的质数<br>表<br>O(n) 或 O(nlog(n)) 的统计每个数出现的次数<br>对于第 i 个质数 pi，和数组中第 j 个元素 aj，答案应该累加<br>上 pi − aj 出现的次数<br>注意 pi = 2 ∗ aj 的情况，应该加上 aj 出现的次数减去 1</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int prime[350];</span><br><span class="line">int v[250];</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; 250; i ++)</span><br><span class="line">&#123;</span><br><span class="line">prime[i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">prime[0] = prime[1] = 0;</span><br><span class="line">for(int i = 2; i &lt; 250; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 2; j * i &lt; 250; j ++)</span><br><span class="line">&#123;</span><br><span class="line">prime[i * j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i = 0; i &lt; 200; i ++) v[i] = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">v[a] ++;</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= 200; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(prime[i] == 1)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= i / 2; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j != i - j)</span><br><span class="line">ans = ans + v[j] * v[i - j] * 2;</span><br><span class="line">else</span><br><span class="line">ans = ans + v[j] * (v[j] - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>官方code：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">bool check(int x)&#123;</span><br><span class="line">if(x==1) return 0;</span><br><span class="line">if(x==2) return 1;</span><br><span class="line">for(int i=2;i*i&lt;=x;i++)&#123;</span><br><span class="line">if(x%i==0) return 0;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; pr;</span><br><span class="line">void init()&#123;</span><br><span class="line">for(int i=1;i&lt;=250;i++)&#123;</span><br><span class="line">if(check(i)) pr.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int a[N];</span><br><span class="line">int vis[300];</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">long long ans=0;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],vis[a[i]]++;</span><br><span class="line">for(int i=0;i&lt;(int)pr.size();i++)&#123;</span><br><span class="line">int now=pr[i];</span><br><span class="line">for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">if(now&gt;=a[j])&#123;</span><br><span class="line">if(now==(a[j]*2)) ans+=vis[a[j]]-1;</span><br><span class="line">else&#123;</span><br><span class="line"> if(vis[a[j]]&amp;&amp;vis[now-a[j]]) ans+=vis[now-a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="平行线"><a href="#平行线" class="headerlink" title="平行线"></a>平行线</h2><p><code>Problem Description</code><br>“大猩猩为什么不喜欢平行线？”“因为平行线没有相交”<br>哈哈哈哈哈哈哈哈哈<br>为了管理动物园不听话的大猩猩们，动物管理员Boctorio 决定去远方的ACM之城找一些平行线，当他逛到一个神奇的店铺时，他发现了一副黑色的图，上面依稀可见一些白色的点。Boctorio 询问店铺老板这幅画是什么，老板说：“天机不可泄露”。等Boctorio仔细端详了一会这幅画后，他惊讶的发现其中所蕴含的奥秘。向店铺老板道谢后，他拿着刚买的这幅画，就连忙赶回动物园。</p><p><code>输入格式</code><br>输入一个数 n(1≤n≤1000)，表示点的个数。<br>接下来n行，每行两个整数 xi,yi(1≤xi,yi≤1e9),表示第i个点。<br>数据保证没有重复的点</p><p><code>输出格式</code><br>输出用这些点所能表示出来的平行线段的对数。（两条不同的线段重合也算为平行）</p><p>样例<br>input<br>6<br>0 0<br>1 0<br>1 1<br>3 1<br>3 3<br>5 4<br>output<br>10</p><p>Solve:<br>对(yi−yj)/(xi−xj) 用 gcd 约分后用 pair 存储<br>利用 map 统计每个斜率的线段条数, 假设为 num, 那么斜率<br>k 的贡献即为 num*(num−1)/2累加不同的斜率的贡献即可<br>复杂度 O(n^2log(n^2))</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int x[1005], y[1005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">set&lt;pair&lt;int, int&gt; &gt; se;</span><br><span class="line">map&lt;pair&lt;int, int&gt; ,int&gt; mp;</span><br><span class="line">for(int i = 0; i &lt; n; i ++) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = i + 1; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">int dx = x[j] - x[i];</span><br><span class="line">int dy = y[j] - y[i];</span><br><span class="line">int mid = __gcd(dx, dy);</span><br><span class="line">dx /= mid;</span><br><span class="line">dy /= mid;</span><br><span class="line">mp[&#123;dx, dy&#125;] ++;</span><br><span class="line">se.insert(&#123;dx, dy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(set&lt;pair&lt;int, int&gt; &gt; :: iterator it = se.begin(); it != se.end(); it ++) </span><br><span class="line">&#123;</span><br><span class="line">ans += (mp[*it] * (mp[*it] - 1)) / 2;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">先开一个集合和一个字典用来存储点数据 </span><br><span class="line">然后用gcd来找最大公约数，找到最小的分数，用  map存储约化后的斜率</span><br><span class="line">n * (n - 1) / 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><p>官方code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2000;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int x[N],y[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">map&lt;pair&lt;int,int&gt; ,int&gt; k;</span><br><span class="line">set&lt;pair&lt;long long,long long&gt;&gt; all;</span><br><span class="line">long long ans=0;</span><br><span class="line">for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=i+1;j&lt;=n;j++)&#123;</span><br><span class="line">int dx=x[j]-x[i];</span><br><span class="line">int dy=y[j]-y[i];</span><br><span class="line">if(dx&lt;0&amp;&amp;dy&lt;0)&#123;</span><br><span class="line">dx=-dx;</span><br><span class="line">dy=-dy;</span><br><span class="line">&#125;</span><br><span class="line">long long gc=__gcd(dx,dy);</span><br><span class="line">dx/=gc;dy/=gc;</span><br><span class="line">k[&#123;dx,dy&#125;]++;</span><br><span class="line">all.insert(&#123;dx,dy&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(auto v:all)&#123;</span><br><span class="line">ans+=(k[v]*(k[v]-1)/2);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Area-of-polygons"><a href="#Area-of-polygons" class="headerlink" title="Area of polygons"></a>Area of polygons</h2><p><code>Problem Description</code><br>现在有a个边长为1的正方形，b个半径为1的圆，c个边长为1的等边三角形，现在你随机拿出一个图形，求这个图形面积的期望。</p><p><code>输入格式</code><br>第一行输入一个T,代表输入的组数。(1≤T≤100)<br>接下来T行，每行三个数字a,b,c(1≤a,b,c≤1000)。</p><p><code>输出格式</code><br>输出T行，对于每一组输入，输出面积的期望，小数点后保留三位小数。</p><p>样例<br>input<br>3<br>1 2 3<br>4 5 6<br>7 8 9<br>output<br>1.430<br>1.487<br>1.501</p><p>提示<br>圆周率为3.1415926535897</p><p>Solve:<br>初中数学题<br>答案即为 a+b<em>PI+c</em>√3/4/(a+b+c)</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">const float P = 3.1415926535897;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">double a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">double ans = 0;</span><br><span class="line">ans = (a + b * P + c * sqrt(3) / 4) / (a + b + c);</span><br><span class="line">printf(&quot;%.3lf\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="双色球"><a href="#双色球" class="headerlink" title="双色球"></a>双色球</h2><p><code>Problem Description</code><br>双色球投注区分为红色球号码区和蓝色球号码区，红色球号码区由1-33共三十三个号码组成，蓝色球号码区由1-16共十六个号码组成。投注时选择6个红色球号码和1个蓝色球号码组成一注进行单式投注。其中奖规则为：<br>一等奖（6+1）<br>二等奖（6+0）<br>三等奖（5+1）<br>四等奖（5+0、4+1）<br>五等奖（4+0、3+1）<br>六等奖（2+1、1+1、0+1）<br>其中(a+b)即为有a个红色球，b个蓝色球与开奖某个数字相同（只与数字有关，与位置无关）。<br>现在你有 n 张双色球彩票，以及本场彩票开奖结果，请你求出这 n 张彩票获得的最高奖。</p><p><code>输入格式</code><br>第一行输入一个 n ，表示 n 张彩票<br>接下来 n 行，每行 7 个数字，表示每张彩票的选号，其中前六个位红色球，后一个为蓝色球。<br>接下来一行，输入 7 个数字，表示开奖结果，其中前六个为红色球，后一个为蓝色球。</p><p><code>输出格式</code><br>输出所有彩票中能获得的最高等级奖，若无，则输出”0”。</p><p>样例<br>input<br>5<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>13 14 21 22 27 32 8<br>6 7 12 19 27 28 12<br>output<br>6<br>input<br>3<br>2 17 21 28 30 32 10<br>2 12 17 29 30 31 15<br>9 10 19 25 26 30 12<br>6 8 18 29 30 31 10<br>output<br>6</p><p>提示<br>彩票六个红色球数字均为从小到大排列</p><p>Solve:只有 7 颗球，暴力模拟即可</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int b[10];</span><br><span class="line">&#125;d[1000];</span><br><span class="line">int a[40];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 7; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; d[i].b[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 7; i ++) cin &gt;&gt; a[i];</span><br><span class="line">int awd = 7, fin_awd = 7;</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int flag = 0;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int j = 0; j &lt; 6; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(binary_search(a, a + 6, d[i].b[j]))</span><br><span class="line">&#123;</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(a[6] == d[i].b[6]) flag = 1;</span><br><span class="line">if(ans == 0 &amp;&amp; flag == 1) awd = 6;</span><br><span class="line">if(ans == 1 &amp;&amp; flag == 1) awd = 6;</span><br><span class="line">if(ans == 2 &amp;&amp; flag == 1) awd = 6;</span><br><span class="line">if(ans == 3 &amp;&amp; flag == 1) awd = 5;</span><br><span class="line">if(ans == 4 &amp;&amp; flag == 0) awd = 5;</span><br><span class="line">if(ans == 4 &amp;&amp; flag == 1) awd = 4;</span><br><span class="line">if(ans == 5 &amp;&amp; flag == 0) awd = 4;</span><br><span class="line">if(ans == 5 &amp;&amp; flag == 1) awd = 3;</span><br><span class="line">if(ans == 6 &amp;&amp; flag == 0) awd = 2;</span><br><span class="line">if(ans == 6 &amp;&amp; flag == 1) awd = 1;</span><br><span class="line"></span><br><span class="line">fin_awd = min(awd, fin_awd);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fin_awd % 7 &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>官方code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">pair&lt;int,int&gt; solve(vector&lt;int&gt; a,vector&lt;int&gt; b)&#123;</span><br><span class="line">int num[34];</span><br><span class="line">memset(num,0,sizeof(num));</span><br><span class="line">int r=0;</span><br><span class="line">int bl=0;</span><br><span class="line">for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">num[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">if(num[b[i]]) r++;</span><br><span class="line">&#125;</span><br><span class="line">if(a[6]==b[6]) bl=1;</span><br><span class="line">return &#123;r,bl&#125;;</span><br><span class="line">&#125;</span><br><span class="line">int cal(pair&lt;int,int&gt; pii)&#123;</span><br><span class="line">if(pii.first==6&amp;&amp;pii.second==1) return 1;</span><br><span class="line">if(pii.first==6&amp;&amp;pii.second==0) return 2;</span><br><span class="line">if(pii.first==5&amp;&amp;pii.second==1) return 3;</span><br><span class="line">if((pii.first==5&amp;&amp;pii.second==0)||(pii.first==4&amp;&amp;pii.second==1)) return 4;</span><br><span class="line">if((pii.first==4&amp;&amp;pii.second==0)||(pii.first==3&amp;&amp;pii.second==1)) return 5;</span><br><span class="line">if((pii.first==2&amp;&amp;pii.second==1)||(pii.first==1&amp;&amp;pii.second==1)||(pii.first==0&amp;&amp;pii.second==1)) return 6;</span><br><span class="line">return 99999;</span><br><span class="line">&#125;</span><br><span class="line">const int N = 1e3+100;</span><br><span class="line">vector&lt;int&gt; a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">int x;</span><br><span class="line">for(int j=0;j&lt;7;j++)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">a[i].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans=7;</span><br><span class="line">vector&lt;int&gt; b(7);</span><br><span class="line">for(int i=0;i&lt;7;i++) cin&gt;&gt;b[i];</span><br><span class="line">for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">ans=min(ans,cal(solve(a[i],b)));</span><br><span class="line">&#125;</span><br><span class="line">if(ans==7) ans=0;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Remainder-Minimization-2019"><a href="#Remainder-Minimization-2019" class="headerlink" title="Remainder Minimization 2019"></a>Remainder Minimization 2019</h2><p><code>Problem Description</code><br>给你一个区间[L,R],在这个区间内找到两个不同的数字i,j，使得(i∗j)%2019的值最小。</p><p><code>输入格式</code><br>输入两个数 L,R,(1≤L\&lt;R≤1e9）</p><p><code>输出格式</code><br>如题</p><p>样例<br>input<br>4 5<br>output<br>20<br>input<br>2020 2040<br>output<br>2</p><p>Solve:<br>当 L 和 R 的差值大于 2019 的时候，其中必定含有 2019 的<br>倍数，此时答案为 0<br>否则暴力枚举</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 2019;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">int minn = 6666666;</span><br><span class="line">if((r - l) &gt; 2019) minn = 0;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i = l; i &lt;= r; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = i; j &lt;= r; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(i != j &amp;&amp; (i % mod) * (j % mod) % 2019 &lt; minn)</span><br><span class="line">&#123;</span><br><span class="line">minn = (i % mod) * (j % mod) % 2019;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; minn &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day4&quot;&gt;&lt;a href=&quot;#Day4&quot; class=&quot;headerlink&quot; title=&quot;Day4&quot;&gt;&lt;/a&gt;Day4&lt;/h1&gt;&lt;p&gt;&lt;code&gt;第一次积分赛&lt;/code&gt;&lt;br&gt;今天打了第一次积分赛，有点小激动&lt;br&gt;虽然没有大佬们那样NB吧，但至少咱们没爆零(以前的事谁有能记得清楚，是不？)&lt;br&gt;归根结底，还是自己太菜了&lt;br&gt;总结一下，积分赛还是学到了很多知识的&lt;br&gt;不一一列举了，都会在代码中体现的(主要是很多新函数的加入！！！)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Day3</title>
    <link href="http://yoursite.com/2019/07/20/Day3/"/>
    <id>http://yoursite.com/2019/07/20/Day3/</id>
    <published>2019-07-20T14:26:30.867Z</published>
    <updated>2019-07-22T14:49:12.021Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>今天学习的是 STL + 栈 + 队列<br>栈和队列还好，以前接触过，STL就不行了，对我来说只是听说过，没用过<br>全新的知识点一定要打好基础！！！</p><p><code>因为学的比较慢，此次没有把题补完，下次补上</code><br>未完待续~~~<br><a id="more"></a></p><p>OJ链接：<a href="https://cn.vjudge.net/contest/312177" target="_blank" rel="noopener">https://cn.vjudge.net/contest/312177</a></p><h2 id="Windows-Message-Queue"><a href="#Windows-Message-Queue" class="headerlink" title="Windows Message Queue"></a>Windows Message Queue</h2><p><code>Problem Description</code><br>Message queue is the basic fundamental of windows system. For each process, the system maintains a message queue. If something happens to this process, such as mouse click, text change, the system will add a message to the queue. Meanwhile, the process will do a loop for getting message from the queue according to the priority value if it is not empty. Note that the less priority value means the higher priority. In this problem, you are asked to simulate the message queue for putting messages to and getting message from the message queue.<br><code>Input</code><br>There’s only one test case in the input. Each line is a command, “GET” or “PUT”, which means getting message or putting message. If the command is “PUT”, there’re one string means the message name and two integer means the parameter and priority followed by. There will be at most 60000 command. Note that one message can appear twice or more and if two messages have the same priority, the one comes first will be processed first.(i.e., FIFO for the same priority.) Process to the end-of-file.<br><code>Output</code><br>For each “GET” command, output the command getting from the message queue with the name and parameter in one line. If there’s no message in the queue, output “EMPTY QUEUE!”. There’s no output for “PUT” command.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">GET</span><br><span class="line">PUT msg1 10 5</span><br><span class="line">PUT msg2 10 4</span><br><span class="line">GET</span><br><span class="line">GET</span><br><span class="line">GET</span><br><span class="line">Sample Output</span><br><span class="line">EMPTY QUEUE!</span><br><span class="line">msg2 10</span><br><span class="line">msg1 10</span><br><span class="line">EMPTY QUEUE!</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补~</p><h2 id="Train-Problem-I"><a href="#Train-Problem-I" class="headerlink" title="Train Problem I"></a>Train Problem I</h2><p><code>Problem Description</code><br>As the new term comes, the Ignatius Train Station is very busy nowadays. A lot of student want to get back to school by train(because the trains in the Ignatius Train Station is the fastest all over the world ^v^).<br>But here comes a problem, there is only one railway where all the trains stop. So all the trains come in from one side and get out from the other side. For this problem, if train A gets into the railway first, and then train B gets into the railway before train A leaves, train A can’t leave until train B leaves.<br>The pictures below figure out the problem. Now the problem for you is, there are at most 9 trains in the station, all the trains has an ID(numbered from 1 to n), the trains get into the railway in an order O1, your task is to determine whether the trains can get out in an order O2.<br><img src="/2019/07/20/Day3/1.jpg" alt> <img src="/2019/07/20/Day3/2.jpg" alt> <img src="/2019/07/20/Day3/3.jpg" alt><br><code>Input</code><br>The input contains several test cases. Each test case consists of an integer, the number of trains, and two strings, the order of the trains come in:O1, and the order of the trains leave:O2. The input is terminated by the end of file. More details in the Sample Input.<br><code>Output</code><br>The output contains a string “No.” if you can’t exchange O2 to O1, or you should output a line contains “Yes.”, and then output your way in exchanging the order(you should output “in” for a train getting into the railway, and “out” for a train getting out of the railway). Print a line contains “FINISH” after each test case. More details in the Sample Output.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 123 321</span><br><span class="line">3 123 312</span><br><span class="line">Sample Output</span><br><span class="line">Yes.</span><br><span class="line">in</span><br><span class="line">in</span><br><span class="line">in</span><br><span class="line">out</span><br><span class="line">out</span><br><span class="line">out</span><br><span class="line">FINISH</span><br><span class="line">No.</span><br><span class="line">FINISH</span><br><span class="line"></span><br><span class="line">Tip:</span><br><span class="line">For the first Sample Input, we let train 1 get in, then train 2 and train 3.</span><br><span class="line">So now train 3 is at the top of the railway, so train 3 can leave first, then train 2 and train 1.</span><br><span class="line">In the second Sample input, we should let train 3 leave first, so we have to let train 1 get in, then train 2 and train 3.</span><br><span class="line">Now we can let train 3 leave.</span><br><span class="line">But after that we can&apos;t let train 1 leave before train 2, because train 2 is at the top of the railway at the moment.</span><br><span class="line">So we output &quot;No.&quot;.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">string id1, id2, res;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; id1 &gt;&gt; id2;</span><br><span class="line">stack&lt;char&gt; s;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">int i, j;</span><br><span class="line">int flag = 0;</span><br><span class="line">for(int i = 0, j = 0; i &lt; n &amp;&amp; j &lt;= n;)</span><br><span class="line">&#123;</span><br><span class="line">if(s.empty() || s.top() != id2[i])</span><br><span class="line">&#123;</span><br><span class="line">if(j == n)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;No.\nFINISH\n&quot;;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">s.push(id1[j]);</span><br><span class="line">j ++;</span><br><span class="line">q.push(&quot;in&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line">i ++;</span><br><span class="line">q.push(&quot;out&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) continue;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Yes.\n&quot;;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; q.front() &lt;&lt; endl;</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;FINISH&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Rails"><a href="#Rails" class="headerlink" title="Rails"></a>Rails</h2><p><code>Problem Description</code><br>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time.<br>It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.<br>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, …, N.<br>The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, …, aN. Help him and write a program that decides whether it is possible to get the required order of coaches.<br>You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.<br><img src="/2019/07/20/Day3/4.jpg" alt><br><code>Input</code><br>The input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, …, N. The last line of the block contains just 0.</p><p>The last block consists of just one line containing 0.<br><code>Output</code><br>The output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last <code></code>null’’ block of the input.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 1 2 3</span><br><span class="line">0</span><br><span class="line">6</span><br><span class="line">6 5 4 3 2 1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line"></span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;t) &amp;&amp; t)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[0]);</span><br><span class="line">if(!a[0])</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">s.push(i);</span><br><span class="line">while(!s.empty() &amp;&amp; s.top() == a[ans])</span><br><span class="line">&#123;</span><br><span class="line">s.pop();</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(s.empty()) puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A-B"><a href="#A-B" class="headerlink" title="{A} + {B}"></a>{A} + {B}</h2><p><code>Problem Description</code><br>给你两个集合，要求{A} + {B}.<br>注:同一个集合中不会有两个相同的元素.<br><code>Input</code><br>每组输入数据分为三行,第一行有两个数字n,m(0&lt;n,m&lt;=10000),分别表示集合A和集合B的元素个数.后两行分别表示集合A和集合B.每个元素为不超出int范围的整数,每个元素之间有一个空格隔开.<br><code>Output</code><br>针对每组数据输出一行数据,表示合并后的集合,要求从小到大输出,每个元素之间有一个空格隔开.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 2</span><br><span class="line">1</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">1</span><br><span class="line">1 2</span><br><span class="line">Sample Output</span><br><span class="line">1 2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">set&lt;int&gt; :: iterator it;//遍历器 </span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">st.insert((x));</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;y);</span><br><span class="line">st.insert(y);</span><br><span class="line">&#125;</span><br><span class="line">it = st.begin();</span><br><span class="line">cout &lt;&lt; *it;</span><br><span class="line">it ++;</span><br><span class="line">for(; it != st.end(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; *it;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="水果"><a href="#水果" class="headerlink" title="水果"></a>水果</h2><p><code>Problem Description</code><br>夏天来了<del>好开心啊,呵呵,好多好多水果</del><br>Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表,这样Joe就可以很容易掌握所有水果的销售情况了.<br><code>Input</code><br>第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.<br>每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.<br><code>Output</code><br>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.<br>两组测试数据之间有一个空行.最后一组测试数据之后没有空行.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">apple shandong 3</span><br><span class="line">pineapple guangdong 1</span><br><span class="line">sugarcane guangdong 1</span><br><span class="line">pineapple guangdong 3</span><br><span class="line">pineapple guangdong 1</span><br><span class="line">Sample Output</span><br><span class="line">guangdong</span><br><span class="line">   |----pineapple(5)</span><br><span class="line">   |----sugarcane(1)</span><br><span class="line">shandong</span><br><span class="line">   |----apple(3)</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//  map的嵌套使用 </span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">map&lt;string, int&gt; count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">map&lt;string, node&gt; mp;</span><br><span class="line">int x, num;</span><br><span class="line">string fruit, place;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; fruit &gt;&gt; place &gt;&gt; num;</span><br><span class="line">mp[place].count[fruit] += num;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; :: iterator it1;</span><br><span class="line">map&lt;string, node&gt; :: iterator it2;</span><br><span class="line">for(it2 = mp.begin(); it2 != mp.end(); it2 ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; it2 -&gt; first &lt;&lt; endl;</span><br><span class="line">for(it1 = mp[it2 -&gt; first].count.begin(); it1 != mp[it2 -&gt; first].count.end(); it1 ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;   |----&quot; &lt;&lt; it1 -&gt; first &lt;&lt; &quot;(&quot; &lt;&lt; it1 -&gt; second &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Let-the-Balloon-Rise"><a href="#Let-the-Balloon-Rise" class="headerlink" title="Let the Balloon Rise"></a>Let the Balloon Rise</h2><p><code>Problem Description</code></p><p>Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges’ favorite time is guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.</p><p>This year, they decide to leave this lovely job to you.<br><code>Input</code><br>Input contains multiple test cases. Each test case starts with a number N (0 &lt; N &lt;= 1000) – the total number of balloons distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.</p><p>A test case with N = 0 terminates the input and this test case is not to be processed.<br><code>Output</code><br>For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a unique solution for each test case.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">green</span><br><span class="line">red</span><br><span class="line">blue</span><br><span class="line">red</span><br><span class="line">red</span><br><span class="line">3</span><br><span class="line">pink</span><br><span class="line">orange</span><br><span class="line">pink</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">red</span><br><span class="line">pink</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 10010;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">char name[20];</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if( n == 0) break;</span><br><span class="line">map&lt;string, int&gt; balloons;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">balloons[name] ++;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; :: iterator p, m;</span><br><span class="line">p = m = balloons.begin();</span><br><span class="line">for(; p != balloons.end(); p ++)</span><br><span class="line">&#123;</span><br><span class="line">if(p -&gt; second &gt; m -&gt; second) m = p;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; m -&gt; first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="不重复数字"><a href="#不重复数字" class="headerlink" title="不重复数字"></a>不重复数字</h2><p><code>Problem Description</code><br>给出N个数，要求把其中重复的去掉，只保留第一次出现的数。<br>例如，给出的数为1 2 18 3 3 19 2 3 6 5 4，其中2和3有重复，去除后的结果为1 2 18 3 19 6 5 4。</p><p><code>Input</code><br>输入第一行为正整数T，表示有T组数据。<br>接下来每组数据包括两行，第一行为正整数N，表示有N个数。第二行为要去重的N个正整数。</p><p><code>Output</code></p><p>对于每组数据，输出一行，为去重后剩下的数字，数字之间用一个空格隔开。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">1 2 18 3 3 19 2 3 6 5 4</span><br><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">Sample Output</span><br><span class="line">1 2 18 3 19 6 5 4</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">Hint</span><br><span class="line"></span><br><span class="line">对于30%的数据，1 &lt;= N &lt;= 100，给出的数不大于100，均为非负整数； </span><br><span class="line"></span><br><span class="line">对于50%的数据，1 &lt;= N &lt;= 10000，给出的数不大于10000，均为非负整数； </span><br><span class="line"></span><br><span class="line">对于100%的数据，1 &lt;= N &lt;= 50000，给出的数在32位有符号整数范围内。</span><br><span class="line"></span><br><span class="line">提示: </span><br><span class="line"></span><br><span class="line">由于数据量很大，使用C++的同学请使用scanf和printf来进行输入输出操作，以免浪费不必要的时间。</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, m;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">set&lt;int&gt; st;</span><br><span class="line">int a[50010];</span><br><span class="line">int l = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">if(st.count(m) == 0)</span><br><span class="line">&#123;</span><br><span class="line">st.insert(m);</span><br><span class="line">a[l ++] = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; l - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;, a[l - 1]);</span><br><span class="line">st.clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Andy’s-First-Dictionary"><a href="#Andy’s-First-Dictionary" class="headerlink" title="Andy’s First Dictionary"></a>Andy’s First Dictionary</h2><p><code>Problem Description</code><br>Andy, 8, has a dream - he wants to produce his very own dictionary. This is not an easy task for him, as the number of words that he knows is, well, not quite enough. Instead of thinking up all the words himself, he has a briliant idea. From his bookshelf he would pick one of his favourite story books, from which he would copy out all the distinct words. By arranging the words in<br>alphabetical order, he is done! Of course, it is a really time-consuming job, and this is where a computer program is helpful.You are asked to write a program that lists all the different words in the input text. In this problem, a word is defined as a consecutive sequence of alphabets, in upper and/or lower case. Words with only one letter are also to be considered. Furthermore, your program must be CaSe InSeNsItIvE. For example, words like “Apple”, “apple” or “APPLE” must be considered the same.<br><code>Input</code><br>The input file is a text with no more than 5000 lines. An input line has at most 200 characters. Input<br>is terminated by EOF.<br><code>Output</code><br>Your output should give a list of different words that appears in the input text, one in a line. The<br>words should all be in lower case, sorted in alphabetical order. You can be sure that he number of<br>distinct words in the text does not exceed 5000.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">Adventures in Disneyland</span><br><span class="line">Two blondes were going to Disneyland when they came to a fork in the</span><br><span class="line">road. The sign read: &quot;Disneyland Left.&quot;</span><br><span class="line">So they went home.</span><br><span class="line">Sample Output</span><br><span class="line">a</span><br><span class="line">adventures</span><br><span class="line">blondes</span><br><span class="line">came</span><br><span class="line">disneyland</span><br><span class="line">fork</span><br><span class="line">going</span><br><span class="line">home</span><br><span class="line">in</span><br><span class="line">left</span><br><span class="line">read</span><br><span class="line">road</span><br><span class="line">sign</span><br><span class="line">so</span><br><span class="line">the</span><br><span class="line">they</span><br><span class="line">to</span><br><span class="line">two</span><br><span class="line">went</span><br><span class="line">were</span><br><span class="line">when</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string      s;</span><br><span class="line">    set&lt;string&gt; se;</span><br><span class="line">    while (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &gt;= &apos;A&apos; &amp;&amp; s[i] &lt;= &apos;Z&apos;)</span><br><span class="line">                s[i] += 32;</span><br><span class="line">            else if (s[i] &gt;= &apos;a&apos; &amp;&amp; s[i] &lt;= &apos;z&apos;)</span><br><span class="line">                s[i] = s[i];</span><br><span class="line">            else</span><br><span class="line">                s[i] = &apos; &apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        string       mi;</span><br><span class="line">        stringstream mid(s);</span><br><span class="line">        while (mid &gt;&gt; mi)</span><br><span class="line">        &#123;</span><br><span class="line">            se.insert(mi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (set&lt;string&gt;::iterator it = se.begin(); it != se.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A-and-B-and-Compilation-Errors"><a href="#A-and-B-and-Compilation-Errors" class="headerlink" title="A and B and Compilation Errors"></a>A and B and Compilation Errors</h2><p><code>Problem Description</code><br>A and B are preparing themselves for programming contests.<br>B loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.<br>Initially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.<br>However, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared — the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.<br>Can you help B find out exactly what two errors he corrected?<br><code>Input</code><br>The first line of the input contains integer n (3 ≤ n ≤ 105) — the initial number of compilation errors.<br>The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 109) — the errors the compiler displayed for the first time.<br>The third line contains n - 1 space-separated integers b1, b2, …, bn - 1 — the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one.<br>The fourth line contains n - 2 space-separated integers с1, с2, …, сn - 2 — the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one.<br><code>Output</code><br>Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">5</span><br><span class="line">1 5 8 123 7</span><br><span class="line">123 7 5 1</span><br><span class="line">5 1 7</span><br><span class="line">Output</span><br><span class="line">8</span><br><span class="line">123</span><br><span class="line">Input</span><br><span class="line">6</span><br><span class="line">1 4 3 3 5 7</span><br><span class="line">3 7 5 4 3</span><br><span class="line">4 3 7 5</span><br><span class="line">Output</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">Note</span><br><span class="line">In the first test sample B first corrects the error number 8, then the error number 123.</span><br><span class="line">In the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e9;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, x, a = 0, b = 0, c = 0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">for(int i = 0; i &lt; t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">a += x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; t - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">b += x;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; t - 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">c += x;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n%d\n&quot;,a - b, b - c);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="排列2"><a href="#排列2" class="headerlink" title="排列2"></a>排列2</h2><p><code>Problem Description</code><br>Ray又对数字的列产生了兴趣：<br>现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。<br><code>Input</code><br>每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。<br><code>Output</code><br>对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。<br>每组输出数据间空一行，最后一组数据后面没有空行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 2 3 4</span><br><span class="line">1 1 2 3</span><br><span class="line">0 1 2 3</span><br><span class="line">0 0 0 0</span><br><span class="line">Sample Output</span><br><span class="line">1234 1243 1324 1342 1423 1432</span><br><span class="line">2134 2143 2314 2341 2413 2431</span><br><span class="line">3124 3142 3214 3241 3412 3421</span><br><span class="line">4123 4132 4213 4231 4312 4321</span><br><span class="line"></span><br><span class="line">1123 1132 1213 1231 1312 1321</span><br><span class="line">2113 2131 2311</span><br><span class="line">3112 3121 3211</span><br><span class="line"></span><br><span class="line">1023 1032 1203 1230 1302 1320</span><br><span class="line">2013 2031 2103 2130 2301 2310</span><br><span class="line">3012 3021 3102 3120 3201 3210</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[4];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t = 0, tmp;</span><br><span class="line">while(scanf(&quot;%d %d %d %d&quot;,&amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]) &amp;&amp; a[0] + a[1] + a[2] + a[3])</span><br><span class="line">&#123;</span><br><span class="line">if(t) puts(&quot;&quot;);</span><br><span class="line">t = 1;</span><br><span class="line">int flag = 1;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">if(a[0] == 0) continue;</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else if(tmp == a[0])</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];</span><br><span class="line">&#125;</span><br><span class="line">tmp = a[0];</span><br><span class="line">&#125;</span><br><span class="line">while(next_permutation(a, a + 4));</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ignatius-and-the-Princess-II"><a href="#Ignatius-and-the-Princess-II" class="headerlink" title="Ignatius and the Princess II"></a>Ignatius and the Princess II</h2><p><code>Problem Description</code><br>Now our hero finds the door to the BEelzebub feng5166. He opens the door and finds feng5166 is about to kill our pretty Princess. But now the BEelzebub has to beat our hero first. feng5166 says, “I have three question for you, if you can work them out, I will release the Princess, or you will be my dinner, too.” Ignatius says confidently, “OK, at last, I will save the Princess.”</p><p>“Now I will show you the first problem.” feng5166 says, “Given a sequence of number 1 to N, we define that 1,2,3…N-1,N is the smallest sequence among all the sequence which can be composed with number 1 to N(each number can be and should be use only once in this problem). So it’s easy to see the second smallest sequence is 1,2,3…N,N-1. Now I will give you two numbers, N and M. You should tell me the Mth smallest sequence which is composed with number 1 to N. It’s easy, isn’t is? Hahahahaha……”<br>Can you help Ignatius to solve this problem?<br><code>Input</code><br>The input contains several test cases. Each test case consists of two numbers, N and M(1&lt;=N&lt;=1000, 1&lt;=M&lt;=10000). You may assume that there is always a sequence satisfied the BEelzebub’s demand. The input is terminated by the end of file.<br><code>Output</code><br>For each test case, you only have to output the sequence satisfied the BEelzebub’s demand. When output a sequence, you should print a space between two numbers, but do not output any spaces after the last number.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6 4</span><br><span class="line">11 8</span><br><span class="line">Sample Output</span><br><span class="line">1 2 3 5 6 4</span><br><span class="line">1 2 3 4 5 6 7 9 8 11 10</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e9;</span><br><span class="line">int a[1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">next_permutation(a + 1, a + n + 1);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[1];</span><br><span class="line">for(int i = 2; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="ACboy-needs-your-help-again"><a href="#ACboy-needs-your-help-again" class="headerlink" title="ACboy needs your help again!"></a>ACboy needs your help again!</h2><p><code>Problem Description</code><br>ACboy was kidnapped!!<br>he miss his mother very much and is very scare now.You can’t image how dark the room he was put into is, so poor :(.<br>As a smart ACMer, you want to get ACboy out of the monster’s labyrinth.But when you arrive at the gate of the maze, the monste say :” I have heard that you are very clever, but if can’t solve my problems, you will die with ACboy.”<br>The problems of the monster is shown on the wall:<br>Each problem’s first line is a integer N(the number of commands), and a word “FIFO” or “FILO”.(you are very happy because you know “FIFO” stands for “First In First Out”, and “FILO” means “First In Last Out”).<br>and the following N lines, each line is “IN M” or “OUT”, (M represent a integer).<br>and the answer of a problem is a passowrd of a door, so if you want to rescue ACboy, answer the problem carefully!<br><code>Input</code><br>The input contains multiple test cases.<br>The first line has one integer,represent the number oftest cases.<br>And the input of each subproblem are described above.<br><code>Output</code><br>For each command “OUT”, you should output a integer depend on the word is “FIFO” or “FILO”, or a word “None” if you don’t have any integer.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4</span><br><span class="line">4 FIFO</span><br><span class="line">IN 1</span><br><span class="line">IN 2</span><br><span class="line">OUT</span><br><span class="line">OUT</span><br><span class="line">4 FILO</span><br><span class="line">IN 1</span><br><span class="line">IN 2</span><br><span class="line">OUT</span><br><span class="line">OUT</span><br><span class="line">5 FIFO</span><br><span class="line">IN 1</span><br><span class="line">IN 2</span><br><span class="line">OUT</span><br><span class="line">OUT</span><br><span class="line">OUT</span><br><span class="line">5 FILO</span><br><span class="line">IN 1</span><br><span class="line">IN 2</span><br><span class="line">OUT</span><br><span class="line">IN 3</span><br><span class="line">OUT</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">None</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br>待补~</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Aug 07 2019 23:09:53 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day3&quot;&gt;&lt;a href=&quot;#Day3&quot; class=&quot;headerlink&quot; title=&quot;Day3&quot;&gt;&lt;/a&gt;Day3&lt;/h1&gt;&lt;p&gt;今天学习的是 STL + 栈 + 队列&lt;br&gt;栈和队列还好，以前接触过，STL就不行了，对我来说只是听说过，没用过&lt;br&gt;全新的知识点一定要打好基础！！！&lt;/p&gt;&lt;p&gt;&lt;code&gt;因为学的比较慢，此次没有把题补完，下次补上&lt;/code&gt;&lt;br&gt;未完待续~~~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
</feed>
