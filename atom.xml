<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dou Qing</title>
  
  <subtitle>~人间有万紫千红~&lt;br&gt;~唯你是我情之所钟~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-12T15:40:06.575Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集训中学到的方法</title>
    <link href="http://yoursite.com/2019/08/30/%E9%9B%86%E8%AE%AD%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/30/集训中学到的方法/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2019-08-12T15:40:06.575Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="学习就该如贪心！！一直向前-！"><a href="#学习就该如贪心！！一直向前-！" class="headerlink" title="学习就该如贪心！！一直向前~！"></a><center>学习就该如贪心！！一直向前~！</center></h1><p><center>记录一些会用到并且好用的函数<br>或者是容易混淆的知识点<br><code>持续更新</code><br><a id="more"></a></center></p><h2 id="STL的定义方式："><a href="#STL的定义方式：" class="headerlink" title="STL的定义方式："></a>STL的定义方式：</h2><p>set/stack/queue/vector &lt;int/string&gt; 定义名称；<br><code>set</code>有自动排序的功能(从小到大)</p><blockquote><p>set里面用的是平衡二叉搜索树（也就是红黑树）维护</p></blockquote><p>string 字符串名称；<br>map&lt;string/int, int/string&gt; 名称；</p><h3 id="set的迭代器："><a href="#set的迭代器：" class="headerlink" title="set的迭代器："></a>set的迭代器：</h3><p>set<int>:: iterator it;<br>这个it是为指针用法<br>eg：<br>it = st.begin();<br>cout &lt;&lt; <em>it;<br>it ++;<br>for(; it != st.end(); it ++)<br>{<br>cout &lt;&lt; “ “ &lt;&lt; </em>it;<br>}</int></p><h3 id="map的迭代器："><a href="#map的迭代器：" class="headerlink" title="map的迭代器："></a>map的迭代器：</h3><p>map&lt;string, int&gt; :: iterator mp;<br>这个mp用法要用mp -&gt; first 或者mp -&gt; second 来表示<br>eg：<br>map&lt;string, int&gt; :: iterator it1;<br>map&lt;string, node&gt; :: iterator it2;<br>for(it2 = mp.begin(); it2 != mp.end(); it2 ++)<br>{<br>cout &lt;&lt; it2 -&gt; first &lt;&lt; endl;<br>for(it1 = mp[it2 -&gt; first].count.begin(); it1 != mp[it2 -&gt; first].count.end(); it1 ++)<br>{<br>cout &lt;&lt; “|—-“ &lt;&lt; it1 -&gt; first &lt;&lt; “(“ &lt;&lt; it1 -&gt; second &lt;&lt; “)” &lt;&lt; endl;<br>}<br>}</p><h3 id="嵌套map用法可以为"><a href="#嵌套map用法可以为" class="headerlink" title="嵌套map用法可以为"></a>嵌套map用法可以为</h3><p>struct node{<br>map&lt;string, int&gt; count;<br>};</p><p>map&lt;string, node&gt; mp;</p><p>用的时候为：mp[string].count[string] ++;或者一些操作</p><h2 id="二分查找–binary-search的用法"><a href="#二分查找–binary-search的用法" class="headerlink" title="二分查找–binary_search的用法"></a>二分查找–binary_search的用法</h2><p>头文件 <code>#include &lt;algorithm&gt;</code></p><p>使用方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.函数模板：binary_search(arr[],arr[]+size ,  indx)</span><br><span class="line">b.参数说明：</span><br><span class="line">    arr[]： 数组首地址</span><br><span class="line">    size：数组元素个数</span><br><span class="line">    indx:需要查找的值</span><br><span class="line">c.函数功能：  在数组中以二分法检索的方式查找，若在数组(要求数组元素非递减)中查找到indx元素则真，若查找不到则返回值为假。</span><br></pre></td></tr></table></figure><p></p><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>查找第一个大于或等于某个元素的位置<br>使用方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a.函数模板：lower_bound(arr[],arr[]+size ,  indx):</span><br><span class="line">b.参数说明：</span><br><span class="line">    arr[]： 数组首地址</span><br><span class="line">    size：数组元素个数</span><br><span class="line">    indx:需要查找的值</span><br><span class="line">c.函数功能:函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置(注意是地址)。如果所有元素都小于val，则返回last的位置</span><br><span class="line">d.举例如下：</span><br><span class="line">　　一个数组number序列为：4,10,11,30,69,70,96,100.设要插入数字3,9,111.pos为要插入的位置的下标，则</span><br><span class="line">　　/*注意因为返回值是一个指针，所以减去数组的指针就是int变量了*/</span><br><span class="line">　　pos = lower_bound( number, number + 8, 3) - number，pos = 0.即number数组的下标为0的位置。</span><br><span class="line">　　pos = lower_bound( number, number + 8, 9) - number， pos = 1，即number数组的下标为1的位置（即10所在的位置）。</span><br><span class="line">　　pos = lower_bound( number, number + 8, 111) - number， pos = 8，即number数组的下标为8的位置（但下标上限为7，所以返回最后一个元素的下一个元素）。</span><br><span class="line">e.注意：函数lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的！</span><br></pre></td></tr></table></figure><p></p><h3 id="upper-bound-查找第一个大于某个位置的元素的位置"><a href="#upper-bound-查找第一个大于某个位置的元素的位置" class="headerlink" title="upper_bound: 查找第一个大于某个位置的元素的位置"></a>upper_bound: 查找第一个大于某个位置的元素的位置</h3><p>使用方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a.函数模板：upper_bound(arr[],arr[]+size ,  indx):</span><br><span class="line">b.参数说明：</span><br><span class="line">    arr[]： 数组首地址</span><br><span class="line">    size：数组元素个数</span><br><span class="line">    indx:需要查找的值</span><br><span class="line">c.函数功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置</span><br><span class="line">　　例如：一个数组number序列1,2,2,4.upper_bound(2)后，返回的位置是3（下标）也就是4所在的位置,同样，如果插入元素大于数组中全部元素，返回的是last。(注意：数组下标越界)</span><br><span class="line">　　返回查找元素的最后一个可安插位置，也就是“元素值&gt;查找值”的第一个元素的位置 。</span><br></pre></td></tr></table></figure><p></p><h2 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a>unique函数</h2><p>类属性算法unique的作用是从输入序列中“删除”所有相邻的重复元素。</p><p>该算法删除相邻的重复元素，然后重新排列输入范围内的元素，并且返回一个迭代器（容器的长度没变，只是元素顺序改变了），表示无重复的值范围得结束。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// sort words alphabetically so we can find the duplicates</span><br><span class="line">sort(words.begin(), words.end());</span><br><span class="line"> vector&lt;string&gt;::iterator end_unique =  unique(words.begin(), words.end());</span><br><span class="line"> words.erase(end_unique, words.end());</span><br></pre></td></tr></table></figure><p></p><p>在STL中unique函数是一个去重函数， unique的功能是去除相邻的重复元素(只保留一个),其实它并不真正把重复的元素删除，是把重复的元素移到后面去了，然后依然保存到了原数组中，然后 返回去重后最后一个元素的地址，因为unique去除的是相邻的重复元素，所以一般用之前都会要排一下序。<br>若调用sort后，vector的对象的元素按次序排列如下：<br>sort jumps over quick red red slow the the turtle<br><img src="https://i.loli.net/2019/08/12/24TpqaLng3NoZWU.png" alt="下载.png"><br>注意，words的大小并没有改变，依然保存着10个元素；只是这些元素的顺序改变了。调用unique“删除”了相邻的重复值。给“删除”加上引号是因为unique实际上并没有删除任何元素，而是将无重复的元素复制到序列的前段，从而覆盖相邻的重复元素。unique返回的迭代器指向超出无重复的元素范围末端的下一个位置。</p><p>注意：算法不直接修改容器的大小。如果需要添加或删除元素，则必须使用容器操作。<br>Eg:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line">&#123;</span><br><span class="line">    //cout&lt;&lt;&quot;Illustrating the generic unique algorithm.&quot;&lt;&lt;endl;</span><br><span class="line">    const int N=11;</span><br><span class="line">    int array1[N]=&#123;1,2,0,3,3,0,7,7,7,0,8&#125;;</span><br><span class="line">    vector&lt;int&gt; vector1;</span><br><span class="line">    for (int i=0;i&lt;N;++i)</span><br><span class="line">        vector1.push_back(array1[i]);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::iterator new_end;</span><br><span class="line">    new_end=unique(vector1.begin(),vector1.end());    //&quot;删除&quot;相邻的重复元素</span><br><span class="line">    assert(vector1.size()==N);</span><br><span class="line"></span><br><span class="line">    vector1.erase(new_end,vector1.end());  //删除（真正的删除）重复的元素</span><br><span class="line">    copy(vector1.begin(),vector1.end(),ostream_iterator&lt;int&gt;(cout,&quot; &quot;));</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="gcd的前缀后缀维护"><a href="#gcd的前缀后缀维护" class="headerlink" title="gcd的前缀后缀维护"></a>gcd的前缀后缀维护</h2><p>说到gcd,就不得不提一下<br>C++11中子代有内置gcd函数,用法是 __gcd(a, b);</p><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6025" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6025</a></p><p><code>持续更新</code><br>PS:暂时不会讲解，先看代码吧，等以后理解透了在讲解<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int gcd(int a,int b)&#123;</span><br><span class="line">if(a&lt;b)&#123;</span><br><span class="line">int t=a;</span><br><span class="line">a=b;b=t;</span><br><span class="line">&#125;</span><br><span class="line">return b==0?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int a[1000005],q[1000005],h[1000005];</span><br><span class="line">int main()&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">memset(q,0,sizeof(q));</span><br><span class="line">memset(h,0,sizeof(h));</span><br><span class="line">int i;</span><br><span class="line">for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">q[0]=a[0];</span><br><span class="line">for(i=1;i&lt;n-1;i++)&#123;</span><br><span class="line">q[i]=gcd(q[i-1],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">h[n-1]=a[n-1];</span><br><span class="line">for(i=n-2;i&gt;0;i--)&#123;</span><br><span class="line">h[i]=gcd(h[i+1],a[i]);</span><br><span class="line">&#125;</span><br><span class="line">int ans=max(q[n-2],h[1]);</span><br><span class="line">for(i=1;i&lt;n-1;i++)&#123;</span><br><span class="line">ans=max(ans,gcd(q[i-1],h[i+1]));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="C-中auto的用法"><a href="#C-中auto的用法" class="headerlink" title="C++中auto的用法"></a>C++中auto的用法</h2><h3 id="C-98-auto"><a href="#C-98-auto" class="headerlink" title="C++98 auto"></a>C++98 auto</h3><p>早在C++98标准中就存在了auto关键字，那时的auto用于声明变量为自动变量，自动变量意为拥有自动的生命期，这是多余的，因为就算不使用auto声明，变量依旧拥有自动的生命期：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a =10 ;  //拥有自动生命期</span><br><span class="line">auto int b = 20 ;//拥有自动生命期</span><br><span class="line">static int c = 30 ;//延长了生命期</span><br></pre></td></tr></table></figure><p></p><p>C++98中的auto多余且极少使用，C++11已经删除了这一用法，取而代之的是全新的auto：变量的自动类型推断。</p><h3 id="C-11-auto"><a href="#C-11-auto" class="headerlink" title="C++11 auto"></a>C++11 auto</h3><p>auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">auto au_a = a;//自动类型推断，au_a为int类型</span><br><span class="line">cout &lt;&lt; typeid(au_a).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p></p><p>typeid运算符可以输出变量的类型。程序的运行结果输出了<br>int<br>这种用法就类似于C#中的var关键字。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。而是否会造成编译期的时间消耗，我认为是不会的，在未使用auto时，编译器也需要得知右操作数的类型，再与左操作数的类型进行比较，检查是否可以发生相应的转化，是否需要进行隐式类型转换。</p><h3 id="为什么用auto"><a href="#为什么用auto" class="headerlink" title="为什么用auto:"></a>为什么用auto:</h3><p>用于代替冗长复杂、变量使用范围专一的变量声明。<br>想象一下在没有auto的时候，我们操作标准库时经常需要这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; vs;</span><br><span class="line">    for (vector&lt;string&gt;::iterator i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用auto 可以简化代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;string&gt; vs;</span><br><span class="line">    for (auto i = vs.begin(); i != vs.end(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="pair的用法"><a href="#pair的用法" class="headerlink" title="pair的用法"></a>pair的用法</h2><h3 id="pair的应用"><a href="#pair的应用" class="headerlink" title="pair的应用"></a>pair的应用</h3><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。<br>另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p1;            //创建一个空的pair对象（使用默认构造），它的两个元素分别是T1和T2类型，采用值初始化。</span><br><span class="line">pair&lt;T1, T2&gt; p1(v1, v2);    //创建一个pair对象，它的两个元素分别是T1和T2类型，其中first成员初始化为v1，second成员初始化为v2。</span><br><span class="line">make_pair(v1, v2);          // 以v1和v2的值创建一个新的pair对象，其元素类型分别是v1和v2的类型。</span><br><span class="line">p1 &lt; p2;                    // 两个pair对象间的小于运算，其定义遵循字典次序：如 p1.first &lt; p2.first 或者 !(p2.first &lt; p1.first) &amp;&amp; (p1.second &lt; p2.second) 则返回true。</span><br><span class="line">p1 == p2；                  // 如果两个对象的first和second依次相等，则这两个对象相等；该运算使用元素的==操作符。</span><br><span class="line">p1.first;                   // 返回对象p1中名为first的公有数据成员</span><br><span class="line">p1.second;                 // 返回对象p1中名为second的公有数据成员</span><br></pre></td></tr></table></figure><p></p><h3 id="pair的创建和初始化"><a href="#pair的创建和初始化" class="headerlink" title="pair的创建和初始化"></a>pair的创建和初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pair包含两个数值，与容器一样，pair也是一种模板类型。但是又与之前介绍的容器不同；</span><br><span class="line">在创建pair对象时，必须提供两个类型名，两个对应的类型名的类型不必相同</span><br><span class="line"></span><br><span class="line">pair&lt;string, string&gt; anon;        // 创建一个空对象anon，两个元素类型都是string</span><br><span class="line">pair&lt;string, int&gt; word_count;     // 创建一个空对象 word_count, 两个元素类型分别是string和int类型</span><br><span class="line">pair&lt;string, vector&lt;int&gt; &gt; line;  // 创建一个空对象line，两个元素类型分别是string和vector类型</span><br><span class="line"></span><br><span class="line">当然也可以在定义时进行成员初始化：</span><br><span class="line">pair&lt;string, string&gt; author(&quot;James&quot;,&quot;Joy&quot;);    // 创建一个author对象，两个元素类型分别为string类型，并默认初始值为James和Joy。</span><br><span class="line">pair&lt;string, int&gt; name_age(&quot;Tom&quot;, &quot;18&quot;);</span><br><span class="line">pair&lt;string, int&gt; name_age2(name_age);    // 拷贝构造初始化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pair类型的使用相当的繁琐，如果定义多个相同的pair类型对象，可以使用typedef简化声明：</span><br><span class="line">typedef pair&lt;string,string&gt; Author;</span><br><span class="line">Author proust(&quot;March&quot;,&quot;Proust&quot;);</span><br><span class="line">Author Joy(&quot;James&quot;,&quot;Joy&quot;);</span><br><span class="line"></span><br><span class="line">变量间赋值：</span><br><span class="line">pair&lt;int, double&gt; p1(1, 1.2);</span><br><span class="line">pair&lt;int, double&gt; p2 = p1;     //operator =</span><br></pre></td></tr></table></figure><h2 id="pair对象的操作"><a href="#pair对象的操作" class="headerlink" title="pair对象的操作"></a>pair对象的操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int ,double&gt; p1;</span><br><span class="line">p1.first = 1;</span><br><span class="line">p1.second = 2.5;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;p1.first&lt;&lt;&apos; &apos;&lt;&lt;p1.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">//输出结果：1 2.5</span><br><span class="line"></span><br><span class="line">string firstBook;</span><br><span class="line">if(author.first==&quot;James&quot; &amp;&amp; author.second==&quot;Joy&quot;)</span><br><span class="line">    firstBook=&quot;Stephen Hero&quot;;</span><br></pre></td></tr></table></figure><h2 id="生成新的pair对象"><a href="#生成新的pair对象" class="headerlink" title="生成新的pair对象"></a>生成新的pair对象</h2><p>还可以利用make_pair创建新的pair对象：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;</span><br><span class="line">p1 = make_pair(1, 1.2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; p1.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//output: 1 1.2</span><br><span class="line"></span><br><span class="line">int a = 8;</span><br><span class="line">string m = &quot;James&quot;;</span><br><span class="line">pair&lt;int, string&gt; newone;</span><br><span class="line"></span><br><span class="line">newone = make_pair(a, m);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; newone.first &lt;&lt; newone.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//output: 8 James</span><br></pre></td></tr></table></figure><p></p><h2 id="通过tie获取pair元素值"><a href="#通过tie获取pair元素值" class="headerlink" title="通过tie获取pair元素值"></a>通过tie获取pair元素值</h2><p>在某些清况函数会以pair对象作为返回值时，可以直接通过std::tie进行接收。比如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;std::string, int&gt; getPreson() &#123;</span><br><span class="line">    return std::make_pair(&quot;Sven&quot;, 25);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    int ages;</span><br><span class="line"></span><br><span class="line">    std::tie(name, ages) = getPreson();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; &quot;, ages: &quot; &lt;&lt; ages &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="有关字符串的一些用法"><a href="#有关字符串的一些用法" class="headerlink" title="有关字符串的一些用法"></a>有关字符串的一些用法</h2><p>1.isalpha(c) ~判断是否为英文字符<br>2.tolower(c) ~将字符转换成小写<br>3.字符串输入sstream<br>4.将字符串分割成单词：<br>stringstream temp(str); //分割成一个个单词<br>5.将字符串插入进set中，自动排序~</p><h2 id="string的用法"><a href="#string的用法" class="headerlink" title="string的用法"></a>string的用法</h2><p>提到字符串就必须提一句string,这个是真的好用！！！！</p><p>简洁明了string 的用法和 int 基本上没啥差别，也就是定义的类型不同，string功能多一点罢了(string毕竟是字符串嘛)</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str[100];</span><br><span class="line">str = &quot;aaa&quot;;//直接赋值</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">cin &gt;&gt; str[i];//输入赋值</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>说起来比较就更令人发指了！！！<br>不知道比起来某个char方便多少呢。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;abc&quot;;</span><br><span class="line">str2 = &quot;abb&quot;;</span><br><span class="line">if(str1 &gt; str2) puts(&quot;1&quot;);</span><br><span class="line">//输出结果 1</span><br></pre></td></tr></table></figure><p></p><p>没错，你没看错！！就是直接比较大小。。<br><code>持续更新string 功能</code></p><h2 id="stringstream的用法："><a href="#stringstream的用法：" class="headerlink" title="stringstream的用法："></a>stringstream的用法：</h2><p>stringstream是 C++ 提供的另一个字串型的串流(stream)物件，和之前学过的iostream、fstream有类似的操作方式。要使用stringstream， 必须先加入这一行：</p><p>#include<sstream><br>stringstream主要是用在將一个字符串分割，可以先用.clear( )以及.str( )將指定字串设定成一开始的內容，再用&gt;&gt;把个別的资料输出。</sstream></p><p>Eg:<br>題目：输入的第一行有一个数字 N 代表接下來有 N 行资料，每一行资料里有不固定个数的整数(最多20个，每行最大200个字元)，编程將每行的总和打印出來。<br>输入：<br>3<br>1 2 3<br>20 17 23 54 77 60<br>111 222 333 444 555 666 777 888 999<br>输出：<br>6<br>251<br>4995<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    getline(cin, s);  //读取换行</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(cin, s);</span><br><span class="line">        ss.clear();</span><br><span class="line">        ss.str(s);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            int a;</span><br><span class="line">            ss &gt;&gt; a;</span><br><span class="line">            if(ss.fail())</span><br><span class="line">                break;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用stringstream简化类型转换<br>C++标准库中的<sstream>提供了比ANSI C的&lt;stdio.h&gt;更高级的一些功能，即单纯性、类型安全和可扩展性。接下来，我将举例说明怎样使用这些库来实现安全和自动的类型转换。<br>Eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 10000;</span><br><span class="line">    char s[10];</span><br><span class="line"></span><br><span class="line">    sprintf(s, &quot;%d&quot;, n);</span><br><span class="line">    //s中的内容为“10000”</span><br><span class="line"></span><br><span class="line">//到目前为止看起来还不错。但是，对上面代码的一个微小的改变就会使程序发生错误</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, s);</span><br><span class="line">    sprintf(s, &quot;%f&quot;, n);</span><br><span class="line"></span><br><span class="line">//错误的格式化符</span><br><span class="line">    printf(&quot;%s\n&quot;, s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></sstream></p><p><code>详细学习链接</code>：<br><a href="http://blog.csdn.net/zhang_xueping/article/details/47846807" target="_blank" rel="noopener">http://blog.csdn.net/zhang_xueping/article/details/47846807</a><br><a href="http://blog.csdn.net/u014097230/article/details/52089530" target="_blank" rel="noopener">http://blog.csdn.net/u014097230/article/details/52089530</a></p><h2 id="优先队列—自动排序！！！"><a href="#优先队列—自动排序！！！" class="headerlink" title="优先队列—自动排序！！！"></a>优先队列—自动排序！！！</h2><p>说道优先队列就必须提一句<br>优先队列别有back()操作，并且第一个元素不是用front()而是top()，，，front()是队列的<br>优先队列是一种特殊的队列，在学习堆排序的时候就有所了解。<br><a href="https://blog.csdn.net/c20182030/article/details/52727101" target="_blank" rel="noopener">堆排序</a></p><h2 id="奇偶剪枝"><a href="#奇偶剪枝" class="headerlink" title="奇偶剪枝"></a>奇偶剪枝</h2><p><a href="https://www.cnblogs.com/wkfvawl/p/9337156.html" target="_blank" rel="noopener">点这里</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;学习就该如贪心！！一直向前-！&quot;&gt;&lt;a href=&quot;#学习就该如贪心！！一直向前-！&quot; class=&quot;headerlink&quot; title=&quot;学习就该如贪心！！一直向前~！&quot;&gt;&lt;/a&gt;&lt;center&gt;学习就该如贪心！！一直向前~！&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;center&gt;记录一些会用到并且好用的函数&lt;br&gt;或者是容易混淆的知识点&lt;br&gt;&lt;code&gt;持续更新&lt;/code&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/ACM/Algorithm/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Day24</title>
    <link href="http://yoursite.com/2019/08/13/Day24/"/>
    <id>http://yoursite.com/2019/08/13/Day24/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-13T15:11:06.767Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day23"><a href="#Day23" class="headerlink" title="Day23"></a>Day23</h1><p>今天和学长们一起打了学长们的积分赛。。。<br>战况还行<br><code>补题</code><br><a href="http://acm.zzuli.edu.cn/contest.php?cid=1398" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="小L的项链切割"><a href="#小L的项链切割" class="headerlink" title="小L的项链切割"></a>小L的项链切割</h2><p>题目描述<br>小T送给了小L了一串项链。为了方便，我们把项链上形态不同钻石用不同的字母表示。这样小L的项链就变成了一个字符串。小L忽然想把这串项链优美地切割一下，她想把它切割成尽量少的回文项链，啊也就是回文串。求最少的切割次数。<br><code>输入</code><br>第一行一个整数T 表示数据组数<br>下面T组数据，每一组数据:<br>只有一行，一个只有小写英文字母的字符串，字符串长度 &lt;= 1000。<br><code>输出</code><br>对于每一组数据，输出将这个字符串能切割成最少的回文串所需切割的次数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">abaacca</span><br><span class="line">abcd</span><br><span class="line">样例输出</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><blockquote><p>解法<br>令dp[i]表示从字符串从位置1到位置 i ，最少要切割多少次<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 1e3+7;</span><br><span class="line">int dp[MAXN];</span><br><span class="line">char s[MAXN];</span><br><span class="line"></span><br><span class="line">bool check(char *s,int l,int r) &#123;</span><br><span class="line">        while(l&lt;=r) &#123;</span><br><span class="line">                if(s[l]!=s[r])</span><br><span class="line">                        return false;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        int t;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">        while(t--) &#123;</span><br><span class="line">                scanf(&quot;%s&quot;,s+1);</span><br><span class="line">                int len = strlen(s+1);</span><br><span class="line">                memset(dp,0,sizeof(dp));</span><br><span class="line">                for(int i=1;i&lt;=len;++i) &#123;</span><br><span class="line">                        dp[i] = MAXN;</span><br><span class="line">                        for(int j=1;j&lt;=i;++j) &#123;</span><br><span class="line">                                if(check(s,j,i)) &#123;</span><br><span class="line">                                        if(j==1)</span><br><span class="line">                                                dp[i] = 1;</span><br><span class="line">                                        else</span><br><span class="line">                                                dp[i] = min(dp[i],dp[j-1]+1);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;%d\n&quot;,dp[len]-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="小L的试卷"><a href="#小L的试卷" class="headerlink" title="小L的试卷"></a>小L的试卷</h2><p>Description:<br>题目描述<br>小L期末考试结束，高高兴兴放假回家了，可是那么多试卷，老师还要加班批改，有n份试卷由k个老师批改，n份试卷进行了密封编号，由于试卷上的做题情况和书写的规范程序不一样，批改不同的试卷用时也可能不一样，每个老师批改试卷的编号顺序是连续的，每位老师批改完分配给自己的试卷就可以离开，问最后离开的老师，最短可能的用时是多少，假定一份试卷让任何一位老师批改用时都是一样的。现在请你设计一种分配方案，使得最后离开的老师用时最短。<br><code>输入</code><br>第一行两个整数n，k；（0&lt;k≤n≤1000）<br>第二行n个整数，第i个整数表示批改第i份试卷的用时。<br><code>输出</code><br>输出一个整数，表示最后离开的老师所用的最短时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">9 3                              </span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">样例输出</span><br><span class="line">17</span><br></pre></td></tr></table></figure><p></p><blockquote><p>二分求解<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll inf = 0x3f3f3f3f;</span><br><span class="line">const int maxn = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int n , k;</span><br><span class="line">ll a[maxn];</span><br><span class="line"></span><br><span class="line">bool isok(int x)</span><br><span class="line">&#123;</span><br><span class="line">    bool flag = false;</span><br><span class="line">    int num = 0;</span><br><span class="line">    ll temp = 0;</span><br><span class="line">    for (int i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i] &gt; x)  return false;</span><br><span class="line">        temp += a[i];</span><br><span class="line">        if (temp &gt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            num ++;</span><br><span class="line">            temp = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (temp &gt; 0)  num ++;</span><br><span class="line">    if (num &lt;= k)  return true;</span><br><span class="line">    else  return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">    for (int i=1; i&lt;=n; i++)  scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">    ll l = 0 , r = inf;</span><br><span class="line">    while (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid = (l + r) / 2;</span><br><span class="line">        if (isok(mid))  r = mid-1;</span><br><span class="line">        else  l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="小L记单词"><a href="#小L记单词" class="headerlink" title="小L记单词"></a>小L记单词</h2><p>Description:<br>题目描述<br>小L最近在努力学习英语，但是对一些词组总是记不住，小L小把这些词组中每一个单词的首字母都记一下，这样形成词组的缩写，通过这种方式小L的学习效率明显提高。<br><code>输入</code><br>输入有多行，每组测试数据占一行，每行有一个词组，每个词组由一个或多个单词组成；每组的单词个数不超过10个，每个单词由大、小写字母组成；<br>单词长度不超过10，由一个空格分隔这些单词。<br><code>输出</code><br>对应每一个词组，输出词组的缩写，缩写都用大写字母，每组输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">end of file</span><br><span class="line">样例输出</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">const int maxx = 110;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">char a[maxx];</span><br><span class="line">while(getline(cin,str))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">a[0] = str[0];</span><br><span class="line">int len = 1;</span><br><span class="line">for(int i = 1; i &lt; str.size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(str[i - 1] == &apos; &apos;)</span><br><span class="line">a[len ++] = str[i];</span><br><span class="line">else continue;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i] &gt;= &apos;a&apos; &amp;&amp; a[i] &lt;= &apos;z&apos;)</span><br><span class="line">a[i] -= 32;</span><br><span class="line">else if(a[i] &gt;= &apos;A&apos; &amp;&amp; a[i] &lt;= &apos;Z&apos;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; len; i ++)</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="小L的取膜算式"><a href="#小L的取膜算式" class="headerlink" title="小L的取膜算式"></a>小L的取膜算式</h2><p>Description:<br>题目描述<br>小L想请你帮忙计算一下这个式子的结果<br>(a+b)p MOD p，其中p是质数。<br><code>输入</code><br>多组数据<br>第一行一个T表示数据组数<br>接下来T行，每行3个正整数a, b, p且保证p是质数 ，输入数据都是long long范围内的正整数。特别的: p &lt;= 2^62<br><code>输出</code><br>对于每一组输入数据，输出正确结果<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">1</span><br><span class="line">1 2 3</span><br><span class="line">样例输出</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll T, a, b, p;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;T);</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld %lld&quot;,&amp;a, &amp;b, &amp;p);</span><br><span class="line">a %= p;</span><br><span class="line">b %= p;</span><br><span class="line">ll ans = (a + b) % p;</span><br><span class="line">printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="小L玩滚球游戏"><a href="#小L玩滚球游戏" class="headerlink" title="小L玩滚球游戏"></a>小L玩滚球游戏</h2><p>Description:<br>题目描述<br>小L正在玩滚球游戏，有n个水晶球在轨道上以不同开始位置和速度从近往远的方向滚动，如果两个水晶球在滚动过程中相遇，它们就会融合成一个水晶球，然后以速度较慢的水晶球的速度继续向前滚动， 问经过时间t后，轨道上还有多少水晶球。<br><code>输入</code><br>第一行输入两个整数n、t，n代表水晶球的数量（1 &lt;= n &lt;= 105, 0&lt;t&lt;231），t代表时间。<br>接下来n行，每行两个整数，按位置从近到远的顺序给出水晶球的初始位置和速度。<br><code>输出</code><br>输出一个整数表示经过时间t后水晶球的数量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5 3</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">6 1</span><br><span class="line">样例输出</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>题解：</p><blockquote><p>根据题意，移动速度快的球可能会追上在他前面移动速度慢的球，并且追上后合并在一起会变成前面速度慢的球。<br>可以将题意理解为，后面移动速度快的球碰到前面移动速度慢的球则会消失。<br>而且t是固定的值，直接计算每个位置在t秒后移动到的位置，逆向维护一个最靠后的值，检测当前球是否超过这个值。<br>如果超过则说明追上了后面的球当前球会消失。<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define fst first</span><br><span class="line">#define sed second</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">const ll LINF = 0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line">int a[N], v[N];</span><br><span class="line">ll b[N]; //经过t秒所处位置</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">//freopen(&quot;C:/input.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">#endif</span><br><span class="line">int n, t, m = 0;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;a[i], &amp;v[i]), b[i] = a[i] + 1LL * v[i] * t;</span><br><span class="line">ll p = LINF;</span><br><span class="line">for (int i = n; i &gt;= 1; --i)</span><br><span class="line">&#123;</span><br><span class="line">if (b[i] &gt;= p)</span><br><span class="line">m++;</span><br><span class="line">p = min(p, b[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; n - m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="小L的区间求和"><a href="#小L的区间求和" class="headerlink" title="小L的区间求和"></a>小L的区间求和</h2><p>Description:<br>题目描述<br>在给定的一个整数序列中，小L希望找到一个连续的区间，这个区间的和能够被k整除，请你帮小L算一下满足条件的最长的区间长度是多少。<br><code>输入</code><br>第一行输入两个整数n、k。（1 &lt;= n &lt;= 105,1&lt;=k&lt;100）<br>接下来一行输入n个整数，表示序列中的数。<br><code>输出</code><br>输出一个整数，满足条件区间的最长长度，如果不存在，输出0<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5 7</span><br><span class="line">1 2 4 1 1</span><br><span class="line">样例输出</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>题解：</p><blockquote><p>题解：开一个数组要来记录前n项对K取余的余数，，再开一个数组，用来记录余数第一次出现的位置<br>要点1 当一个 余数数组 的的前几项和为0的时候，从开头到此处的和是K的倍数<br>要点2 当一个余数重复出现的时候，说明从该余数第一次出现的位置（不包括第一次）到该次出现的位置的和味K的倍数（仔细想想还是很有道理的）<br>例如 2%10=2 （2+10）%10 =2 所以当两个余数相同时，期间一定加上了k的倍数。关键就是前面的前n项和的余数数组有点难理解。}<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int a[maxx], sum[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;k);</span><br><span class="line">map&lt;int, int&gt; mp;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">sum[i] = (sum[i - 1] + a[i]) % k;</span><br><span class="line">mp[sum[i]] = -1;</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">mp[sum[0]] = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(mp[sum[i]] == -1)</span><br><span class="line">mp[sum[i]] = i;</span><br><span class="line">else</span><br><span class="line">ans = max(ans, i - mp[sum[i]]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="小L的随机数"><a href="#小L的随机数" class="headerlink" title="小L的随机数"></a>小L的随机数</h2><p>Description:<br>题目描述<br>随机数是生成随机算法的基础，小L准备使用线性同余法（Linear Congruential Method）来生成一个随机数列，这种方法需要设置四个非负整数参数m, a, c, x0按照下面的公式生成出一系列随机数 : Xn+1 = (a * Xn + c) mod m ,小L现在想知道这个数列第n个数是多少，由于他只需要生成小于g的随机数，所以你只需要告诉他Xn mod g的结果即可。<br><code>输入</code><br>输入一行6个整数，分别表示m, a, c, X0, n, g 。(n ≤ 106，1 ≤ m, a, c, X0 , g ≤231 − 1)<br><code>输出</code><br>一行一个整数表示Xn<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">233 3 3 3 3 333</span><br><span class="line">样例输出</span><br><span class="line">120</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e7 + 50;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll m, a, c, x, n, g;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; a &gt;&gt; c &gt;&gt; x &gt;&gt; n &gt;&gt; g;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">x = (x * a + c) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;%lld\n&quot;,x % g);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="小L的直线"><a href="#小L的直线" class="headerlink" title="小L的直线"></a>小L的直线</h2><p>Description:<br>题目描述<br>小学时期的小L发现自己很有艺术细胞，于是买了一块画板，但是他的绘画水平使得他只能连接两点画出一条线段。有一天他决定在一张有n个点的图上作画，即他可以把这n个点任意连接。大家认为平行线是非常不美观的，于是他想知道自己最多能画多少条直线使整张画不出现平行线。<br><code>输入</code><br>第一行输入一个整数n （1 &lt;= n &lt;= 200）<br>接下来n行每行两个整数代表每个点的坐标x, y （-1000 &lt;= x, y &lt;= 1000）<br><code>输出</code><br>一行一个整数为能画出最多的两两不平行的直线条数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">4</span><br><span class="line">-1 1</span><br><span class="line">-2 0</span><br><span class="line">0 0</span><br><span class="line">1 1</span><br><span class="line">样例输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;e[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">set&lt;double&gt; se;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">cin &gt;&gt; e[i].x &gt;&gt; e[i].y;</span><br><span class="line">double ans;</span><br><span class="line">int cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(i == j) continue;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">if((e[j].x - e[i].x) == 0)cnt = 1;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">ans = 1.0 * (e[j].y - e[i].y) / (e[j].x - e[i].x);</span><br><span class="line">se.insert(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//for(set&lt;double&gt; :: iterator it = se.begin(); it != se.end(); it ++)</span><br><span class="line">//cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; se.size() + cnt &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="小L的长方形"><a href="#小L的长方形" class="headerlink" title="小L的长方形"></a>小L的长方形</h2><p>Description:<br>题目描述<br>在数学课上，老师发给小L一根铁丝，让小L将这根铁丝围成一个长方形。要求这个长方形的长是宽的3倍，并且计算它的面积。<br><code>输入</code><br>仅一个整数a，表示铁丝的长度(a≤10000)。<br><code>输出</code><br>输出三个数，分别表示长方形的长、宽、面积。如果计算结果是整数，则输出整数结果（没有小数部分）；如果不是，则保留三位小数。每个数之间用一个空格隔开。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">36</span><br><span class="line">样例输出</span><br><span class="line">13.500 4.500 60.750</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double x;</span><br><span class="line">double l;</span><br><span class="line">cin &gt;&gt; l;</span><br><span class="line">x = l / 8;</span><br><span class="line">double ans = 3 * x * x;</span><br><span class="line">if(x == (int)x)</span><br><span class="line">printf(&quot;%.0lf %.0lf %.0lf\n&quot;,3 * x, x, ans);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%.3lf %.3lf %.3lf\n&quot;,3 * x, x, ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day23&quot;&gt;&lt;a href=&quot;#Day23&quot; class=&quot;headerlink&quot; title=&quot;Day23&quot;&gt;&lt;/a&gt;Day23&lt;/h1&gt;&lt;p&gt;今天和学长们一起打了学长们的积分赛。。。&lt;br&gt;战况还行&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;http://acm.zzuli.edu.cn/contest.php?cid=1398&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Day23</title>
    <link href="http://yoursite.com/2019/08/12/Day23/"/>
    <id>http://yoursite.com/2019/08/12/Day23/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-12T16:04:36.206Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day23"><a href="#Day23" class="headerlink" title="Day23"></a>Day23</h1><p>今天讲的是 <code>算术基本原理</code> ，没咋学会。。。<br>有是自闭的一天<br><code>补题</code><br><a id="more"></a></p><h2 id="算术基本原理"><a href="#算术基本原理" class="headerlink" title="算术基本原理"></a>算术基本原理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个或以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。</p><p>例如: 6936 = 2^3 <em>3 </em>17^2, 1200 = 2^4 <em>3 </em>5^2</p><p>算术基本定理的内容由两部分构成：</p><p>分解的存在性：<br>分解的唯一性，即若不考虑排列的顺序，正整数分解为素数乘积的方式是唯一的。<br>算术基本定理是初等数论中一个基本的定理，也是许多其他定理的逻辑支撑点和出发点。</p><p><a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">详情链接</a></p><h3 id="假代码模板"><a href="#假代码模板" class="headerlink" title="假代码模板"></a>假代码模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1000];</span><br><span class="line">map&lt;int,int&gt;ma;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int num=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">int m=n;</span><br><span class="line">for(int i=2;i*i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(n%i==0) a[num++]=i;</span><br><span class="line">while(n%i==0)</span><br><span class="line">&#123;</span><br><span class="line">ma[i]++;</span><br><span class="line">n=n/i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n&gt;1) a[num++]=n,ma[n]++;</span><br><span class="line">for(int i=0;i&lt;num;i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d %d\n&quot;,a[i],ma[a[i]]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Smith-Numbers"><a href="#Smith-Numbers" class="headerlink" title="Smith Numbers"></a>Smith Numbers</h2><p>Description:<br>While skimming his phone directory in 1982, Albert Wilansky, a mathematician of Lehigh University,noticed that the telephone number of his brother-in-law H. Smith had the following peculiar property: The sum of the digits of that number was equal to the sum of the digits of the prime factors of that number. Got it? Smith’s telephone number was 493-7775. This number can be written as the product of its prime factors in the following way:<br>4937775= 3<em>5</em>5*65837</p><p>The sum of all digits of the telephone number is 4+9+3+7+7+7+5= 42,and the sum of the digits of its prime factors is equally 3+5+5+6+5+8+3+7=42. Wilansky was so amazed by his discovery that he named this kind of numbers after his brother-in-law: Smith numbers.<br>As this observation is also true for every prime number, Wilansky decided later that a (simple and unsophisticated) prime number is not worth being a Smith number, so he excluded them from the definition.<br>Wilansky published an article about Smith numbers in the Two Year College Mathematics Journal and was able to present a whole collection of different Smith numbers: For example, 9985 is a Smith number and so is 6036. However,Wilansky was not able to find a Smith number that was larger than the telephone number of his brother-in-law. It is your task to find Smith numbers that are larger than 4937775!<br><code>Input</code><br>The input file consists of a sequence of positive integers, one integer per line. Each integer will have at most 8 digits. The input is terminated by a line containing the number 0.<br><code>Output</code><br>For every number n &gt; 0 in the input, you are to compute the smallest Smith number which is larger than n,and print it on a line by itself. You can assume that such a number exists.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4937774</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">4937775</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int a[1000];</span><br><span class="line">int num;</span><br><span class="line">map&lt;int,int&gt;ma;</span><br><span class="line">bool isprime(int n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 2; i * i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(n % i == 0)</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int sum(int n)</span><br><span class="line">&#123;</span><br><span class="line">int i, sum = 0;</span><br><span class="line">while(n)</span><br><span class="line">&#123;</span><br><span class="line">i = n % 10;</span><br><span class="line">sum += i;</span><br><span class="line">n /= 10;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cut(int n)</span><br><span class="line">&#123;</span><br><span class="line">//分治的思想，如果是素数，就返回sum，否则，将该数分成两部分，再求各部分的质因子的sum</span><br><span class="line">if(isprime(n))</span><br><span class="line">return sum(n);</span><br><span class="line">for(int i = (int)sqrt(n + 0.5); i &gt; 1; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(n % i == 0)</span><br><span class="line">return cut(i) + cut(n / i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">while(n ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!isprime(n) &amp;&amp; sum(n) == cut(n))</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Pairs-Forming-LCM"><a href="#Pairs-Forming-LCM" class="headerlink" title="Pairs Forming LCM"></a>Pairs Forming LCM</h2><p>Description:<br>Find the result of the following code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long long pairsFormLCM( int n ) &#123;</span><br><span class="line">    long long res = 0;</span><br><span class="line">    for( int i = 1; i &lt;= n; i++ )</span><br><span class="line">        for( int j = i; j &lt;= n; j++ )</span><br><span class="line">           if( lcm(i, j) == n ) res++; // lcm means least common multiple</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>A straight forward implementation of the code may time out. If you analyze the code, you will find that the code actually counts the number of pairs (i, j) for which lcm(i, j) = n and (i ≤ j).</p><p><code>Input</code><br>Input starts with an integer T (≤ 200), denoting the number of test cases.</p><p>Each case starts with a line containing an integer n (1 ≤ n ≤ 1014).</p><p><code>Output</code><br>For each case, print the case number and the value returned by the function ‘pairsFormLCM(n)’.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">15</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">15</span><br><span class="line">18</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">27</span><br><span class="line">29</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 2</span><br><span class="line">Case 2: 2</span><br><span class="line">Case 3: 3</span><br><span class="line">Case 4: 5</span><br><span class="line">Case 5: 4</span><br><span class="line">Case 6: 5</span><br><span class="line">Case 7: 8</span><br><span class="line">Case 8: 5</span><br><span class="line">Case 9: 8</span><br><span class="line">Case 10: 8</span><br><span class="line">Case 11: 5</span><br><span class="line">Case 12: 11</span><br><span class="line">Case 13: 3</span><br><span class="line">Case 14: 4</span><br><span class="line">Case 15: 2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int p[maxn/10],m;//素数的数组开始1e7会RE</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    m=0;</span><br><span class="line">    for(int i=2;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!vis[i])    p[m++]=i;</span><br><span class="line">        for(int j=0;j&lt;m&amp;&amp;p[j]*i&lt;maxn;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[p[j]*i]=1;</span><br><span class="line">            if(i%p[j]==0)    break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    init();</span><br><span class="line">    ll n,ans,c;</span><br><span class="line">    int t,f=0;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        ans=1;</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[i]*p[i]&gt;n)    break;</span><br><span class="line">            c=0;</span><br><span class="line">            while(n%p[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                n/=p[i];</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">            if(c)    ans*=c*2+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&gt;1)    ans*=1*2+1;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;,++f,ans/2+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ekka-Dokka"><a href="#Ekka-Dokka" class="headerlink" title="Ekka Dokka"></a>Ekka Dokka</h2><p>Description:<br>Ekka and his friend Dokka decided to buy a cake. They both love cakes and that’s why they want to share the cake after buying it. As the name suggested that Ekka is very fond of odd numbers and Dokka is very fond of even numbers, they want to divide the cake such that Ekka gets a share of N square centimeters and Dokka gets a share of M square centimeters where N is odd and M is even. Both N and M are positive integers.</p><p>They want to divide the cake such that N * M = W, where W is the dashing factor set by them. Now you know their dashing factor, you have to find whether they can buy the desired cake or not.</p><p><code>Input</code><br>Input starts with an integer T (≤ 10000), denoting the number of test cases.</p><p>Each case contains an integer W (2 ≤ W &lt; 263). And W will not be a power of 2.</p><p><code>Output</code><br>For each case, print the case number first. After that print “Impossible” if they can’t buy their desired cake. If they can buy such a cake, you have to print N and M. If there are multiple solutions, then print the result where M is as small as possible.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">12</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 5 2</span><br><span class="line">Case 2: Impossible</span><br><span class="line">Case 3: 3 4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">ll w;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">int k = 0;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;w);</span><br><span class="line">ll n = 1, m = 1;</span><br><span class="line"></span><br><span class="line">if(w % 2 == 0)</span><br><span class="line">&#123;</span><br><span class="line">while(w % 2 == 0)</span><br><span class="line">&#123;</span><br><span class="line">n = n * 2;</span><br><span class="line">w = w / 2;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;Case %d: %lld %lld\n&quot;, ++ k, w, n);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">printf(&quot;Case %d: Impossible\n&quot;,++ k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Sum-of-Consecutive-Integers"><a href="#Sum-of-Consecutive-Integers" class="headerlink" title="Sum of Consecutive Integers"></a>Sum of Consecutive Integers</h2><p>Description:<br>Given an integer N, you have to find the number of ways you can express N as sum of consecutive integers. You have to use at least two integers.</p><p>For example, N = 15 has three solutions, (1+2+3+4+5), (4+5+6), (7+8).</p><p><code>Input</code><br>Input starts with an integer T (≤ 200), denoting the number of test cases.</p><p>Each case starts with a line containing an integer N (1 ≤ N ≤ 1014).</p><p><code>Output</code><br>For each case, print the case number and the number of ways to express N as sum of consecutive integers.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">15</span><br><span class="line">12</span><br><span class="line">36</span><br><span class="line">828495</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 1</span><br><span class="line">Case 2: 3</span><br><span class="line">Case 3: 1</span><br><span class="line">Case 4: 2</span><br><span class="line">Case 5: 47</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e7+10;</span><br><span class="line">ll n,p[maxn/10];</span><br><span class="line">bool is[maxn];</span><br><span class="line">int t,ca,pos;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=2;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!is[i])    p[pos++]=i;</span><br><span class="line">        for(int j=0;j&lt;pos&amp;&amp;i*p[j]&lt;maxn;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            is[i*p[j]]=1;</span><br><span class="line">            if(i%p[j]==0)    break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    init();</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=1;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        for(int i=0;i&lt;pos&amp;&amp;p[i]*p[i]&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll cnt=0;a</span><br><span class="line">            while(n%p[i]==0)    cnt++,n/=p[i];</span><br><span class="line">            if(i)    ans*=cnt+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&gt;2)    ans*=2;</span><br><span class="line">        printf(&quot;Case %d: %lld\n&quot;,++ca,ans-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Aladdin-and-the-Flying-Carpet"><a href="#Aladdin-and-the-Flying-Carpet" class="headerlink" title="Aladdin and the Flying Carpet"></a>Aladdin and the Flying Carpet</h2><p>Description:<br>It’s said that Aladdin had to solve seven mysteries before getting the Magical Lamp which summons a powerful Genie. Here we are concerned about the first mystery.</p><p>Aladdin was about to enter to a magical cave, led by the evil sorcerer who disguised himself as Aladdin’s uncle, found a strange magical flying carpet at the entrance. There were some strange creatures guarding the entrance of the cave. Aladdin could run, but he knew that there was a high chance of getting caught. So, he decided to use the magical flying carpet. The carpet was rectangular shaped, but not square shaped. Aladdin took the carpet and with the help of it he passed the entrance.</p><p>Now you are given the area of the carpet and the length of the minimum possible side of the carpet, your task is to find how many types of carpets are possible. For example, the area of the carpet 12, and the minimum possible side of the carpet is 2, then there can be two types of carpets and their sides are: {2, 6} and {3, 4}.</p><p><code>Input</code><br>Input starts with an integer T (≤ 4000), denoting the number of test cases.</p><p>Each case starts with a line containing two integers: a b (1 ≤ b ≤ a ≤ 1012) where a denotes the area of the carpet and b denotes the minimum possible side of the carpet.</p><p><code>Output</code><br>For each case, print the case number and the number of possible carpets.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">10 2</span><br><span class="line">12 2</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 1</span><br><span class="line">Case 2: 2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1e6;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll p[maxn],pos,vis[maxn];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    pos=0;</span><br><span class="line">    for(int i=2;i&lt;maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!vis[i])    p[pos++]=i;</span><br><span class="line">        for(int j=0;j&lt;pos&amp;&amp;p[j]*i&lt;maxn;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[p[j]*i]=1;</span><br><span class="line">            if(i%p[j]==0)    break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll t,a,b,l=0;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">    init();</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll now=0,ans=1,aa,net=0;</span><br><span class="line">        scanf(&quot;%lld %lld&quot;,&amp;a,&amp;b);</span><br><span class="line">        if(b*b&gt;=a)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Case %d: 0\n&quot;,++l);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        aa=a;</span><br><span class="line">        for(int i=0;i&lt;pos&amp;&amp;p[i]&lt;=a;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int c=0;</span><br><span class="line">            while(a%p[i]==0)</span><br><span class="line">            &#123;</span><br><span class="line">                a/=p[i];</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans*=(c+1);</span><br><span class="line">        &#125;</span><br><span class="line">            if(a&gt;1)    ans*=2;</span><br><span class="line">            ans/=2;</span><br><span class="line">        for(ll i=1;i&lt;b;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(aa%i==0)        </span><br><span class="line">                ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Case %lld: %lld\n&quot;,++l,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Minimum-Sum-LCM"><a href="#Minimum-Sum-LCM" class="headerlink" title="Minimum Sum LCM"></a>Minimum Sum LCM</h2><p>Description:<br>LCM (Least Common Multiple) of a set of integers is defined as the minimum number, which is a<br>multiple of all integers of that set. It is interesting to note that any positive integer can be expressed<br>as the LCM of a set of positive integers. For example 12 can be expressed as the LCM of 1, 12 or 12, 12 or 3, 4 or 4, 6 or 1, 2, 3, 4 etc.<br>In this problem, you will be given a positive integer N. You have to find out a set of at least two positive integers whose LCM is N. As infinite such sequences are possible, you have to pick the sequence whose summation of elements is minimum. We will be quite happy<br>if you just print the summation of the elements of this set. So, for N = 12, you should print 4+3 = 7 as LCM of 4 and 3 is 12 and 7 is the minimum possible summation.<br><code>Input</code><br>The input file contains at most 100 test cases. Each test case consists of a positive integer N (1 ≤ N ≤ 2^31 − 1).<br>Input is terminated by a case where N = 0. This case should not be processed. There can be at most 100 test cases.<br><code>Output</code><br>Output of each test case should consist of a line starting with ‘Case #: ’ where # is the test case number. It should be followed by the summation as specified in the problem statement. Look at the output for sample input for details.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">12</span><br><span class="line">10</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 7</span><br><span class="line">Case 2: 7</span><br><span class="line">Case 3: 6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ll n,cas=1;</span><br><span class="line">    while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=0,cnt=0,x=n;</span><br><span class="line">        for(ll i=2;i*i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mid=1;</span><br><span class="line">            if(n%i==0)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                while(n%i==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    n/=i;</span><br><span class="line">                    mid*=i;</span><br><span class="line">                &#125;</span><br><span class="line">                ans+=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n==x)    ans=x+1;</span><br><span class="line">        else if(n!=1 || cnt == 1)    ans+=n;</span><br><span class="line">        printf(&quot;Case %lld: %lld\n&quot;,cas++,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="GCD-and-LCM"><a href="#GCD-and-LCM" class="headerlink" title="GCD and LCM"></a>GCD and LCM</h2><p>Description:<br>Given two positive integers G and L, could you tell me how many solutions of (x, y, z) there are, satisfying that gcd(x, y, z) = G and lcm(x, y, z) = L?<br>Note, gcd(x, y, z) means the greatest common divisor of x, y and z, while lcm(x, y, z) means the least common multiple of x, y and z.<br>Note 2, (1, 2, 3) and (1, 3, 2) are two different solutions.<br><code>Input</code><br>First line comes an integer T (T &lt;= 12), telling the number of test cases.<br>The next T lines, each contains two positive 32-bit signed integers, G and L.<br>It’s guaranteed that each answer will fit in a 32-bit signed integer.<br><code>Output</code><br>For each test case, print one line with the number of solutions satisfying the conditions above.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">6 72</span><br><span class="line">7 33</span><br><span class="line">Sample Output</span><br><span class="line">72</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">ll L, G;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;G, &amp;L);</span><br><span class="line">ll n = L / G;</span><br><span class="line">//L % G != 0 无解</span><br><span class="line">ll ans = L % G ? 0 : 1;</span><br><span class="line">for(ll i = 2; i * i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">//m是n某一个素因子的幂级数</span><br><span class="line">ll m = 0;</span><br><span class="line">if(n % i != 0) continue;</span><br><span class="line">while(n % i == 0)</span><br><span class="line">&#123;</span><br><span class="line">m ++;</span><br><span class="line">n = n / i;</span><br><span class="line">&#125;</span><br><span class="line">ans = ans * 6 * m;</span><br><span class="line">&#125;</span><br><span class="line">//n仍然不等于1说明此时n是一个大素数</span><br><span class="line">if(n != 1)</span><br><span class="line">ans *= 6;</span><br><span class="line">printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">显然若lcm%gcd!=0时无解，令n=lcm/gcd，对n质因数分解后得到n=p1^k1*p2^k2*…*pm^km，那么必然有</span><br><span class="line">a/g=p1^a1*p2^a2*…*pm^am</span><br><span class="line">b/g=p1^b1*p2^b2*…*pm^bm</span><br><span class="line">c/g=p1^c1*p2^c2*…*pm^cm</span><br><span class="line">所以对于任意i(1&lt;=i&lt;=m)，都有min(ai,bi,ci)=0,max(ai,bi,ci)=ki，当ai,bi,ci三者之中居中者取1~ki-1时，总共有6*(ki-1)种情况，当取0或者ki时，有2*3=6种情况，所以对于每个i，都有6*(ki-1)+6=6*ki种情况，所以枚举n的所有质因子幂级数k每次累乘6*k即可</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//另一种代码</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">long long m, n, ans, i, count;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">while (t--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld%lld&quot;, &amp;m, &amp;n);</span><br><span class="line">if (n % m) puts(&quot;0&quot;);///注意特判</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">n /= m;</span><br><span class="line">ans = 1;</span><br><span class="line">for (i = 2; i * i &lt;= n; i += 2)///不用求素数，因为范围很小(注意n在不断减小)</span><br><span class="line">&#123;</span><br><span class="line">if (n % i == 0)</span><br><span class="line">&#123;</span><br><span class="line">count = 0;</span><br><span class="line">while (n % i == 0)</span><br><span class="line">&#123;</span><br><span class="line">n /= i;</span><br><span class="line">++count;</span><br><span class="line">&#125;</span><br><span class="line">ans *= 6 * count;</span><br><span class="line">&#125;</span><br><span class="line">if (i == 2)</span><br><span class="line">--i;///小技巧</span><br><span class="line">&#125;</span><br><span class="line">if (n &gt; 1) ans *= 6;</span><br><span class="line">printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day23&quot;&gt;&lt;a href=&quot;#Day23&quot; class=&quot;headerlink&quot; title=&quot;Day23&quot;&gt;&lt;/a&gt;Day23&lt;/h1&gt;&lt;p&gt;今天讲的是 &lt;code&gt;算术基本原理&lt;/code&gt; ，没咋学会。。。&lt;br&gt;有是自闭的一天&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算术基本原理" scheme="http://yoursite.com/tags/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Day22</title>
    <link href="http://yoursite.com/2019/08/10/Day22/"/>
    <id>http://yoursite.com/2019/08/10/Day22/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-12T15:21:02.109Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day22"><a href="#Day22" class="headerlink" title="Day22"></a>Day22</h1><p>有是一次<code>积分赛</code><br>有是自闭的一天<br><code>补题</code><br><a id="more"></a></p><h2 id="wzy的大冒险——出发前的清理"><a href="#wzy的大冒险——出发前的清理" class="headerlink" title="wzy的大冒险——出发前的清理"></a>wzy的大冒险——出发前的清理</h2><p>Description:</p><p>由于上次学弟们没有ak，导致许多蚂蚁被留下了。wzy在出发冒险前请来了一只食蚁兽帮忙清理。<br>现在出现了一只食蚁兽。每个蚂蚁都有wzy给它的一个编号，食蚁兽要吃蚂蚁必须要确认蚂蚁的编号X是否满足要求，如下：</p><p>X的质因子的种类不超过13种<br>X的食蚁数是个素数(食蚁数的定义见最下方提示)<br>X的食蚁数是个回文数<br>如果都满足则输出 YES ,否则输出 NO</p><p><code>输入格式</code><br>第一行给定一个T,(1≤T≤1e5)<br>接下来T行，每行给出数字X,(1≤X≤1e17)</p><p><code>输出格式</code><br>每行输出 YES 或者 NO<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">121666</span><br><span class="line">111666</span><br><span class="line">1312333</span><br><span class="line">output</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">提示</span><br><span class="line">补充：</span><br><span class="line">1. 回文数至少为两位数，如 131 、 22</span><br><span class="line">2. 如果X的长度为 len1 ，令 len2=⌊len1/2⌋，则 X 的前 len2 位形成的数是它的食蚁数</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">//打表做法</span><br><span class="line">//借用别人的代码</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define PI acos(-1)</span><br><span class="line">const int NN = 777;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int prime[NN] = &#123;</span><br><span class="line">11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,</span><br><span class="line">10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,</span><br><span class="line">16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,</span><br><span class="line">34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,</span><br><span class="line">71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,</span><br><span class="line">79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,</span><br><span class="line">97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,</span><br><span class="line">1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,</span><br><span class="line">1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,</span><br><span class="line">1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,</span><br><span class="line">1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,</span><br><span class="line">1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,</span><br><span class="line">1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,</span><br><span class="line">1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,</span><br><span class="line">1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,</span><br><span class="line">1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,</span><br><span class="line">1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,</span><br><span class="line">1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,</span><br><span class="line">1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,</span><br><span class="line">1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,</span><br><span class="line">3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,</span><br><span class="line">3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,</span><br><span class="line">3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,</span><br><span class="line">3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,</span><br><span class="line">3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,</span><br><span class="line">3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,</span><br><span class="line">3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,</span><br><span class="line">3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,</span><br><span class="line">3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,</span><br><span class="line">3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,</span><br><span class="line">3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,</span><br><span class="line">3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,</span><br><span class="line">3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,</span><br><span class="line">7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,</span><br><span class="line">7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,</span><br><span class="line">7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,</span><br><span class="line">7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,</span><br><span class="line">7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,</span><br><span class="line">7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,</span><br><span class="line">7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,</span><br><span class="line">7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,</span><br><span class="line">7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,</span><br><span class="line">7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,</span><br><span class="line">7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,</span><br><span class="line">9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,</span><br><span class="line">9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,</span><br><span class="line">9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,</span><br><span class="line">9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,</span><br><span class="line">9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,</span><br><span class="line">9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,</span><br><span class="line">9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,</span><br><span class="line">9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,</span><br><span class="line">9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,</span><br><span class="line">9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899&#125;;</span><br><span class="line"></span><br><span class="line">bool isprime(ll N)&#123;</span><br><span class="line">string str = std::to_string(N);</span><br><span class="line">ll n = 0;</span><br><span class="line">for(int i = 0;i&lt;str.size()/2;i++)&#123;</span><br><span class="line">n = n*10+(str[i]-&apos;0&apos;);</span><br><span class="line">&#125;</span><br><span class="line">if(n == 1||n ==0) return false;</span><br><span class="line">int t = lower_bound(prime,prime+NN,n)-prime;</span><br><span class="line">if(t == NN) return false;</span><br><span class="line">if(prime[t] == n) return true;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll ksm(ll a,ll b)&#123;</span><br><span class="line">ll res = 1;</span><br><span class="line">while(b)&#123;</span><br><span class="line">if(b&amp;1) res = res*a;</span><br><span class="line">a = a*a;</span><br><span class="line">b&lt;&lt;=1;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool divide(ll x)&#123;</span><br><span class="line">int coun = 0;</span><br><span class="line">for(int i = 2;i&lt;=x/i &amp;&amp; i&lt;=100;i++)&#123;</span><br><span class="line">if(x%i ==0 )&#123;</span><br><span class="line">while(x%i ==0) x/=i;</span><br><span class="line">coun++;</span><br><span class="line">if(coun&gt;13) return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">ll T,N;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line">while(T--)&#123;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;N);</span><br><span class="line">if(!isprime(N))&#123;</span><br><span class="line">cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(!divide(N))&#123;</span><br><span class="line">cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//非打表做法</span><br><span class="line">//#pragma GCC optimize(3)</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef unsigned long long ull;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e7+7;</span><br><span class="line"></span><br><span class="line">int prime[MAXN];</span><br><span class="line">int visit[MAXN];</span><br><span class="line">void Prime()&#123;   //网上随便找了个素筛板子，好像visit[i]==0表示素数（为什么两个数组不反过来用</span><br><span class="line">    memset(visit,0, sizeof(visit));</span><br><span class="line">    memset(prime, 0, sizeof(prime));</span><br><span class="line">    for (int i = 2;i &lt;= MAXN; i++) &#123;</span><br><span class="line">        // cout&lt;&lt;&quot; i = &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        if (!visit[i]) &#123;</span><br><span class="line">            prime[++prime[0]] = i;      //纪录素数， 这个prime[0] 相当于 cnt，用来计数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 1; j &lt;=prime[0] &amp;&amp; i*prime[j] &lt;= MAXN; j++) &#123;</span><br><span class="line">            visit[i*prime[j]] = 1;</span><br><span class="line">            if (i % prime[j] == 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char s[20];</span><br><span class="line">char w[20];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // ll q;</span><br><span class="line">    // q = 2*3*5*7*11*13;</span><br><span class="line">    // q = q*17* 19* 23*29*31*37*41; //13:304250263527210  14:13082761331670030</span><br><span class="line">    Prime();</span><br><span class="line">    int i, k, flag, n;</span><br><span class="line">    ll a, b;</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;a);</span><br><span class="line">        if(a&lt;=1000) //食蚁数长度在两位及以上，所以a的长度在四位及以上</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        b = a;</span><br><span class="line">        k = 0;</span><br><span class="line">        flag = 1;</span><br><span class="line">        while(b)  //统计a的长度并且转换为字符串</span><br><span class="line">        &#123;</span><br><span class="line">            s[k++] = b%10;</span><br><span class="line">            b/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        n = k;  //长度</span><br><span class="line">        if(n&gt;=16)   //a长度为16、17位，食蚁数长度为8位；或者a==100000000000000000，食蚁数==100000000</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0; i&lt;k/2; i++)  //取食蚁数字符串</span><br><span class="line">            w[i] = s[k-i-1];</span><br><span class="line">        k/=2;   //k为食蚁数位数</span><br><span class="line">        if(!(k%2))   //一个回文数如果位数为偶数位那么它一定不是素数（11除外）</span><br><span class="line">        &#123;</span><br><span class="line">            if(a/100==11 || a/1000==11) printf(&quot;YES\n&quot;);</span><br><span class="line">            else printf(&quot;NO\n&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0; i&lt;k/2; i++)  //检查回文串</span><br><span class="line">        &#123;</span><br><span class="line">            if(w[i] != w[k-i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = a/pow(10, n-k);</span><br><span class="line">        if(flag &amp;&amp; !visit[n]) printf(&quot;YES\n&quot;);</span><br><span class="line">        else printf(&quot;NO\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="wzy的大冒险——出发咯QAQ"><a href="#wzy的大冒险——出发咯QAQ" class="headerlink" title="wzy的大冒险——出发咯QAQ"></a>wzy的大冒险——出发咯QAQ</h2><p>Description:<br>wzy踏上了冒险的旅程。<br>现在他从地精手里买了一份地图，地图上有n个城镇。<br>他从第一个城镇出发，走向（没钱只能走）第n个城镇，现在，请你帮wzy找到一条最短的路径，并倒序（从n到1）输出一条最短路径。<br>举个栗子:如果有两条路径6 4 3 1和6 5 2 1，我们选择6 4 3 1这条。<br>地精小提示：路是单向的QAQ。</p><p><code>输入格式</code><br>第一行两个数n,m ，(1≤n≤10^3,1≤m≤10^3)</p><p>接下来m行，每行三个数x,y,z，表示点 x 与点 y 之间有一条权值为 z 的有向边 (1≤x,y,z≤10^3).</p><p><code>输出格式</code><br>第一行一个整数表示 1 到 n 的最短距离；<br>第二行倒序输出这条路径。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">5 7</span><br><span class="line">1 2 69</span><br><span class="line">1 3 87</span><br><span class="line">1 4 79</span><br><span class="line">2 5 94</span><br><span class="line">2 3 10</span><br><span class="line">3 5 79</span><br><span class="line">4 5 43</span><br><span class="line">output</span><br><span class="line">122</span><br><span class="line">5 4 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">long long dp[40][2000];</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">    int numRollsToTarget(int d, int f, int target) &#123;</span><br><span class="line">    memset(dp,0,sizeof(dp));</span><br><span class="line">        for(int i=1;i&lt;=f;i++) dp[1][i]=1;</span><br><span class="line">        for(int i=2;i&lt;=d;i++)&#123;</span><br><span class="line">        for(int k=1;k&lt;=f;k++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=2000;j++)&#123;</span><br><span class="line">        if(j&gt;=k) dp[i][j]+=dp[i-1][j-k];</span><br><span class="line">        dp[i][j]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[d][target]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">Solution a;</span><br><span class="line">cout&lt;&lt;a.numRollsToTarget(30,30,500)&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="wzy的大冒险——数学王国"><a href="#wzy的大冒险——数学王国" class="headerlink" title="wzy的大冒险——数学王国"></a>wzy的大冒险——数学王国</h2><p>Description:<br>wzy这一次来到了数学王国，加号国王为了考验他，找来了一个数字n，告诉了wzy这个数字的阶乘的末尾零的个数Q，猜错的话就要把wzy赶出去。现在请你帮帮wzy求这个数最小为多少。<br>若不存在输出”impossible”(输出不带引号)。</p><p><code>输入格式</code><br>输入数据包含T组(1≤T≤10000)<br>每一组数据包含一个数字Q (0≤Q≤10^8)</p><p><code>输出格式</code><br>对于每一组数据请输出这个数字n,否则输出”impossible”(输出不带引号)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">output</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">impossible</span><br><span class="line">input</span><br><span class="line">1</span><br><span class="line">10000000</span><br><span class="line">output</span><br><span class="line">40000010</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e9;</span><br><span class="line">int solve(ll x)</span><br><span class="line">&#123;</span><br><span class="line">ll ans = 0;</span><br><span class="line">while(x)</span><br><span class="line">&#123;</span><br><span class="line">ans = ans + (x / 5);</span><br><span class="line">x = x / 5;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int er_fen(ll n)</span><br><span class="line">&#123;</span><br><span class="line">ll l = 0, r = maxx;</span><br><span class="line">ll mid;</span><br><span class="line">while(l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">mid = l + r;</span><br><span class="line">if(solve(mid / 2) &gt;= n)</span><br><span class="line">r = mid / 2 - 1;</span><br><span class="line">else</span><br><span class="line">l = mid / 2 + 1;</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">ll x, y;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">y = er_fen(x) + 1;</span><br><span class="line">if(solve(y) == x)</span><br><span class="line">printf(&quot;%lld\n&quot;,y);</span><br><span class="line">else</span><br><span class="line">puts(&quot;impossible&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="wzy的大冒险——a-b问题"><a href="#wzy的大冒险——a-b问题" class="headerlink" title="wzy的大冒险——a+b问题"></a>wzy的大冒险——a+b问题</h2><p>Description:<br>每个ACMer都是从a+b问题开始的，今天wzy翻到了他的第一个a+b程序，并想让你来输出它</p><p>#include&lt;stdio.h&gt;<br>int main()<br>{<br>int a,b;<br>scanf(“%d %d”,&amp;a,&amp;b);<br>int c=a+b;<br>printf(“%d\n”,c);<br>return 0;<br>}<br><code>输入格式</code><br>本题无输入</p><p><code>输出格式</code><br>将上面代码输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">output</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a,&amp;b);</span><br><span class="line">int c=a+b;</span><br><span class="line">printf(&quot;%d\n&quot;,c);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;#include&lt;stdio.h&gt;\n&quot;);</span><br><span class="line">printf(&quot;int main()\n&quot;);</span><br><span class="line">printf(&quot;&#123;\n&quot;);</span><br><span class="line">printf(&quot;int a,b;\n&quot;);</span><br><span class="line">printf(&quot;scanf(\&quot;&quot;);</span><br><span class="line">cout &lt;&lt; &quot;%d &quot; &lt;&lt; &quot;%d&quot;;</span><br><span class="line">printf(&quot;\&quot;,&amp;a,&amp;b);\n&quot;);</span><br><span class="line">printf(&quot;int c=a+b;\n&quot;);</span><br><span class="line">printf(&quot;printf(\&quot;&quot;);</span><br><span class="line">cout &lt;&lt; &quot;%d\\n&quot;;</span><br><span class="line">printf(&quot;\&quot;,c);\n&quot;);</span><br><span class="line">printf(&quot;return 0;\n&quot;);</span><br><span class="line">printf(&quot;&#125;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="wzy的大冒险——炉石传说"><a href="#wzy的大冒险——炉石传说" class="headerlink" title="wzy的大冒险——炉石传说"></a>wzy的大冒险——炉石传说</h2><p>Description:<br>wzy来到了炉石传说的世界。<br>他发现他现在有n个攻击力为ai的随从，每个随从只能攻击一次。<br>对面的boss有m个血量为bi的具有嘲讽的随从（嘲讽即为你必须先把这些怪物击败才可攻击boss）。<br>当我方随从攻击力大于等于敌方随从血量时，敌方随从死亡。<br>由于boss的强力技能，对方的随从只能受到一次攻击，受到攻击后无法再一次受到攻击。(你无法使两个随从都攻击对方的同一个的随从)。<br>wzy必须先干掉对方的所有随从才能使用剩下的随从攻击boss本身。<br>对方boss有k的血量，现在请问wzy能否干掉敌方boss回归现实世界？</p><p><code>输入格式</code><br>第一行为三个数n，m，k。n 为wzy拥有的随从数量，m为boss拥有的随从数量，k为boss血量。<br>第二行为n个数，分别是wzy随从的攻击力;<br>第三行为m个数，分别是boss随从的血量。<br>以上数据范围均在[1,100]范围内</p><p><code>输出格式</code><br>如果胜利输出Win，否则输出Lose<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">4 3 2</span><br><span class="line">2 4 6 8</span><br><span class="line">3 5 7</span><br><span class="line">output</span><br><span class="line">Win</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 101;</span><br><span class="line"></span><br><span class="line">int cmp(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int a[maxx], b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; b[i];</span><br><span class="line">sort(a + 1, a + n + 1);</span><br><span class="line">sort(b + 1, b + m + 1);</span><br><span class="line">int flag = 0;</span><br><span class="line">if(n &lt;= m) puts(&quot;Lose&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int ans = 0;</span><br><span class="line">if(a[n] &gt;= b[m])</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1;j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[j] &lt; b[i])</span><br><span class="line">&#123;</span><br><span class="line">ans += a[j];</span><br><span class="line">a[j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a[j] = 0;</span><br><span class="line">b[i] = 0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) ans += a[i];</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">if(b[i] != 0)</span><br><span class="line">flag = 1;</span><br><span class="line">if(ans &gt;= k &amp;&amp; flag == 0) puts(&quot;Win&quot;);</span><br><span class="line">else puts(&quot;Lose&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else puts(&quot;Lose&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="wzy的大冒险——接龙红包"><a href="#wzy的大冒险——接龙红包" class="headerlink" title="wzy的大冒险——接龙红包"></a>wzy的大冒险——接龙红包</h2><p>Description:<br>最近QQ更新了一个新的功能–“接龙红包”，会长作为算协的土豪，便开始在群里发红包,wzy总是抢的又快又准，现在他开始研究成语接龙的奥秘。<br>现在QQ的词库里面有n种成语，每种成语由一个只由小写字母组成的字符串表示，现在wzy发现了一个问题，如果有个同学说了一个成语，但是在词库里找不到可以接在它后面的成语（即找不到一个成语的首字母和该成语的尾字母相同），这样的成语被称为死局成语，现在zy想知道在词库里面有多少这样的死局成语。</p><p><code>输入格式</code><br>第一行输入n，接下来n行每行输入一个字符串代表一个成语s。<br>(1≤n≤100,1≤|s|≤20)</p><p><code>输出格式</code><br>第一行输出死局成语的个数m。<br>接下来m行每行输出一个死局成语，输出顺序应和输入顺序保持一致。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">aaa</span><br><span class="line">bab</span><br><span class="line">abc</span><br><span class="line">output</span><br><span class="line">1</span><br><span class="line">abc</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">output</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx=1e5;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str[maxx], str2[maxx];</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; str[i];</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0, len = 1;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int flag = 0;</span><br><span class="line">//if(str[i][0] == str[i][str[i].size() - 1]) continue;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(str[j][0] == str[i][str[i].size() - 1])</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) continue;</span><br><span class="line">ans ++;</span><br><span class="line">str2[len ++] = str[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">cout &lt;&lt; str2[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="大树的水塘"><a href="#大树的水塘" class="headerlink" title="大树的水塘"></a>大树的水塘</h2><p>Description:<br>那一天，世界上所有的人类都……变成了石头！</p><p>3700年后，千空和大树从石头中苏醒过来，但是世界发生了翻天覆地的变化，人类文明已经不复存在</p><p>天才少年千空立志用自己的科学知识在这个「石之世界」中重建文明</p><p>为了生存，淡水是必不可少的，每次都用海水进行蒸馏会比较麻烦，所以千空决定让大树建造一个水塘来存储雨水</p><p>水塘建造在一个无限长，高度不超过100，宽度为1的峡谷里，所以只需要往里面填石头，即可达到蓄水的目的</p><p>当大树建造好水塘让千空去检查的时候，千空一口老血喷了出来：因为大树是一个体力笨蛋，所以建造的水塘底部是参差不齐的，这使得建造蓄水相同体积的水塘，大树多用了好多石头</p><p>已知每块石头中的规格是1×1×1，水塘的长度为N，宽度为1，在第i位置，大树放了ai个石头</p><p>设大树建造的水塘蓄水量为V</p><p>请你求出在长度和宽度不变的情况下，建造一个蓄水量不小于V的水塘最多可以节约多少石头</p><p><code>输入格式</code><br>单组输入</p><p>第一行一个数N (1≤N≤10^7)表示水塘的长度</p><p>第二行有N个非负数xi (0≤xi≤100)，表示第i个位置上放的石头数</p><p><code>输出格式</code><br>输出有两行</p><p>第一行输出大树建造的水塘的蓄水量V</p><p>第二行输出最多可以节约多少石头</p><p>提示：<br><img src="https://i.loli.net/2019/08/12/QEaeDWHc3n6N5U4.png" alt="water.7mDyN9DT.png"><br><img src="https://i.loli.net/2019/08/12/N3wqmRapOiJcSFr.png" alt="water_new.pQvfFov7.png"><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">5</span><br><span class="line">2 1 3 1 3</span><br><span class="line">output</span><br><span class="line">3</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e7 + 10;</span><br><span class="line">int a[maxx];</span><br><span class="line">int l[maxx], r[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">int n;</span><br><span class="line">int max_left, max_right;</span><br><span class="line">int cnt_left, cnt_right;</span><br><span class="line">ll v;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">ll sum = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">//输入每个石块，算出总石头个数</span><br><span class="line">cin &gt;&gt; a[i], sum += 1LL * a[i];</span><br><span class="line">max_left = max_right = 0;</span><br><span class="line">v = 0;</span><br><span class="line">//前后缀</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">max_left = max(max_left, a[i]), l[i] += max_left;</span><br><span class="line">for(int i = n - 1; i &gt;= 0; i --)</span><br><span class="line">max_right = max(max_right, a[i]), r[i] += max_right;</span><br><span class="line">//利用前后缀和的优势找出来，算出储水体积</span><br><span class="line">for(int i = 0; i &lt;= n; i ++)</span><br><span class="line">v += 1LL * min(l[i], r[i]) - a[i];</span><br><span class="line">cout &lt;&lt; v &lt;&lt; &quot;\n&quot;;</span><br><span class="line">//除去两边的石块(因为两边都是石头)</span><br><span class="line">int height = ceil(1.0 * v / (n - 2));</span><br><span class="line">//保证储水不溢出，两边都要有防护</span><br><span class="line">cout &lt;&lt; sum - height * 2 &lt;&lt; &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="幸运素数"><a href="#幸运素数" class="headerlink" title="幸运素数"></a>幸运素数</h2><p>Description:<br>跳皮筋 我第一，马兰开花二十一；</p><p>二五六 二五七，二八二九三十一；</p><p>三五六 三五七，三八三九四十一；</p><p>……</p><p>童谣《马兰花》作为建国以来最大的数学难题，里面数字的含义困扰了全国人民几十年，并且一直未解</p><p>难道这些数字真的只是为了押韵生搬硬凑的数字吗？</p><p>并！不！是！</p><p>经过wzy的多年研究，他发现了里面潜藏的惊天大秘密（并没有）：</p><p>28=256，而257是离256最近的素数</p><p>28是第二个完美数，29是离28最近的素数</p><p>31是第四个幸运素数</p><p>仅仅这一句话中，就出现了二进制、素数、完美数、幸运数！</p><p>这哪里是童谣？这分明就是中国版的达芬奇密码！</p><p>今天wzy就来考考你《马兰花》里出现的数学知识：</p><p>幸运数是经由类似埃拉托斯特尼筛法的演算法后留下的整数集合，是在1955年波兰数学家乌拉姆提出。</p><p>由一组由1开始的数列为例：</p><p>1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25, …<br>先将所有偶数删去，只留下奇数：</p><p>1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25,…<br>然后把数列中的第 2 个数字(设该数字为 x )的倍数对应的数删除，即把所有第 nx,x∈Z+ 个数删除，例如上述例子中，第 2 数字是 3 ，所以删去所有第 3n 个数：</p><p>1, 3, 7, 9, 13, 15, 19, 21, 25,…<br>新数列的第 3 项(每次都加上 1 )为 7 ，因此将新数列的第 7n 个数删除：</p><p>1, 3, 7, 9, 13, 15, 21, 25,…<br>若一直重复上述的步骤，最后剩下的数就是幸运数</p><p>（以上内容来自维基百科幸运数）</p><p>我们将既是幸运数又是素数的数叫做幸运素数</p><p>现在给你一个数N，请判断N是否是一个幸运素数</p><p><code>输入格式</code><br>第一行一个数T，代表有T个数(1≤T≤2×10^5)</p><p>第1∼T行，每行一个正整数N(1≤N≤2×10^5)</p><p><code>输出格式</code><br>对于每个输入的数N，如果N是幸运素数，输出Yes，否则输出No<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">output</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 2e5 + 50;</span><br><span class="line">int prime[maxx], luck[maxx];</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">void get_prime()</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt; 200010; i ++)</span><br><span class="line">prime[i] = 1;</span><br><span class="line">prime[0] = prime[1] = 0;</span><br><span class="line">for(int i = 2; i &lt; 200010; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 2; j * i &lt; 200010; j ++)</span><br><span class="line">prime[i * j] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_luck()</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(0);</span><br><span class="line">for(int i = 1; i &lt; 200010; i += 2)</span><br><span class="line">v.push_back(i);</span><br><span class="line">for(int i = 1; i &lt; 200010; i ++)</span><br><span class="line">luck[i] = 0;</span><br><span class="line">int ti = 2;</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">int len = v.size();</span><br><span class="line">int s = v[ti];</span><br><span class="line">if(s &gt; len - 1)</span><br><span class="line">break;</span><br><span class="line">for(int i = s; i &lt; len; i += s)</span><br><span class="line">v[i] = 0;</span><br><span class="line">for(auto it = v.begin() + 1; it &lt; v.end(); it ++)</span><br><span class="line">if(*it == 0)</span><br><span class="line">v.erase(it);</span><br><span class="line">ti ++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; v.size(); i ++)</span><br><span class="line">luck[v[i]] = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">get_prime();</span><br><span class="line">get_luck();</span><br><span class="line">int t , n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">for(int i = 1; i &lt;= t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">if(luck[n] &amp;&amp; prime[n])</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="NO-GAME-NO-LIFE"><a href="#NO-GAME-NO-LIFE" class="headerlink" title="NO GAME NO LIFE"></a>NO GAME NO LIFE</h2><p>Description:<br>空白，永不败北！</p><p>作为世界的唯一神灵，游戏之神特图的日常就是改变自己的外表，在世界各地游荡</p><p>在被空和白在一次网上的国际象棋比赛击败后，他以拯救人类种的名义将兄妹二人召唤到迪斯博德</p><p>来到迪斯博德的空白，常常因为在游戏上找不到对手而感到无聊</p><p>在风和日丽的一个下午，空白出门视察国情，在路上偶遇了扮成人类种闲逛的特图，特图为了打发时间，决定向空白发起挑战，游戏内容如下：</p><p>在一棵有着N个节点的树上，第i个节点上有xi颗钻石，由最先开始的一方选择一个节点进行标记，标记完成后，双方轮流进行如下操作：拿走标记节点的一颗钻石，并将标记移至与当前节点直接相连的节点，至到出现无法拿石子的一方停止。</p><p>空白兄妹听完游戏规则后，立刻做出了回应，但前提是空白作为先手选择节点</p><p>特图自认为这是一个特别公平的游戏，所以就答应了这个要求</p><p>每当一棵树出现后，空白凭借超人的数学能力，能够在一秒内快速判断出能否获胜</p><p><code>输入格式</code><br>单组输入，第一行一个正整数N (2≤N≤10^6)，表示这棵树有N个节点</p><p>第二行有N个正整数xi (1≤xi≤100)，表示i节点上有xi颗钻石</p><p>接下来N−1行，每行两个整数x,y (1≤x,y≤N)，表示节点x与节点y相连</p><p><code>输出格式</code><br>如果空白可以获胜，输出Blank</p><p>否则输出Teto<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">output</span><br><span class="line">Teto</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">output</span><br><span class="line">Blank</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e6 + 10;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">int x, y;</span><br><span class="line">for(int i = 1; i &lt; n; i ++)</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">sort(a, a + n);</span><br><span class="line">n = unique(a, a + n) - a;</span><br><span class="line">if(n == 1)</span><br><span class="line">cout&lt;&lt;&quot;Teto&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;Blank&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*不要直接用cin,cout，会超时*/</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day22&quot;&gt;&lt;a href=&quot;#Day22&quot; class=&quot;headerlink&quot; title=&quot;Day22&quot;&gt;&lt;/a&gt;Day22&lt;/h1&gt;&lt;p&gt;有是一次&lt;code&gt;积分赛&lt;/code&gt;&lt;br&gt;有是自闭的一天&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Day21比赛题解</title>
    <link href="http://yoursite.com/2019/08/09/Day21%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/08/09/Day21题解/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-09T13:33:38.196Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day21"><a href="#Day21" class="headerlink" title="Day21"></a>Day21</h1><p><code>比赛题解</code><br><code>补题</code><br><a id="more"></a></p><blockquote><p>PS:只要能看得懂题意，就是水题了</p></blockquote><p><a href="https://vjudge.net/contest/318470#overview" target="_blank" rel="noopener">链接</a></p><h2 id="MaratonIME-helps-Pablito"><a href="#MaratonIME-helps-Pablito" class="headerlink" title="MaratonIME helps Pablito"></a>MaratonIME helps Pablito</h2><p>Description:<br>♬ Caloventor tiene miedo… ♬<br>Benedetto, Nathan<br>As is well known by any cultured person, rats are the smartest beings on earth. Followed directly by dolphins.</p><p>MaratonIME knows about the species hierarchy and uses this knowledge in it’s regard. Usually, when they need some resource, they know it’s always useful to have a smart rat available. Unfortunately, rats are not very fond of us, primates, and will only help us if they owe us some favour.</p><p>With that in mind, MaratonIME decided to help a little rat called Pablito. Pablito is studying rat’s genealogy, to help with cloning and genetic mapping. luckily, the way rats identify themselves make the job much easier.</p><p>The rat society is, historically, matriarchal. At first, there were little families, each of which had it’s own leading matriarch. At that time, it was decided that rats would organize themselves according to the following rules:</p><p>Each martiarch had an id number greater than one.<br>Each of these ids were chosen in a way such that they would have the least amount of divisors possible.<br>Each family member had the same id as the matriarch.<br>The id of any newborn rat would be the product of its parents id’s.<br>For instance, the offspring of a rat with id 6 and another with id 7 is 42.</p><p>Pablito needs to know if two given rats have a common ancestor, but his only tool is the id number of each of the two rats, which is always a positive integer greater than 1 with no more than 16 digits. Can you help him?</p><p>Create a program that decides if a pair of rats have some common ancestor.</p><p><code>Input</code><br>The input begins with a positive integer t ≤ 105, the number of test cases.</p><p>After that, follows t lines, each with two integers ai e bi identifying two rats.</p><p>Every rat’s id is a positive integer greater than 1 and with no more than 16 digits.</p><p><code>Output</code><br>For each test case, print “Sim” if the rats ai and bi share a common ancestor and “Nao” otherwise.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">2</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">Output</span><br><span class="line">Sim</span><br><span class="line">Nao</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long t, n, m;</span><br><span class="line">while(~scanf(&quot;%lld&quot;,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt;= t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;n, &amp;m);</span><br><span class="line">int ans = __gcd(n, m);</span><br><span class="line">if(ans != 1) puts(&quot;Sim&quot;);</span><br><span class="line">else puts(&quot;Nao&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-plays-Cirokime"><a href="#MaratonIME-plays-Cirokime" class="headerlink" title="MaratonIME plays Cîrokime"></a>MaratonIME plays Cîrokime</h2><p>Description:<br>Have you ever seen flavored vodka?<br>Everaldo, Glauber<br>The MaratonIME members like to have fun. As they enjoy having fun so much, they have invented a game named “Cîrokime”. The game works as follows:</p><p>First, n cups with Cîroc1 are lined up. In front of the i-th cup a number ai is written. It is guaranteed that ai &lt; ai + 1, for all 1 ≤ i &lt; n. Then, the numbers are covered and the game starts.</p><p>The player must then find the cup that has a certain number x. It is guaranteed that this cup exists. For this, he has to choose a cup i and drink the beverage. Then, the cup’s number ai is revealed and if this number is equal to x the game finished. Otherwise, the player has to choose another cup and so on.</p><p>“Cîrokime” is a traditional game among MaratonIME members, they play it every party. At the last party, Sussu had to drink all of the n cups because he found the right cup only at the end. He got sick for drinking so much and had to be carried home3</p><p>However, the DESMAME4 is scheduled for May 13 and Sussu wants to restore his dignity. For this, he wants to know, in the worst case, what is the maximum number of cups that he will have to drink if he plays in the optimal way.</p><p><code>Input</code><br>The first line has a single integer n, the number of cups. The second line has n integers ai, the values hidden in each cup.</p><p>1 ≤ n ≤ 105<br>For all i, 1 ≤ ai ≤ 109<br>For i &lt; n, ai &lt; ai + 1<br><code>Output</code><br>The output has a single line with a single integer: the minimum number of cups that Sussu should drink, in the worst case, if he plays in the optimal way.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">3</span><br><span class="line">2 5 7</span><br><span class="line">Output</span><br><span class="line">2</span><br><span class="line">Input</span><br><span class="line">8</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line">Output</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, ans;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">ans = 0;</span><br><span class="line">for(int i = 0; i &lt; t; i ++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">while(t)</span><br><span class="line">&#123;</span><br><span class="line">t /= 2;</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-plays-Nim"><a href="#MaratonIME-plays-Nim" class="headerlink" title="MaratonIME plays Nim"></a>MaratonIME plays Nim</h2><p>Description:<br>Ai Fox!<br>UnionFind, Germano<br>You open your eyes, but everything remains dark. The world is dark, and everything shakes. You realize you are locked in, but before desperation takes hold, you hear the door opening and the light invades your sight and blinds you for a few moments.</p><p>They help you out, you had been locked inside a trunk. You don’t know the masked faces before you, but remember that in the last competitive programming practice they told you that “the beginning is yet to come”. “So this is the fabled MaratonIME’s initiation challenge”, you had heard rumors of this event, and you feel honored to be chosen.</p><p>After walking into and abandoned building, they sit you on an old chair. The first test is to watch a soccer game without any show of excitement. Easy. The second is to install Linux on a notebook in less than 5 minutes. You were prepared, carrying the Arch Linux pendrive as usual, just in case. You face more tests, and manage to pass all of them despite a few difficulties.</p><p>Hours go by, the members remove their masks, and each take a coin out of their pocket. “I won! And I even got rich” you think, but realize they place the coins in a table in front of you, divided in two piles. Renzo, MaratonIME’s great boss, takes a chair and sits in front of you. You will play a match of Nim, and if you win you will become an honorary member of MaratonIME, that is, you win a balloon.</p><p>Nim is a game of two players, alternating their turns. Two piles of coins are placed on a table and in each turn you can remove any non zero quantity of coins from one of the piles. The last player to take their turn (leaving both piles empty) wins.</p><p>You start the game. So it would not be unfair, it is guaranteed that it is possible for you to win. Write a program than beats Renzo 100% of the time.</p><p><code>Input</code><br>In the first line, two integers, x and y, the size of the piles, such that 0 ≤ x, y ≤ 104. It is guaranteed that you can win the game.</p><p><code>Interaction</code><br>In your turn, print two integers, i and x, where i is the number of the pile from which you will remove the coins (i 属于 {1, 2}), and x is the number of coins you will remove (x ≥ 1, such that i has at least x coins).</p><p>In Renzo’s turn, read two integers, in the same format as in your turn.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">2 1</span><br><span class="line">1 1</span><br><span class="line">Output</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">Note</span><br><span class="line">Of course we do not do an initiation challenge like this :P</span><br><span class="line"></span><br><span class="line">In the example, we have a pile with 2 coins and another with 1. You remove 1 coin from the first pile, and now no matter what coin Renzo removes, you can remove the other and win.</span><br><span class="line"></span><br><span class="line">Remember, after printing your play, flush the output, like: fflush(stdout); in C, cout.flush(); in C++, or sys.stdout.flush() in Python.</span><br></pre></td></tr></table></figure><p></p><blockquote><p>关于flush()<br>flush() 是把缓冲区的数据强行输出，(注意不要和frush()刷新混淆了)<br>主要用在IO中，即清空缓冲区数据，一般在读写流(stream)的时候，数据是先被读到了内存中，再把数据写到文件中，当你数据读完的时候不代表你的数据已经写完了，因为还有一部分有可能会留在内存这个缓冲区中。这时候如果你调用了close()方法关闭了读写流，那么这部分数据就会丢失，所以应该在关闭读写流之前先flush()。<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    if(a==0) </span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;2&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">       cout.flush();</span><br><span class="line">       return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0) </span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;1&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">       cout.flush();</span><br><span class="line">       return 0;    </span><br><span class="line">    &#125;</span><br><span class="line">    if(a&gt;b) </span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;1&quot;&lt;&lt;&quot; &quot;&lt;&lt;a-b&lt;&lt;endl;</span><br><span class="line">        cout.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a&lt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;2&quot;&lt;&lt;&quot; &quot;&lt;&lt;b-a&lt;&lt;endl;</span><br><span class="line">        cout.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int x;</span><br><span class="line">    while(cin&gt;&gt;x&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">cout&lt;&lt;3-x&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">        cout.flush();</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="MaratonIME-plays-Chess"><a href="#MaratonIME-plays-Chess" class="headerlink" title="MaratonIME plays Chess"></a>MaratonIME plays Chess</h2><p>Description:<br>This problem is boring as duck.<br>Kawakami, Marcos<br>Our dear Nathan, when a little child, used to like chess a lot, but this was a long time ago. One of these days he was challenged by @luisgust to a chess match and, as he is a guy that likes hard challenges, he accepted it. The problem is that Nathan keeps forgetting the rules of the game, so he asked you to help him determine if a given opponent’s piece can be captured in one move.</p><p>Chess, in MaratonIME, is represented as a matrix of characters. Instead of playing with black and white pieces, they play with uppercase and lowercase letters. Nathan has chosen to play with the lowercase letters.</p><p>Besides that, as usual, the positions on the matrix are given in the following coordinates system: Each position is a pair with a character between a and h (inclusive), representing the column, and an integer between 1 and 8 (inclusive), representing the row. For exemple, the position d2 refers to the fourth column (from left to right) and second row (from bottom to top), and the position f6 refers to the sixth column and sixth row. Lowercase letters start on the bottom of the grid, on lines 1 and 2.</p><p>Here position A is adjacent position B if A shares a vertex with B, that is, if the distance between their rows is at most one and the distance between their columns is at most one. For example, the position c4 is adjacent to 8 positions: b3, b4, b5, c3, c5, d3, d4 and d5.</p><p>They decided to play a simplified version of chess. To help you, they gave you the following manual on how to play it:</p><p>The pawn, represented by p or P, can capture pieces that share a diagonal and is in front of it, that is, the lowercase pawn on c4 can capture pieces at b5 or d5.<br>The knight, represented by c or C, makes L-shaped moves in any of the 8 possible directions, that is, it moves two positions in any direction and after that one position in a direction that is perpenticular to the first one. A knight on c4 can capture, in one move, pieces on positions a3, a5, b2, b6, d2, d6, e3 and e5.<br>The rook, represented by t or T, can capture pieces that are on the same row or the same column as it, as long as no other piece lies between them. For example, a rook on c4 can capture any piece on column c or row 4, as long as there is no other piece in between. If the rook is on c4 and there is another piece on c6, the rook can’t capture pieces on c7 and c8.<br>The bishop, represented by b or B, can capture any piece on one of its diagonals as long as there are no piece between them (diagonaly). For example, the bishop on c4 can capture a piece on f7 as long as there are no piece on d5 and e6.<br>The queen, represented by r or R, can capture any piece that lies on the same row, column or diagonal, given there are no pieces in between, as if it were a bishop and a rook at the same time.<br>The king, represented by k or K, can capture any piece that is adjacent to it.<br>The character . represents an empty position.<br>Given a matrix representing a chess board and an opponent’s piece, your program needs to determine whether you can capture it with one of your pieces. It is guaranteed that each player has at most two bishops, two rooks, two knights, eight pawns, one king and one queen.</p><p><code>Input</code><br>The input begins with 8 lines with 8 characters each, representing the chess board. The first line contains the characters on the positions a8, b8, … , h8. The second line contains the characters on positions a7, b7, … , h7, and so on. After that follows a line containing the position of the opponent’s piece you wish to capture.</p><p><code>Output</code><br>Print a single line containing the word Sim if it is possible to capture the piece or Nao otherwise.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">TCBRKBCT</span><br><span class="line">PPPPPPPP</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">pppppppp</span><br><span class="line">tcbrkbct</span><br><span class="line">d8</span><br><span class="line">Output</span><br><span class="line">Nao</span><br><span class="line">Input</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">..R.....</span><br><span class="line">...p....</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">c5</span><br><span class="line">Output</span><br><span class="line">Sim</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不会，，，</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-rides-the-university-bus"><a href="#MaratonIME-rides-the-university-bus" class="headerlink" title="MaratonIME rides the university bus"></a>MaratonIME rides the university bus</h2><p>Description:<br>If we organize it correctly, …<br>Unknown<br>To make the trip to the subway less boring and tiring, the SPSU, Sao Paulo State University, tried one of its most famous inventions: buses with Infinite Inner Length! In such a modern engineering wonder, there’s always a couple of empty seats for the students to sit and chat during the trip.</p><p>MaratonIME crew is very popular, so popular that they have friends at every SPSU institute. Like everyone else from this university, they need to take the bus after a long day learning how to fix the Wi-Fi network. Because they don’t practice sports like rowing, every SPSU student sits right after entering the bus, making pairs whenever possible. Thinking about that, Gi, an ICPC expert, comes with a problem to think on the way to the subway: given a number n which indicates the number of institutes at SPSU and n integers ai representing the amount of people waiting for the bus at the institute i, Gi wants to know for m pairs lj, rj (lj ≤ rj) if all the people waiting for the bus at any point between lj e rj (inclusive) took an empty bus, they could sit together in pairs (nobody would sit alone).</p><p><code>Input</code><br>The input consist in one line with two integers n and m, the number of institutes and the number of Gi’s questions. In the second line there are n integers ai, the number of people waiting for the bus at the ith institute. Then follows m lines with two integers each, li and ri, the first and last institute of Gi’s question.</p><p>1 ≤ n, m ≤ 105<br>0 ≤ ai ≤ 105<br>1 ≤ li ≤ ri ≤ n<br><code>Output</code><br>Output “Sim” if it is possible to organize all the pairs in a way nobody sits alone or “Nao” otherwise.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">5 2</span><br><span class="line">1 4 10 3 2</span><br><span class="line">3 5</span><br><span class="line">2 3</span><br><span class="line">Output</span><br><span class="line">Nao</span><br><span class="line">Sim</span><br><span class="line">Note</span><br><span class="line">In the first sample we have 5 institutes with 1, 4, 10, 3 and 2 students. Gi asks if it is possible to form only couples if the ones between the 3rd and the 5th institutes takes an empty bus and the ones between the 2nd and the 3rd. For the first we have 15 so we can&apos;t and for the second we have 14 so we can.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int sum[maxx];</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(sum, 0, sizeof sum);</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum[i] += sum[i - 1] + a[i];</span><br><span class="line">&#125;</span><br><span class="line">int x, y;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">if((sum[y] - sum[x - 1]) &amp; 1) puts(&quot;Nao&quot;);</span><br><span class="line">else puts(&quot;Sim&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-attends-the-lecture-or-not"><a href="#MaratonIME-attends-the-lecture-or-not" class="headerlink" title="MaratonIME attends the lecture (or not)"></a>MaratonIME attends the lecture (or not)</h2><p>Description:<br>Has the prof taken attendance yet?<br>Student, IME’s<br>In MaratonIME, as many other groups, some students want to attend lectures just enough to not be flunked by frequency (as we know, in USP, University of Sao Paulo, it is necessary to have 70 percent frequency), however some others are dedicated and try to accomplish the most frequency percent possible, going to school even when they are ill or tired. Curiously, there is not any other kind of students in MaratonIME.</p><p>Wood, an old MaratonIME’s member, needs help. He is taking the course MAC4815162342, and attended k of m lectures that were given. Consider that MAC4815162342 has n lectures in total per semester. He ask you to help finding the best way to accomplish his objectives, but, as you are new in MaratonIME, you don’t know the kind of student that he is. Embarassed to ask more, you decide to solve two problems, so there is not way to go wrong.</p><p><code>Input</code><br>The input consists of a just one line. In this line, you are given three integers n, m and k, with 1 ≤ n ≤ 107 and 0 ≤ k ≤ m ≤ n.</p><p>n is the number of lectures of MAC4815162342 per semester, m is the quantity of lectures that were given and k is the number of lectures attended by Wood.</p><p><code>Output</code><br>In the first line, print the minimum number of lectures that Wood needs to attend to accomplish at least 70% frequency, or  - 1 if it is impossible to accomplish 70% frequency.</p><p>In the second line, print the maximum frequency percent that Wood can accomplish, if he goes to all of the lectures from the next lecture. This value has to be rounded down to the closest integer. Don’t print ‘%’.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">10 5 2</span><br><span class="line">Output</span><br><span class="line">5</span><br><span class="line">70</span><br><span class="line">Input</span><br><span class="line">11 2 1</span><br><span class="line">Output</span><br><span class="line">7</span><br><span class="line">90</span><br><span class="line">Note</span><br><span class="line">On the second example, the maximum percentage that Wood can get is 90.9090.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, k, ans;</span><br><span class="line">while(~scanf(&quot;%d %d %d&quot;,&amp;n, &amp;m, &amp;k))</span><br><span class="line">&#123;</span><br><span class="line">int x = (ceil)(0.7 * n);</span><br><span class="line">if(x &gt; k) x -= k;</span><br><span class="line">else x = 0;</span><br><span class="line">ans = (k + n - m) * 100.0 / n;</span><br><span class="line">if(ans &lt; 70)x = -1;</span><br><span class="line">printf(&quot;%d\n%d\n&quot;,x, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-goes-rowing"><a href="#MaratonIME-goes-rowing" class="headerlink" title="MaratonIME goes rowing"></a>MaratonIME goes rowing</h2><p>Description:<br>Speed down, Colombooo!!!<br>rowing coach, Gabi<br>As common sense tells us, competitive programmers excel at rowing. The olympic lane is a wonderful place to row, run and work out. What few take their time to appreciate are the capybaras that inhabit the region. Capybaras are fascinating animals! Aside from their beauty, they possess many interesting behaviours. Did you know that capybaras can live in packs as big as 100 individuals?</p><p>In a pleasant sunny morning, Yan was running, as usual. Watching the capybaras, he noticed that they would line up to sunbath. Each capybara was paired with another one, and only another one. Two capybaras can be paired if and only if both see each other. A capybara sees everything in the direction it is looking.</p><p>Curious, Yan decided to represent the capybaras by the letters A and B, where A indicates that the capybara is looking right, and B indicates that the capybara is looking left.</p><p>For example, the sequence AABABB accurately represents capybaras sunbathing, because it is possible to pair every capybara according to the rules above. Yan was so fascinate by this that he slipped and felt into the water, messing his representations. He was able to recover some, but now they are all messed up with each other. Can you help him and find out if a given sequence represent capybaras sunbathing?</p><p><code>Input</code><br>Every instance contains a sequence S of characters, composed only of ‘A’ and ‘B’ – Yan’s representation. You may assume that 1 ≤ |S| ≤ 105.</p><p><code>Output</code><br>The output should contain a single line. Print “Sim” if the sequence represents capybaras sunbathing, or “Nao” otherwise.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">AABABB</span><br><span class="line">Output</span><br><span class="line">Sim</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">while(cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">int flag = 0, cnt = 0, ans = 0, L = 0, R = 0;</span><br><span class="line">int len = str.size() - 1;</span><br><span class="line">if((len + 1) &amp; 1)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt;= len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(str[i] == &apos;A&apos;) L ++;</span><br><span class="line">if(str[i] == &apos;B&apos;) R ++;</span><br><span class="line">&#125;</span><br><span class="line">if(L != R)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; str.size() / 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(str[0] == &apos;B&apos; || str[len] == &apos;A&apos;)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(str[i] == &apos;A&apos;)</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">else if(str[i] == &apos;B&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt &lt; ans)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;Nao&quot;);</span><br><span class="line">else puts(&quot;Sim&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-goes-to-the-movies"><a href="#MaratonIME-goes-to-the-movies" class="headerlink" title="MaratonIME goes to the movies"></a>MaratonIME goes to the movies</h2><p>Description:<br>Better than “Fifth Wave”<br>in the World, Everyone<br>Believe it if you can, studies show that we in MaratonIME live not only out of competitive programming.</p><p>In a saturday, after taking part in a virtual contest, our heroes decide to enjoy the afternoon watching a movie session. But they didn’t choose any movie, but an n-D movie, that is, a movie with n dimensions.</p><p>During a chase scene, the main character jumps over a chain in the parking lot. Of course this was done in a very athletic way, and for some reason that drove Yan, one of the competitive programmers, mad.</p><p>“Hollywood makes everything seem easy, but jumping over a chain is really hard!”</p><p>The rest of the crowd, after the movie, argued with Yan that the actor surely jumped over the chain, but Yan disagreed, saying that it was done by some camera trick or by special effects.</p><p>To prove his point, he bought another ticket for the movie and this time he took highly precise measuring instruments to the session. Yan’s plan was to show that the distance from the actor’s foot to the floor was smaller than the distance from the chain to the floor, and that would prove that the actor didn’t actually jump over the chain.</p><p>But math in n dimensions is hard. Everyone knows that distance in the 2D plane between two points (x0, y0) and (x1, y1) is given by the formula</p><p><img src="https://i.loli.net/2019/08/09/4XuphOamQiYGUxL.png" alt="295dd04b27b7b5637a67ede5b392f213.png"><br>Most people also know that distance between two points (x0, y0, z0) e (x1, y1, z1) in 3D space is given by the formula</p><p><img src="https://i.loli.net/2019/08/09/hwosDCR4IOptQAg.png" alt="35843a412017eff7d5c7dc53a6ff1d61.png"><br>Both formulas describe the euclidean distance, in the 2 and 3 dimensional case. Your task is, given three points in an n dimensional space, tell if the the closest ones are the foot and the floor or the chain and the flooor, according to euclidean distance.</p><p><code>Input</code><br>The input begins with an integer n, followed by three lines, each with the representation of a point in an n-dimensional space.</p><p>Dimensions confuse us, humans, so you can assume that 1 ≤ n ≤ 105.</p><p>The second line represents the coordinates of the floor, and contains n integers a1, …, an.</p><p>The third line represents the coordinates of the foot of the main character, and contains n integers b1, …, bn.</p><p>The fourth line represents the coordinates of the chain, and contains n integers c1, …, cn.</p><p>The movie theather is not arbitrarily large, so you can assume that the absolute value of these coordinates are not greater than 104.</p><p><code>Output</code><br>Print who wins the argument, that is, print “Yan” if the distance between the floor and the foot is not greater than the distance between the floor and the chain, or “MaratonIME” otherwise.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">Output</span><br><span class="line">Yan</span><br><span class="line">Input</span><br><span class="line">4</span><br><span class="line">0 0 0 0</span><br><span class="line">2 2 2 2</span><br><span class="line">1 1 1 1</span><br><span class="line">Output</span><br><span class="line">MaratonIME</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e4;</span><br><span class="line">const int maxx = 1e6;</span><br><span class="line"></span><br><span class="line">int a[4][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt;= 3; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">double ans1 = 0, ans2 = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">ans2 += pow(a[3][i] - a[1][i], 2);</span><br><span class="line">ans1 += pow(a[2][i] - a[1][i], 2);</span><br><span class="line">&#125;</span><br><span class="line">if(sqrt(ans1) &lt;= sqrt(ans2)) puts(&quot;Yan&quot;);</span><br><span class="line">else puts(&quot;MaratonIME&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-goes-to-a-japanese-restaurant"><a href="#MaratonIME-goes-to-a-japanese-restaurant" class="headerlink" title="MaratonIME goes to a japanese restaurant"></a>MaratonIME goes to a japanese restaurant</h2><p>Description:<br>Matsu?<br>Member, MaratonIME’s<br>Nathan and Yan are very dedicated programmers. They apply their knowledge in algorithms in problems beyond the programming competitions themselves, optimizing even the most trivial every day things.</p><p>Some question if they aren’t just crazy, and if it wouldn’t be better to just do what has to be done.</p><p>Anyhow, eventually some conflicts happen when their approaches differ about what has to be done. That always happens when they decide to go to japanese restaurants.</p><p>Everybody knows that the objective in an all-you-can eat it to try to eat many distinct kinds of food. Nathan and Yan differ in opinions on how to achieve that. Both competitors, when sitting to eat an asian delicacy, eat until nothing is left on their plates.</p><p>The difference is that Yan, respecting the wisdom of the nipponic masters, eats in the order the food arrives, whereas Nathan claims that the food is better the latter it arrives, to spare the most expensive ingredients, and so asks that his plates come in inverted order.</p><p>Given the default order the dishes will arrive and the time Nathan and Yan will stay at the restaurant, determine who is going to eat the most different kinds of food, or if both ate the same number of different kinds of food, given that Yan eats the food in order and Nathan in inverted order.</p><p><code>Input</code><br>The first line of input has two integers: 0 &lt; n ≤ 105, how many plates will be served and 0 &lt; T ≤ 106, how long (in minutes) Yan and Nathan will stay at the restaurant.</p><p>In the following line, n integers 0 &lt; ti ≤ 103, ti is how long it takes to eat the i-th dish (in minutes).</p><p>The restaurants are very well administrated, so you can assume that when one of the competitors finishes his dish, the following dish is already on the table.</p><p><code>Output</code><br>If Yan is going to taste more dishes than Nathan, print “Yan”. If Nathan is going to taste more dishes than Yan, print “Nathan”. Otherwise, if we have a tie, print “Empate”.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">10 45</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Output</span><br><span class="line">Yan</span><br><span class="line">Input</span><br><span class="line">10 45</span><br><span class="line">10 2 3 4 5 6 7 8 9 1</span><br><span class="line">Output</span><br><span class="line">Nathan</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int a[maxx];</span><br><span class="line">int b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, t;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;t))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">memset(b, 0, sizeof b);</span><br><span class="line">int sum = 0;</span><br><span class="line">int m = n;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum += a[i];</span><br><span class="line">b[m --] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">int ans1 = 0, ans2 = 0;</span><br><span class="line">int t1, t2;</span><br><span class="line">t1 = t2 = t;</span><br><span class="line">if(sum &gt;= t)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; t1 &gt;= 0; i ++)</span><br><span class="line">&#123;</span><br><span class="line">t1 -= a[i];</span><br><span class="line">ans1 ++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; t2 &gt;= 0; i ++)</span><br><span class="line">&#123;</span><br><span class="line">t2 -= b[i];</span><br><span class="line">ans2 ++;</span><br><span class="line">&#125;</span><br><span class="line">if(ans1 &gt; ans2) puts(&quot;Yan&quot;);</span><br><span class="line">else if(ans1 &lt; ans2) puts(&quot;Nathan&quot;);</span><br><span class="line">else puts(&quot;Empate&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else puts(&quot;Empate&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-goes-to-the-japanese-restaurant-again"><a href="#MaratonIME-goes-to-the-japanese-restaurant-again" class="headerlink" title="MaratonIME goes to the japanese restaurant (again)"></a>MaratonIME goes to the japanese restaurant (again)</h2><p>Description:<br>Nakato?<br>from MaratonIME, Members<br>After a long day of hard training, MaratonIME (マラトニメ) members decided to go to a Japanese restaurant. Yeah, we love Japanese food.</p><p>After a lot of sushi boats, when everyone was more than satisfied, they asked the sushi-man Sussushi (ススシ) for the last boat. Sussushi felt challenged and answered:</p><p>– You want one more boat? You shall have one more boat…</p><p>The sushi boat that he brought was the biggest that any contestant had ever seen. Some contestants even dare saying that was the biggest sushi boat that ever existed, exceeding the previous limit of 105 sushis made by the suhiwoman Gioza (ジョザ) in 742, in a festival for the king that year, Carlos-sama (カーロス様).</p><p>Besides that the contestants accepted the challenge, and together they managed to eat all the sushis. After that, the contestants we’re so full that they couldn’t touch each other. They couldn’t even think about programming problems. Help them find what pair of friends are touching themselves, so they can move away from each other.</p><p>The contestant are represented as circles in plane, and two contestants touch each other if the circles touch each other. It’s guaranteed that the intersection area of any two circles is null.</p><p><code>Input</code><br>In the first line there is a single integer, n indicating the number of contestants (2 ≤ n ≤ 1000).</p><p>Each one of the next n lines has 3 integers xi, yi e ri, the (i + 1)-th line describes the ith contestant. (xi, yi) are the coordinates of the center of the circle, and ri is the radius. ( - 104 ≤ xi, yi ≤ 104, 1 ≤ ri ≤ 2·104)</p><p>It is guaranteed that the intersection area of any two circles is null.</p><p><code>Output</code><br>For each pair of circles that touch each other, print in one line the indexes of these circles. The collisions can be printed in any order, the indexes of both circles can also be printed in any order.</p><p>Don’t print the collisions more than once, that means, if i intersects with j, print i j or j i, but not both.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">3</span><br><span class="line">0 0 2</span><br><span class="line">5 0 3</span><br><span class="line">10 10 1</span><br><span class="line">Output</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int a[maxx], b[maxx], c[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = i + 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">x = pow(a[i] - a[j], 2);</span><br><span class="line">y = pow(b[i] - b[j], 2);</span><br><span class="line">z = pow(c[i] + c[j], 2);</span><br><span class="line">if(x + y &lt;= z)</span><br><span class="line">cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-goes-to-the-karaoke"><a href="#MaratonIME-goes-to-the-karaoke" class="headerlink" title="MaratonIME goes to the karaoke"></a>MaratonIME goes to the karaoke</h2><p>Description:<br>♬ Hit me, lock me up, do anything with me, … ♬<br>and Marrone, Bruno<br>After thousands of years repeating the title of this problem statement, always with an excited and inviting tone, Nathan finally persuaded his colleagues to go to the karaoke. He is feeling radiant with this achievement.</p><p>But there is a problem. After so much time trying to make his friends go to the karaoke, Nathan is afraid of embarrassing himself when he goes to sing the following classics of Brazilian music:</p><p>Waitress – Reginaldo Rossi<br>Blue Nightclub – Joaquim and Manuel<br>Paper Heart – Sérgio Kings<br>Love Bubble – Fagner<br>You did not teach me to forget – Fernando Mendes<br>To avoid the humiliation, and to not discourage his fellows in future hang outs at the karaoke, Nathan decided to print all the song’s ciphers that are available in the karaoke, to check while he sings. However, this resulted in a colossal amount of paper, that he is not able to carry.</p><p>But the perseverance and ingenuity of an envious programmer is not something you should underestimate.</p><p>Nathan realized that, after all, there were only 7 musical notes. The specialists in this matter used to represent this notes with the letters A, B, C, D, E, F and G. Even more, it’s common that the same note appears several times in sequence. He decided then, to compress the songs, changing every occurrence of repeated notes with the note followed by how many times it occurs.</p><p>For instance, given the sequence</p><p>[(A,A,A,B,B,B,C,G,G,G,G,G,G,G,G,G,G,G)] the compressed version is [A3B3C1G11]</p><p>Unfortunately, Nathan also needs to pack his floral suit and to comb his beard – two homeric jobs – and he is out of time to compress the notes. Help him to not embarrass himself by writing a program that can solve this task.</p><p><code>Input</code><br>Each input consist of a single line, a sequence of caracteres S such as |S| ≤ 105, formed only by the letters A, B, C, D, E, F and G.</p><p><code>Output</code><br>For each input, print in a single line, such as each sequence of similar notes are replaced by the note that occurs and how many times it occurs, as showed in the example.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Examples</span><br><span class="line">Input</span><br><span class="line">ABBGA</span><br><span class="line">Output</span><br><span class="line">A1B2G1A1</span><br><span class="line">Input</span><br><span class="line">AAABBBCGGGGGGGGGGG</span><br><span class="line">Output</span><br><span class="line">A3B3C1G11</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">map&lt;char, int&gt; mp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">while(cin &gt;&gt; str)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; str.size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">mp[str[i]] ++;</span><br><span class="line">if(str[i + 1] != str[i])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c%d&quot;,str[i], mp[str[i]]);</span><br><span class="line">mp[str[i]] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-goes-karting"><a href="#MaratonIME-goes-karting" class="headerlink" title="MaratonIME goes karting"></a>MaratonIME goes karting</h2><p>Description:<br>Yan, it’s red!!!<br>desperate, Passengers<br>Once after a contest, the competitive programmers were sad because of bad results. Seeing the situation, Renzo, MaratonIME’s coach, suggested they should do something fun to relax. After a big discussion, they decided to go karting. Looking for a place that was viable to all students, they found Kartforces, a kart track near Cidade Universitária. However, the track was too small and only fitted two racers by race. As passionate competitive programmers, they organised a fair tournament where everyone raced against everyone, two by two, only once. In each race, the winner got one point on the scoreboard. Draws were allowed and no one scored in this case. The winner was the biggest scorer. There were N competitive programmers present and:</p><p>Each competitive programmer had a skill hi.<br>If hi &gt; hj where 1 ≤ i, j ≤ N and i ≠ j, then the competitive programmer i won the race against j.<br>You had access to the skills of all competitive programmers and now asks who was the champion.</p><p><code>Input</code><br>The first line consists on a single integer N, the number of competitive programmers. The second line contains N integers hi, the skill of the i - th competitive programmer.</p><p>1 ≤ N ≤ 105<br>0 ≤ hi ≤ 109<br><code>Output</code><br>The output consists in a single integer i, the champion competitive programmer. If it’s not possible to determine the champion, print  - 1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">3</span><br><span class="line">2 4 6</span><br><span class="line">Output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const ll mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">ll a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int ans, winner;</span><br><span class="line">int cnt;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">winner = -1;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">if(a[i] &gt; winner)</span><br><span class="line">&#123;</span><br><span class="line">winner = a[i];</span><br><span class="line">ans = i;</span><br><span class="line">cnt = 1;</span><br><span class="line">&#125;</span><br><span class="line">else if(a[i] == winner)</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">else continue;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt &gt;= 2) puts(&quot;-1&quot;);</span><br><span class="line">else printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="MaratonIME-returns-home"><a href="#MaratonIME-returns-home" class="headerlink" title="MaratonIME returns home"></a>MaratonIME returns home</h2><p>Description:<br>♬ Renzo, they’re calling. Renzo, pick up the phone ♬<br>Ringtones, Top<br>Popular among the most traditional coders, the Summer Camp is famous for its fancy parties. After each party all attendees must return to their homes, but the way back home is not always easy: mildly drunk coders walk weird and often find or lose money along the way. However, MaratonIME always has a sober member in the group, who assures no one will lose money, except when they are robbed.</p><p>On its way back MaratonIME knows that they can call their coach, Renzo, who will pick them up immediately. Instead of doing that right after the party, they want to know what is the maximum amount of money they can carry back to their homes.</p><p>Your task is to write a program that solves this problem. Consider the following facts:</p><p>The city map can be seen as an N by M grid;<br>Members of MaratonIME are initially at the top left corner, and start walking right, carrying no money;<br>Whenever they reach the end of a row, they walk to the row below and start walking in the opposite direction (if they were walking right, they walk left the next row, and vice-versa);<br>They cannot go past the last row;<br>Whenever they meet a burglar, they lose all their money;<br>They can call Renzo at anytime, and he will pick them up instantly.<br><code>Input</code><br>The first line of the input contains two integers N and M (1 ≤ N, M ≤ 103), respectively, the number of rows and columns of the grid. Then follows N lines, each containing M characters, representing the city map. Each cell of the city map can be either:</p><p>, meaning there is nothing at this cell of the grid;<br>, meaning there is a coin worth 1 unit of money at this cell;<br>, meaning there is a burglar at that cell.<br><code>Output</code><br>The output must contain a single integer: the maximum amount of money MaratonIME can carry back home.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line">Input</span><br><span class="line">3 3</span><br><span class="line">__.</span><br><span class="line">_._</span><br><span class="line">L._</span><br><span class="line">Output</span><br><span class="line">2</span><br><span class="line">Note</span><br><span class="line">In the example above, MaratonIME follows the following path: (1, 1)  (1, 2)  (1, 3)  (2, 3)  (2, 2)  (2, 1)  (3, 1)  (3, 2)  (3, 3). When they reach (2, 2) or (2, 1) they will have 2 coins, and that is the highest value they can get before calling Renzo.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int n, m;</span><br><span class="line">char s[1010][1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;m);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s[i];</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0, tmp = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(i % 2 == 0)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j] == &apos;L&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans = max(ans, tmp);</span><br><span class="line">tmp = 0;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[i][j] == &apos;.&apos;)</span><br><span class="line">tmp ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int j = m - 1; j &gt;= 0; j --)</span><br><span class="line">&#123;</span><br><span class="line">if(s[i][j] == &apos;L&apos;)</span><br><span class="line">&#123;</span><br><span class="line">ans = max(ans, tmp);</span><br><span class="line">tmp = 0;</span><br><span class="line">&#125;</span><br><span class="line">else if(s[i][j] == &apos;.&apos;)</span><br><span class="line">tmp ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day21&quot;&gt;&lt;a href=&quot;#Day21&quot; class=&quot;headerlink&quot; title=&quot;Day21&quot;&gt;&lt;/a&gt;Day21&lt;/h1&gt;&lt;p&gt;&lt;code&gt;比赛题解&lt;/code&gt;&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day21</title>
    <link href="http://yoursite.com/2019/08/09/Day21/"/>
    <id>http://yoursite.com/2019/08/09/Day21/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-09T12:48:51.910Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:11:59 GMT+0800 (GMT+08:00) --><h1 id="Day21"><a href="#Day21" class="headerlink" title="Day21"></a>Day21</h1><p>今天讲的是强连通量<br><code>中间插入了一场比赛</code><br><code>补题</code><br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p><p><a href="https://vjudge.net/contest/318470" target="_blank" rel="noopener">比赛链接</a><br><a href>题解</a></p><h2 id="Equivalent-Sets"><a href="#Equivalent-Sets" class="headerlink" title="Equivalent Sets"></a>Equivalent Sets</h2><p>Description:<br>To prove two sets A and B are equivalent, we can first prove A is a subset of B, and then prove B is a subset of A, so finally we got that these two sets are equivalent.<br>You are to prove N sets are equivalent, using the method above: in each step you can prove a set X is a subset of another set Y, and there are also some sets that are already proven to be subsets of some other sets.<br>Now you want to know the minimum steps needed to get the problem proved.<br><code>Input</code><br>The input file contains multiple test cases, in each case, the first line contains two integers N &lt;= 20000 and M &lt;= 50000.<br>Next M lines, each line contains two integers X, Y, means set X in a subset of set Y.<br><code>Output</code><br>For each case, output a single integer: the minimum steps needed.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 0</span><br><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">Case 2: First prove set 2 is a subset of set 1 and then prove set 3 is a subset of set 1.</span><br></pre></td></tr></table></figure><p></p><blockquote><p>题解:对于这样一个题目,很容易就可以把子集关系转换成有向图的一条有向边,那么题目就转换为求最少增加多少条有向边使得该图成为一个强连通图.对于一个图来说,他内部可能存在许多强连通分量,对于这些强连通分量之间,他们是不需要再进行建边了,我们可以将一个个强连通分量缩成一个个点,那么我们只需要让这些缩点后的图(有向无环图)是一个强连通图即可.<br>这里用到一点贪心的思想:对于一个有向无环图,若有zin个入度为0的点,我们最多只需要增加zin条有向边,若是有zout个出度为0的点,我只需要增加zout条有向边,那么对于一个有向无环图要成为一个强连通图,我们最少只需要增加max(zin,zout)条有向边即可.<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const int maxn = 20005;</span><br><span class="line">struct Tarjan &#123;</span><br><span class="line">int n;                       //点的个数</span><br><span class="line"> </span><br><span class="line">vector&lt;int&gt;e[maxn];          //邻接表存图</span><br><span class="line">int DFN[maxn], LOW[maxn];</span><br><span class="line">int index;                   //编辑计数器</span><br><span class="line"> </span><br><span class="line">int stk[maxn];               //栈</span><br><span class="line">bool ins[maxn];              //记录点是否在栈中</span><br><span class="line">int top;</span><br><span class="line"> </span><br><span class="line">vector&lt;vector&lt;int&gt; &gt;ans;    </span><br><span class="line">void init(int N) &#123;           //初始化</span><br><span class="line">n = N;</span><br><span class="line"> </span><br><span class="line">ans.clear();</span><br><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">e[i].clear();</span><br><span class="line">top = 0;</span><br><span class="line">index = 0;</span><br><span class="line"> </span><br><span class="line">memset(DFN, -1, sizeof(DFN));</span><br><span class="line">memset(ins, 0, sizeof(ins));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void add_edge(int u, int v) &#123;//添加边</span><br><span class="line">e[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void dfs(int u) &#123;            //从u点开始搜索</span><br><span class="line">DFN[u] = LOW[u] = ++index;</span><br><span class="line">stk[top++] = u;          //为了记录这个连通分量中的节点</span><br><span class="line">ins[u] = true;</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; e[u].size(); i++) &#123;</span><br><span class="line">int v = e[u][i];</span><br><span class="line">if (DFN[v] == -1) &#123;</span><br><span class="line">dfs(v);</span><br><span class="line">LOW[u] = min(LOW[u], LOW[v]);</span><br><span class="line">&#125;</span><br><span class="line">else if (ins[v])</span><br><span class="line">LOW[u] = min(LOW[u], DFN[v]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (DFN[u] == LOW[u]) &#123;  //当DFN==LOW时说明stk中点可以形成一个强连通分量</span><br><span class="line">vector&lt;int&gt;q;</span><br><span class="line">int v = stk[top - 1];</span><br><span class="line"> </span><br><span class="line">while (u != v) &#123;</span><br><span class="line">q.push_back(v);</span><br><span class="line">ins[v] = false;</span><br><span class="line">top--;</span><br><span class="line">v = stk[top - 1];</span><br><span class="line">&#125;</span><br><span class="line">q.push_back(u);</span><br><span class="line">ins[u] = false;</span><br><span class="line">top--;</span><br><span class="line"> </span><br><span class="line">ans.push_back(q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void solve() &#123;                 //运行该函数后产生答案</span><br><span class="line">for (int i = 1; i &lt;= n; i++)</span><br><span class="line">if (DFN[i] == -1) dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;T;</span><br><span class="line">int num[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;int&gt; e[maxn];               //存强连通缩点后的得到的新图</span><br><span class="line">int n, m;</span><br><span class="line">int main()&#123;</span><br><span class="line">while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123;</span><br><span class="line">int u, v;</span><br><span class="line">T.init(n);                 //初始化</span><br><span class="line">while(m--)&#123;                //建有向图</span><br><span class="line">scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">T.add_edge(v, u);      //这里是u-&gt;v</span><br><span class="line">&#125;</span><br><span class="line">T.solve();                 //获得该有向图的所有强连通分量</span><br><span class="line"> </span><br><span class="line">for (int i = 1; i&lt;=n; i++) //清空新图</span><br><span class="line">   e[i].clear();</span><br><span class="line">                           //缩点</span><br><span class="line">for (int i = 0; i&lt; T.ans.size(); i++)</span><br><span class="line">for (int j = 0; j&lt; T.ans[i].size(); j++)</span><br><span class="line">        num[T.ans[i][j]] = i + 1;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">for(int i=1;i&lt;=n;i++)      //输出缩点情况</span><br><span class="line">    printf(&quot;%d:%d\n&quot;,i,num[i]);</span><br><span class="line"> */</span><br><span class="line">                        </span><br><span class="line">for (int i = 1; i&lt;=n; i++) //建新有向无环图</span><br><span class="line">for (int j = 0; j &lt; T.e[i].size(); j++) &#123;</span><br><span class="line">if (num[i] == num[T.e[i][j]]) continue;</span><br><span class="line">e[num[i]].push_back(num[T.e[i][j]]);</span><br><span class="line">//printf(&quot;%d-&gt;%d\n&quot;,num[i],num[T.e[i][j]]);输出图</span><br><span class="line">&#125;</span><br><span class="line">n = T.ans.size();          //新图的点数</span><br><span class="line"> </span><br><span class="line">//以上为Tarjan算法的强连通缩点操作,得到新的有向无环图为e[],点数为n</span><br><span class="line"> </span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">int zin = 0, zout = 0;     //分别为入度为0的点数和出度为0的点数</span><br><span class="line">for (int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">if (e[i].size() == 0)zout++;</span><br><span class="line">for (int j = 0; j &lt; e[i].size(); j++)</span><br><span class="line">vis[e[i][j]] = true;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">   if (!vis[i])zin++;</span><br><span class="line">if (n != 1)printf(&quot;%d\n&quot;, max(zin, zout));</span><br><span class="line">else printf(&quot;0\n&quot;);        //若是只有一点点需要特判结果为0,否则输出1</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:11:59 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day21&quot;&gt;&lt;a href=&quot;#Day21&quot; class=&quot;headerlink&quot; title=&quot;Day21&quot;&gt;&lt;/a&gt;Day21&lt;/h1&gt;&lt;p&gt;今天讲的是强连通量&lt;br&gt;&lt;code&gt;中间插入了一场比赛&lt;/code&gt;&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day20</title>
    <link href="http://yoursite.com/2019/08/08/Day20/"/>
    <id>http://yoursite.com/2019/08/08/Day20/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T15:26:54.758Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day20"><a href="#Day20" class="headerlink" title="Day20"></a>Day20</h1><p>今天讲的是LCA(最近公共祖先)<br><code>补题</code><br><a id="more"></a></p><blockquote><p>提醒自己一下，因为今天有事没有写完这些题目，所以大部分的题解和代码都是在网上找到的，希望以后自己可以把这部分题补上</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近公共祖先简称LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。<br>为了方便，我们记某点集S = v1, v2, …, vn 的最近公共祖先为LCA (v1, v2, …, vn) 或LCA (S)</p><h2 id="解决算法"><a href="#解决算法" class="headerlink" title="解决算法"></a>解决算法</h2><p>朴素算法<br>倍增算法<br>Tarjan 算法<br>转换成 RMQ 问题求解<br>树链剖分<br>动态树</p><blockquote><p>虽然算法多，但是我现在只学了前三个算法</p></blockquote><p><a href="https://blog.csdn.net/JarjingX/article/details/8180560" target="_blank" rel="noopener">生动的解释</a></p><p><a href="https://blog.csdn.net/qq_28954601/article/details/76856187" target="_blank" rel="noopener">详情链接</a></p><h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><p>我们首先预处理出来所有节点所在的深度，对于需要查询的两点<br>u, v，我们假设深度较深的点为 u，将 u 上移至与 v 相同深度的<br>位置，然后同时上移节点 u, v，直至两节点相遇，相遇的点即为<br>LCA(u, v)<br>最坏复杂度 O (N)</p><h2 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h2><p>倍增算法求 LCA 就是利用倍增法对朴素算法的一个优化，预处<br>理时间复杂度 O(nlogn)<br>可以将查询的时间复杂度降到 O (logN)<br>总的时间复杂度：O(nlogn + qlogn)</p><h2 id="加一个-假-模板"><a href="#加一个-假-模板" class="headerlink" title="加一个(假)模板"></a>加一个(假)模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(2)//O2优化 </span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1000000;</span><br><span class="line">long long bit[N];</span><br><span class="line">int depth[N],f[N][30];</span><br><span class="line">vector&lt;int&gt; G[N];</span><br><span class="line">int Scan()</span><br><span class="line">&#123;   //  输入外挂  </span><br><span class="line">    int res = 0, flag = 0;  </span><br><span class="line">    char ch;  </span><br><span class="line">    if ((ch = getchar()) == &apos;-&apos;) </span><br><span class="line">    &#123;   </span><br><span class="line">        flag = 1;  </span><br><span class="line">    &#125;    </span><br><span class="line">    else if(ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;) </span><br><span class="line">    &#123;</span><br><span class="line">        res = ch - &apos;0&apos;; </span><br><span class="line">    &#125;</span><br><span class="line">    while ((ch = getchar()) &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;)  </span><br><span class="line">    &#123;</span><br><span class="line">        res = res * 10 + (ch - &apos;0&apos;);  </span><br><span class="line">    &#125;</span><br><span class="line">    return flag ? -res : res;  </span><br><span class="line">&#125;  </span><br><span class="line">void init()&#123;</span><br><span class="line">bit[0]=1;</span><br><span class="line">for(int i=1;i&lt;=29;i++) bit[i]=(bit[i-1]*2);</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int par)&#123;</span><br><span class="line">depth[u]=depth[par]+1;</span><br><span class="line">f[u][0]=par;</span><br><span class="line">for(int i=1;i&lt;=29;i++) f[u][i]=f[f[u][i-1]][i-1];</span><br><span class="line">for(int i=0;i&lt;(int)G[u].size();i++)&#123;</span><br><span class="line">int v=G[u][i];</span><br><span class="line">if(v==par) continue;</span><br><span class="line">dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int lca(int a,int b)&#123;</span><br><span class="line">if(depth[a]&lt;depth[b]) swap(a,b);</span><br><span class="line">int dif=depth[a]-depth[b];</span><br><span class="line">for(int i=29;i&gt;=0;i--)&#123;</span><br><span class="line">if(dif&gt;=bit[i])&#123;</span><br><span class="line">a=f[a][i];</span><br><span class="line">dif-=bit[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(a==b) return a;</span><br><span class="line">for(int i=29;i&gt;=0;i--)&#123;</span><br><span class="line">if(depth[a]&gt;=bit[i]&amp;&amp;f[a][i]!=f[b][i])&#123;</span><br><span class="line">a=f[a][i];b=f[b][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[a][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line">int n,m,s;</span><br><span class="line">n=Scan();m=Scan();s=Scan();</span><br><span class="line">int u,v;</span><br><span class="line">for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">u=Scan();v=Scan();</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">G[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">dfs(s,0);</span><br><span class="line">while(m--)&#123;</span><br><span class="line">u=Scan();v=Scan();</span><br><span class="line">printf(&quot;%d\n&quot;,lca(u,v));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h2><p>Tarjan 算法是一种常见的用于解决 LCA 问题的离线算法，它结<br>合了深度优先搜索与并查集，预处理时间复杂度 O(nlogn), 每次<br>查询时间复杂度 O(1)，总时间复杂度是 O(nlogn + q)。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>若两个结点 u, v 分别分布于某节点 T 的左右子树，那么此节点 t<br>即为 u 和 v 的最近公共祖先。<br>更进一步，考虑到一个节点自己就是 LCA 的情况，得知：<br>若某结点 T 是两结点 u, v 的祖先之一，且这两结点并不分布于<br>该结点 t 同一棵子树中，而是分别在结点 T 的左子树、右子树<br>中，那么该结点 T 即为两结点 u, v 的最近公共祖先</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>任选一个节点为根节点，从根节点开始<br>遍历该点 u 的所有子节点 v 并标记 v 已经被访问过<br>若 v 还有子节点，返回第二步，否则下一步<br>合并 v 到 u 所在集合<br>寻找与当前点 u 有询问关系的点 e<br>若 e 已经被访问过，则可以确定 u, e 的最近公共祖先为 e<br>被合并到的父亲节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//并查集部分 </span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x != f[x])</span><br><span class="line">&#123;</span><br><span class="line">f[x] = find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">return f[x];</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int dx = f[x], dy = f[y];</span><br><span class="line">if(dx != dy)</span><br><span class="line">f[dy] = f[dx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//存储查询关系</span><br><span class="line">struct Query</span><br><span class="line">&#123;</span><br><span class="line">int q, next;</span><br><span class="line">int index;</span><br><span class="line">&#125;Q[maxx * 2];</span><br><span class="line">int h[maxx];</span><br><span class="line">int tt;</span><br><span class="line">void add_query(int u, int v, int index)</span><br><span class="line">&#123;</span><br><span class="line">Q[tt].q = v;</span><br><span class="line">Q[tt].next = h[u];</span><br><span class="line">Q[tt].index = index;</span><br><span class="line">h[u] = tt ++;</span><br><span class="line">Q[tt].q = u;</span><br><span class="line">Q[tt].next = h[v];</span><br><span class="line">Q[tt].index = index;</span><br><span class="line">h[v] = tt ++;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">//核心代码</span><br><span class="line">void lca(int u)</span><br><span class="line">&#123;</span><br><span class="line">fa[u] = u; vis[u] = 1;</span><br><span class="line">for(int i = head[u]; i != -1; i = edge[i].next)//和顶点u相关的顶点</span><br><span class="line">&#123;</span><br><span class="line">int v = edge[i].to;</span><br><span class="line">if(vis[v]) continue;</span><br><span class="line">lca(v);</span><br><span class="line">join(u, v);//将u的左右孩子的祖先设为u</span><br><span class="line">fa[find(u)] = u; </span><br><span class="line">&#125; </span><br><span class="line">//看输入的查询里面有没有和u节点相关的</span><br><span class="line">for(int i = h[u]; i != -1; i = Q[i].next)</span><br><span class="line">&#123;</span><br><span class="line">int v = Q[i].q;</span><br><span class="line">if(vis[v])</span><br><span class="line">ans[Q[i].index] = fa[find(v)];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://vjudge.net/contest/318221#overview" target="_blank" rel="noopener">OJ链接</a></p><h2 id="Nearest-Common-Ancestors"><a href="#Nearest-Common-Ancestors" class="headerlink" title="Nearest Common Ancestors"></a>Nearest Common Ancestors</h2><p>Description:<br>A rooted tree is a well-known data structure in computer science and engineering. An example is shown below:<br><img src="https://i.loli.net/2019/08/08/qKiOSD1WVdbngTj.gif" alt="a4cf40017a91cfbd4f81b13b267ec9ee.png"><br>In the figure, each node is labeled with an integer from {1, 2,…,16}. Node 8 is the root of the tree. Node x is an ancestor of node y if node x is in the path between the root and node y. For example, node 4 is an ancestor of node 16. Node 10 is also an ancestor of node 16. As a matter of fact, nodes 8, 4, 10, and 16 are the ancestors of node 16. Remember that a node is an ancestor of itself. Nodes 8, 4, 6, and 7 are the ancestors of node 7. A node x is called a common ancestor of two different nodes y and z if node x is an ancestor of node y and an ancestor of node z. Thus, nodes 8 and 4 are the common ancestors of nodes 16 and 7. A node x is called the nearest common ancestor of nodes y and z if x is a common ancestor of y and z and nearest to y and z among their common ancestors. Hence, the nearest common ancestor of nodes 16 and 7 is node 4. Node 4 is nearer to nodes 16 and 7 than node 8 is.</p><p>For other examples, the nearest common ancestor of nodes 2 and 3 is node 10, the nearest common ancestor of nodes 6 and 13 is node 8, and the nearest common ancestor of nodes 4 and 12 is node 4. In the last example, if y is an ancestor of z, then the nearest common ancestor of y and z is y.</p><p>Write a program that finds the nearest common ancestor of two distinct nodes in a tree.</p><p><code>Input</code><br>The input consists of T test cases. The number of test cases (T) is given in the first line of the input file. Each test case starts with a line containing an integer N , the number of nodes in a tree, 2&lt;=N&lt;=10,000. The nodes are labeled with integers 1, 2,…, N. Each of the next N -1 lines contains a pair of integers that represent an edge –the first integer is the parent node of the second integer. Note that a tree with N nodes has exactly N - 1 edges. The last line of each test case contains two distinct integers whose nearest common ancestor is to be computed.<br><code>Output</code><br>Print exactly one line for each test case. The line should contain the integer that is the nearest common ancestor.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">16</span><br><span class="line">1 14</span><br><span class="line">8 5</span><br><span class="line">10 16</span><br><span class="line">5 9</span><br><span class="line">4 6</span><br><span class="line">8 4</span><br><span class="line">4 10</span><br><span class="line">1 13</span><br><span class="line">6 15</span><br><span class="line">10 11</span><br><span class="line">6 7</span><br><span class="line">10 2</span><br><span class="line">16 3</span><br><span class="line">8 1</span><br><span class="line">16 12</span><br><span class="line">16 7</span><br><span class="line">5</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 1</span><br><span class="line">1 5</span><br><span class="line">3 5</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">ll bits[maxx];//存节点 </span><br><span class="line">int f[maxx][30];//存子节点</span><br><span class="line">int depth[maxx];//存储深度</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int in[maxx];</span><br><span class="line">//初始化</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">bits[0] = 1;</span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">bits[i] = bits[i - 1] &lt;&lt; 1;</span><br><span class="line">&#125;</span><br><span class="line">//预处理</span><br><span class="line">void dfs(int u, int par)</span><br><span class="line">&#123;</span><br><span class="line">depth[u] = depth[par] + 1;</span><br><span class="line">f[u][0] = par;</span><br><span class="line">//倍增 </span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">f[u][i] = f[f[u][i - 1]][i - 1];</span><br><span class="line">for(int i = 0; i &lt; v[u].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(v[u][i] == par) continue;</span><br><span class="line">dfs(v[u][i], u);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">//lca</span><br><span class="line">int lca(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &lt; depth[b])</span><br><span class="line">swap(a, b);</span><br><span class="line">int dis = depth[a] - depth[b];</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(dis &gt;= bits[i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">dis -= bits[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(a == b)</span><br><span class="line">return a;</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &gt;= bits[i] &amp;&amp; f[a][i] != f[b][i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">b = f[b][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[a][0];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int t, n, x, y;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i = 1; i &lt;= n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">v[y].push_back(x);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">int root;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!in[i])</span><br><span class="line">&#123;</span><br><span class="line">root = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(root, 0);</span><br><span class="line">printf(&quot;%d\n&quot;,lca(x, y));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Distance-Queries"><a href="#Distance-Queries" class="headerlink" title="Distance Queries"></a>Distance Queries</h2><p>Description:<br>Farmer John’s cows refused to run in his marathon since he chose a path much too long for their leisurely lifestyle. He therefore wants to find a path of a more reasonable length. The input to this problem consists of the same input as in “Navigation Nightmare”,followed by a line containing a single integer K, followed by K “distance queries”. Each distance query is a line of input containing two integers, giving the numbers of two farms between which FJ is interested in computing distance (measured in the length of the roads along the path between the two farms). Please answer FJ’s distance queries as quickly as possible!<br><code>Input</code></p><ul><li><p>Lines 1..1+M: Same format as “Navigation Nightmare”</p></li><li><p>Line 2+M: A single integer, K. 1 &lt;= K &lt;= 10,000</p></li><li><p>Lines 3+M..2+M+K: Each line corresponds to a distance query and contains the indices of two farms.<br><code>Output</code></p></li><li>Lines 1..K: For each distance query, output on a single line an integer giving the appropriate distance.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">7 6</span><br><span class="line">1 6 13 E</span><br><span class="line">6 3 9 E</span><br><span class="line">3 5 7 S</span><br><span class="line">4 1 3 N</span><br><span class="line">2 4 20 W</span><br><span class="line">4 7 2 S</span><br><span class="line">3</span><br><span class="line">1 6</span><br><span class="line">1 4</span><br><span class="line">2 6</span><br><span class="line">Sample Output</span><br><span class="line">13</span><br><span class="line">3</span><br><span class="line">36</span><br><span class="line">Hint</span><br><span class="line">Farms 2 and 6 are 20+3+13=36 apart.</span><br></pre></td></tr></table></figure></li></ul><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#pragma GCC optimize(2)</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">ll bits[maxx];//存节点 </span><br><span class="line">int f[maxx][30];//存子节点</span><br><span class="line">int depth[maxx];//存储深度</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; v[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">//初始化</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">bits[0] = 1;</span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">bits[i] = bits[i - 1] &lt;&lt; 1;</span><br><span class="line">&#125;</span><br><span class="line">//预处理</span><br><span class="line">void dfs(int u, int par)</span><br><span class="line">&#123;</span><br><span class="line">depth[u] = depth[par] + 1;</span><br><span class="line"></span><br><span class="line">f[u][0] = par;</span><br><span class="line">//倍增 </span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">f[u][i] = f[f[u][i - 1]][i - 1];</span><br><span class="line">for(int i = 0; i &lt; v[u].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(v[u][i].first == par) continue;</span><br><span class="line">dis[v[u][i].first] = dis[u] + v[u][i].second;</span><br><span class="line">dfs(v[u][i].first, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">//lca</span><br><span class="line">int lca(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &lt; depth[b])</span><br><span class="line">swap(a, b);</span><br><span class="line">int dis = depth[a] - depth[b];</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(dis &gt;= bits[i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">dis -= bits[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(a == b)</span><br><span class="line">return a;</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &gt;= bits[i] &amp;&amp; f[a][i] != f[b][i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">b = f[b][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[a][0];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int t, n, m, k, x, y;</span><br><span class="line">char z[10];</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 1; i &lt;= n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d %d %s&quot;,&amp;x, &amp;y, &amp;k, &amp;z);</span><br><span class="line">v[x].push_back(make_pair(y, k));</span><br><span class="line">v[y].push_back(make_pair(x, k));</span><br><span class="line">&#125;</span><br><span class="line">dfs(1, 0);</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">for(int i = 1; i &lt;= t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">int ans = lca(x, y), cnt = 0;</span><br><span class="line">cnt = dis[x] + dis[y] - 2 * dis[ans];</span><br><span class="line">printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Closest-Common-Ancestors"><a href="#Closest-Common-Ancestors" class="headerlink" title="Closest Common Ancestors"></a>Closest Common Ancestors</h2><p>Description:<br>Write a program that takes as input a rooted tree and a list of pairs of vertices. For each pair (u,v) the program determines the closest common ancestor of u and v in the tree. The closest common ancestor of two nodes u and v is the node w that is an ancestor of both u and v and has the greatest depth in the tree. A node can be its own ancestor (for example in Figure 1 the ancestors of node 2 are 2 and 5)</p><p>The data set starts with the tree description, in the form:</p><p>nr_of_vertices<br>vertex:(nr_of_successors) successor1 successor2 … successorn<br>……</p><p>where vertices are represented as integers from 1 to n. The tree description is followed by a list of pairs of vertices, in the form:</p><p>nr_of_pairs<br>(u v) (x y) …</p><p>The input contents several data sets (at least one).</p><p>Note that white-spaces (tabs, spaces and line breaks) can be used freely in the input.</p><p>For each common ancestor the program prints the ancestor and the number of pair for which it is an ancestor. The results are printed on the standard output on separate lines, in to the ascending order of the vertices, in the format: ancestor:times</p><p>For example, for the following tree:<br><img src="https://i.loli.net/2019/08/08/apLKrRtk1wMfDj2.gif" alt="d429f0395ea8a6aaa0d514a98146ee82.png"><br>the program input and output is:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Input</span><br><span class="line"></span><br><span class="line">5</span><br><span class="line">5:(3) 1 4 2</span><br><span class="line">1:(0)</span><br><span class="line">4:(0)</span><br><span class="line">2:(1) 3</span><br><span class="line">3:(0)</span><br><span class="line">6</span><br><span class="line">(1,5) (1,4) (4,2)</span><br><span class="line">(2,3)</span><br><span class="line">(1,3) (4,3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line"></span><br><span class="line">2:1</span><br><span class="line">5:5</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 1e5;</span><br><span class="line">int f[N][30];</span><br><span class="line">int depth[N];</span><br><span class="line">int sum[N];</span><br><span class="line">int in[N];</span><br><span class="line">ll bits[30];</span><br><span class="line">vector&lt;int&gt; v[N];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">bits[0] = 1;</span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">&#123;</span><br><span class="line">bits[i] = bits[i - 1] &lt;&lt; 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">//预处理 </span><br><span class="line">void dfs(int u, int par)</span><br><span class="line">&#123;</span><br><span class="line">depth[u] = depth[par] + 1;</span><br><span class="line">f[u][0] = par;</span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">f[u][i] = f[f[u][i - 1]][i - 1];</span><br><span class="line">for(int i = 0; i &lt; v[u].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">int V = v[u][i];</span><br><span class="line">if(V == par)</span><br><span class="line">continue;</span><br><span class="line">dfs(V, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &lt; depth[b])</span><br><span class="line">swap(a, b);</span><br><span class="line">int dis = depth[a] - depth[b];</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(dis &gt;= bits[i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">dis -= bits[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(a == b) return a;</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &gt;= bits[i] &amp;&amp; f[a][i] != f[b][i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">b = f[b][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[a][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int a, b, n, m;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d:(%d)&quot;,&amp;a,&amp;m);</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b);</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">v[b].push_back(a);</span><br><span class="line">in[b] ++;</span><br><span class="line">&#125;</span><br><span class="line">//getchar();</span><br><span class="line">&#125;</span><br><span class="line">int ans;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!in[i])</span><br><span class="line">&#123;</span><br><span class="line">ans = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">dfs(ans, 0);</span><br><span class="line">int t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">memset(sum, 0, sizeof sum);</span><br><span class="line">for(int i = 0; i &lt; t; i ++)</span><br><span class="line">&#123;</span><br><span class="line">char c;</span><br><span class="line">while(scanf(&quot;%c&quot;,&amp;c) &amp;&amp; c != &apos;(&apos;);</span><br><span class="line">scanf(&quot;%d,%d&quot;,&amp;a, &amp;b);</span><br><span class="line">while(scanf(&quot;%c&quot;,&amp;c) &amp;&amp; c != &apos;)&apos;);</span><br><span class="line">sum[lca(a, b)] ++;</span><br><span class="line">getchar();</span><br><span class="line">&#125; </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(sum[i])</span><br><span class="line">printf(&quot;%d:%d\n&quot;, i, sum[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="How-far-away-？"><a href="#How-far-away-？" class="headerlink" title="How far away ？"></a>How far away ？</h2><p>Description:<br>There are n houses in the village and some bidirectional roads connecting them. Every day peole always like to ask like this “How far is it if I want to go from house A to house B”? Usually it hard to answer. But luckily int this village the answer is always unique, since the roads are built in the way that there is a unique simple path(“simple” means you can’t visit a place twice) between every two houses. Yout task is to answer all these curious people.<br><code>Input</code><br>First line is a single integer T(T&lt;=10), indicating the number of test cases.<br>For each test case,in the first line there are two numbers n(2&lt;=n&lt;=40000) and m (1&lt;=m&lt;=200),the number of houses and the number of queries. The following n-1 lines each consisting three numbers i,j,k, separated bu a single space, meaning that there is a road connecting house i and house j,with length k(0&lt;k&lt;=40000).The houses are labeled from 1 to n.<br>Next m lines each has distinct integers i and j, you areato answer the distance between house i and house j.<br><code>Output</code><br>For each test case,output m lines. Each line represents the answer of the query. Output a bland line after each test case.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 2</span><br><span class="line">1 2 10</span><br><span class="line">3 1 15</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line"></span><br><span class="line">2 2</span><br><span class="line">1 2 100</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">Sample Output</span><br><span class="line">10</span><br><span class="line">25</span><br><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">ll bits[maxx];//存节点 </span><br><span class="line">int f[maxx][30];//存子节点</span><br><span class="line">int depth[maxx];//存储深度</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; v[maxx];</span><br><span class="line">int in[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">//初始化</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">bits[0] = 1;</span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">bits[i] = bits[i - 1] &lt;&lt; 1;</span><br><span class="line">&#125;</span><br><span class="line">//预处理</span><br><span class="line">void dfs(int u, int par)</span><br><span class="line">&#123;</span><br><span class="line">depth[u] = depth[par] + 1;</span><br><span class="line"></span><br><span class="line">f[u][0] = par;</span><br><span class="line">//倍增 </span><br><span class="line">for(int i = 1; i &lt;= 29; i ++)</span><br><span class="line">f[u][i] = f[f[u][i - 1]][i - 1];</span><br><span class="line">for(int i = 0; i &lt; v[u].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(v[u][i].first == par) continue;</span><br><span class="line">dis[v[u][i].first] = dis[u] + v[u][i].second;</span><br><span class="line">dfs(v[u][i].first, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">//lca</span><br><span class="line">int lca(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &lt; depth[b])</span><br><span class="line">swap(a, b);</span><br><span class="line">int dis = depth[a] - depth[b];</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(dis &gt;= bits[i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">dis -= bits[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(a == b)</span><br><span class="line">return a;</span><br><span class="line">for(int i = 29; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">if(depth[a] &gt;= bits[i] &amp;&amp; f[a][i] != f[b][i])</span><br><span class="line">&#123;</span><br><span class="line">a = f[a][i];</span><br><span class="line">b = f[b][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[a][0];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int t, n, m, k, x, y;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;m);</span><br><span class="line">for(int i = 1; i &lt;= n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d %d&quot;,&amp;x, &amp;y, &amp;k);</span><br><span class="line">v[x].push_back(make_pair(y, k));</span><br><span class="line">v[y].push_back(make_pair(x, k));</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">int r;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!in[i])</span><br><span class="line">&#123;</span><br><span class="line">r = i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">dfs(r, 0);</span><br><span class="line">int ans = lca(x, y), cnt = 0;</span><br><span class="line">cnt = dis[x] + dis[y] - 2 * dis[ans];</span><br><span class="line">printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line">if(t != 0) puts(&quot;&quot;);</span><br><span class="line">&#125; </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day20&quot;&gt;&lt;a href=&quot;#Day20&quot; class=&quot;headerlink&quot; title=&quot;Day20&quot;&gt;&lt;/a&gt;Day20&lt;/h1&gt;&lt;p&gt;今天讲的是LCA(最近公共祖先)&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day19</title>
    <link href="http://yoursite.com/2019/08/07/Day19/"/>
    <id>http://yoursite.com/2019/08/07/Day19/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-08-07T14:30:57.716Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day19"><a href="#Day19" class="headerlink" title="Day19"></a>Day19</h1><p>今天讲的是拓扑排序算法<br>努力学习！！<br><a href="https://vjudge.net/contest/317983#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="加一个-假-模板"><a href="#加一个-假-模板" class="headerlink" title="加一个(假)模板"></a>加一个(假)模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int in[10100];// 存入度</span><br><span class="line">vector&lt;int&gt; v[10100];// 存关系 构建图</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m,n;</span><br><span class="line">int x,y;</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)// 根据题目要求可以改动</span><br><span class="line">&#123;</span><br><span class="line">memset(in,0,sizeof(in));// 清空入度</span><br><span class="line">for(int i=1;i&lt;=n;i++) v[i].clear() ;// 清空vector</span><br><span class="line">while(m--)// m组数据</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;y&gt;&gt;x;</span><br><span class="line">in[y]++;// y的关系大于x，x指向y y的入度+1；</span><br><span class="line">v[x].push_back(y);// 就 y 放在 x后面</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt;q;// 定义一个队列 最为节点的删除</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(!in[i]) &#123; // 入度为零的节点放入 队列</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty() )</span><br><span class="line">&#123;</span><br><span class="line">int xx=q.front() ; // 如果队列中一次存了大于 2 个节点</span><br><span class="line">q.pop() ; //说明该图有 2-&gt;3 &amp;&amp; 2-&gt;4 这种情况 有点个点之间没有关系</span><br><span class="line">n--; // 总节点数 -1；</span><br><span class="line">for(int i=0;i&lt;v[xx].size() ;i++) // 遍历这个节点后面的 点</span><br><span class="line">&#123;</span><br><span class="line">int yy=v[xx][i];</span><br><span class="line">in[yy]--; // 删除 x 后 yy 的入度就 -1；</span><br><span class="line">if(!in[yy]) &#123; // 如果此时 yy 入度为零放入队列 遍历他的下一个节点</span><br><span class="line">q.push(yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n) cout&lt;&lt;&quot;该图有环&quot;&lt;&lt;endl; // 如果总结点数没减为零 说明有环的存在</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Genealogical-tree"><a href="#Genealogical-tree" class="headerlink" title="Genealogical tree"></a>Genealogical tree</h1><p>Description:<br>The system of Martians’ blood relations is confusing enough. Actually, Martians bud when they want and where they want. They gather together in different groups, so that a Martian can have one parent as well as ten. Nobody will be surprised by a hundred of children. Martians have got used to this and their style of life seems to them natural.<br>And in the Planetary Council the confusing genealogical system leads to some embarrassment. There meet the worthiest of Martians, and therefore in order to offend nobody in all of the discussions it is used first to give the floor to the old Martians, than to the younger ones and only than to the most young childless assessors. However, the maintenance of this order really is not a trivial task. Not always Martian knows all of his parents (and there’s nothing to tell about his grandparents!). But if by a mistake first speak a grandson and only than his young appearing great-grandfather, this is a real scandal.<br>Your task is to write a program, which would define once and for all, an order that would guarantee that every member of the Council takes the floor earlier than each of his descendants.<br><code>Input</code><br>The first line of the standard input contains an only number N, 1 &lt;= N &lt;= 100 — a number of members of the Martian Planetary Council. According to the centuries-old tradition members of the Council are enumerated with the natural numbers from 1 up to N. Further, there are exactly N lines, moreover, the I-th line contains a list of I-th member’s children. The list of children is a sequence of serial numbers of children in a arbitrary order separated by spaces. The list of children may be empty. The list (even if it is empty) ends with 0.<br><code>Output</code><br>The standard output should contain in its only line a sequence of speakers’ numbers, separated by spaces. If several sequences satisfy the conditions of the problem, you are to write to the standard output any of them. At least one such sequence always exists.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">4 5 1 0</span><br><span class="line">1 0</span><br><span class="line">5 3 0</span><br><span class="line">3 0</span><br><span class="line">Sample Output</span><br><span class="line">2 4 5 3 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">//清空图 </span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">v[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">//存图，找度数 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1;; j ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">if(x == 0) break;</span><br><span class="line">v[i].push_back(x);</span><br><span class="line">in[x] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">//找到0入度，加入队列 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; xx;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else cout &lt;&lt; &quot; &quot; &lt;&lt; xx;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Window-Pains"><a href="#Window-Pains" class="headerlink" title="Window Pains"></a>Window Pains</h1><p>Description:<br>Boudreaux likes to multitask, especially when it comes to using his computer. Never satisfied with just running one application at a time, he usually runs nine applications, each in its own window. Due to limited screen real estate, he overlaps these windows and brings whatever window he currently needs to work with to the foreground. If his screen were a 4 x 4 grid of squares, each of Boudreaux’s windows would be represented by the following 2 x 2 windows:</p><p>When Boudreaux brings a window to the foreground, all of its squares come to the top, overlapping any squares it shares with other windows. For example, if window 1 and then window 2 were brought to the foreground, the resulting representation would be:</p><p>If window 4 were then brought to the foreground:</p><p>. . . and so on . . .<br>Unfortunately, Boudreaux’s computer is very unreliable and crashes often. He could easily tell if a crash occurred by looking at the windows and seeing a graphical representation that should not occur if windows were being brought to the foreground correctly. And this is where you come in . . .</p><p><code>Input</code><br>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets.</p><p>A single data set has 3 components:<br>Start line - A single line:<br>START</p><p>Screen Shot - Four lines that represent the current graphical representation of the windows on Boudreaux’s screen. Each position in this 4 x 4 matrix will represent the current piece of window showing in each square. To make input easier, the list of numbers on each line will be delimited by a single space.<br>End line - A single line:<br>END</p><p>After the last data set, there will be a single line:<br>ENDOFINPUT</p><p>Note that each piece of visible window will appear only in screen areas where the window could appear when brought to the front. For instance, a 1 can only appear in the top left quadrant.<br><code>Output</code><br>For each data set, there will be exactly one line of output. If there exists a sequence of bringing windows to the foreground that would result in the graphical representation of the windows on Boudreaux’s screen, the output will be a single line with the statement:</p><p>THESE WINDOWS ARE CLEAN</p><p>Otherwise, the output will be a single line with the statement:<br>THESE WINDOWS ARE BROKEN</p><p>题意：<br>给你一个4<em>4的棋盘窗口,现在电脑上有9个应用,每个应用占用固定的2</em>2正方形网格位置.你通过不同的顺序操作9个应用可以使得4<em>4的窗口当前显示的内容(数字代表)不同,现在给你一个4</em>4棋盘窗口的内容,问你这个内容是否合法.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">START</span><br><span class="line">1 2 3 3</span><br><span class="line">4 5 6 6</span><br><span class="line">7 8 9 9</span><br><span class="line">7 8 9 9</span><br><span class="line">END</span><br><span class="line">START</span><br><span class="line">1 1 3 3</span><br><span class="line">4 1 3 3</span><br><span class="line">7 7 9 9</span><br><span class="line">7 7 9 9</span><br><span class="line">END</span><br><span class="line">ENDOFINPUT</span><br><span class="line"></span><br><span class="line">Sample Output</span><br><span class="line">THESE WINDOWS ARE CLEAN</span><br><span class="line">THESE WINDOWS ARE BROKEN</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=10;</span><br><span class="line">vector&lt;int&gt; value[maxn][maxn];</span><br><span class="line">int dr[]=&#123;0,1,0,1&#125;;//原地,下,右,右下</span><br><span class="line">int dc[]=&#123;0,0,1,1&#125;;</span><br><span class="line">int G[maxn][maxn]; //图</span><br><span class="line">int in[maxn];      //入度</span><br><span class="line"> </span><br><span class="line">bool topo()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt; Q;</span><br><span class="line">    for(int i=0;i&lt;9;i++)</span><br><span class="line">        if(in[i]==0) Q.push(i);</span><br><span class="line">    int sum=0;//记录我们删除的0入度点</span><br><span class="line">    while(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int u=Q.front(); Q.pop();</span><br><span class="line">        for(int v=0;v&lt;9;v++)if(G[u][v])</span><br><span class="line">        &#123;</span><br><span class="line">            G[u][v]=0;</span><br><span class="line">            if(--in[v]==0) Q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum==9;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;9;i++)                //处理0-8每个应用所在的方格vector</span><br><span class="line">    &#123;</span><br><span class="line">        int r=i/3, c=i%3;               //i应用左上角的格子所在的(r,c)</span><br><span class="line">        for(int dir=0;dir&lt;4;dir++)      //i应用所在的其他3个点</span><br><span class="line">        &#123;</span><br><span class="line">            int nr=r+dr[dir], nc=c+dc[dir];</span><br><span class="line">            value[nr][nc].push_back(i); //将i压入对应方格的vector中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    char str[100];</span><br><span class="line">    while(scanf(&quot;%s&quot;,str)==1&amp;&amp;str[0]!=&apos;E&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(G,0,sizeof(G));</span><br><span class="line">        memset(in,0,sizeof(in));</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">        for(int j=0;j&lt;4;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int v;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;v);</span><br><span class="line">            v--;</span><br><span class="line">            for(int k=0;k&lt;value[i][j].size();k++)</span><br><span class="line">            if((value[i][j])[k]!=v)//构造有向边</span><br><span class="line">            &#123;</span><br><span class="line">                int x=(value[i][j])[k];</span><br><span class="line">                if(G[x][v]==0)//一定要做这个判断,因为会重复添加有向边</span><br><span class="line">                &#123;</span><br><span class="line">                    in[v]++;</span><br><span class="line">                    G[x][v]=1;</span><br><span class="line">                &#125;</span><br><span class="line">                //printf(&quot;当前格子为:(%d,%d),当前边为:%d v=%d, %d点的入度为%d\n&quot;,i,j,x,v,v,in[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(topo()) printf(&quot;THESE WINDOWS ARE CLEAN\n&quot;);</span><br><span class="line">        else printf(&quot;THESE WINDOWS ARE BROKEN\n&quot;);</span><br><span class="line">        scanf(&quot;%s&quot;,str);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="确定比赛名次（拓扑排序）"><a href="#确定比赛名次（拓扑排序）" class="headerlink" title="确定比赛名次（拓扑排序）"></a>确定比赛名次（拓扑排序）</h1><p>Description:<br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。<br><code>Input</code><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。<br><code>Output</code><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。</p><p>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br><span class="line">Sample Output</span><br><span class="line">1 2 4 3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">//清空图 </span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">v[i].clear();</span><br><span class="line">&#125;</span><br><span class="line">//存图，找度数 </span><br><span class="line">while(m --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x, &amp;y);</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">//找到0入度，加入队列 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; xx;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else cout &lt;&lt; &quot; &quot; &lt;&lt; xx;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="产生冠军"><a href="#产生冠军" class="headerlink" title="产生冠军"></a>产生冠军</h1><p>Description:<br>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。<br><code>Input</code><br>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。<br><code>Output</code><br>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">Alice Bob</span><br><span class="line">Smith John</span><br><span class="line">Alice Smith</span><br><span class="line">5</span><br><span class="line">a c</span><br><span class="line">c d</span><br><span class="line">d e</span><br><span class="line">b e</span><br><span class="line">a d</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">//第一种方法</span><br><span class="line">//set方法 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">string s1, s2;</span><br><span class="line">set&lt;string&gt; all, loser;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">all.clear();</span><br><span class="line">loser.clear();</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">all.insert(s1);</span><br><span class="line">all.insert(s2);</span><br><span class="line">loser.insert(s2);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (all.size() - loser.size() == 1 ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二种：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e4 + 10;</span><br><span class="line">int in[maxx];</span><br><span class="line">//int edge[maxx][maxx];//用于构图但是这一题没有用到 </span><br><span class="line">bool slove(int n)</span><br><span class="line">&#123;</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">sum ++;</span><br><span class="line">&#125;</span><br><span class="line">if(sum == 1) return true;</span><br><span class="line">return false;</span><br><span class="line"> &#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">map&lt;string, int&gt; mp;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">//清空图 </span><br><span class="line">mp.clear();</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">//memset(edge, 0, sizeof edge);//没用到 </span><br><span class="line">string s1, s2;</span><br><span class="line">int t = 1; </span><br><span class="line">//存图</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">if(!mp[s1]) mp[s1] = t ++;</span><br><span class="line">if(!mp[s2]) mp[s2] = t ++;</span><br><span class="line">//edge[mp[s1]][mp[s2]] = 1;//没用到</span><br><span class="line">in[mp[s2]] ++; </span><br><span class="line">&#125;</span><br><span class="line">t --;</span><br><span class="line">if(slove(t)) puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三种：</span><br><span class="line">//map的另一种做法 </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, cnt;</span><br><span class="line">map&lt;string, int&gt; mp;</span><br><span class="line">string winner, loser;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">mp.clear();</span><br><span class="line">cnt = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; winner &gt;&gt; loser;</span><br><span class="line">if(mp.find(winner) == mp.end())</span><br><span class="line">mp[winner] = 1;</span><br><span class="line">mp[loser] = 0;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; :: iterator it;</span><br><span class="line">for(it = mp.begin(); it != mp.end(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">if(it -&gt; second)</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">if(cnt == 1) puts(&quot;Yes&quot;);</span><br><span class="line">else puts(&quot;No&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Legal-or-Not"><a href="#Legal-or-Not" class="headerlink" title="Legal or Not"></a>Legal or Not</h1><p>Description:<br>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many “holy cows” like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost “master”, and Lost will have a nice “prentice”. By and by, there are many pairs of “master and prentice”. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?</p><p>We all know a master can have many prentices and a prentice may have a lot of masters too, it’s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian’s master and, at the same time, 3xian is HH’s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not.</p><p>Please note that the “master and prentice” relation is transitive. It means that if A is B’s master ans B is C’s master, then A is C’s master.<br><code>Input</code><br>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y’s master and y is x’s prentice. The input is terminated by N = 0.<br>TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,…, N-1). We use their numbers instead of their names.<br><code>Output</code><br>For each test case, print in one line the judgement of the messy relationship.<br>If it is legal, output “YES”, otherwise “NO”.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 2</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int flag = 1, cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">n --;</span><br><span class="line">if(cnt &gt;= n) continue;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(n) puts(&quot;NO&quot;);</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="Reward"><a href="#Reward" class="headerlink" title="Reward"></a>Reward</h1><p>Description:<br>Dandelion’s uncle is a boss of a factory. As the spring festival is coming , he wants to distribute rewards to his workers. Now he has a trouble about how to distribute the rewards.<br>The workers will compare their rewards ,and some one may have demands of the distributing of rewards ,just like a’s reward should more than b’s.Dandelion’s unclue wants to fulfill all the demands, of course ,he wants to use the least money.Every work’s reward will be at least 888 , because it’s a lucky number.<br><code>Input</code><br>One line with two integers n and m ,stands for the number of works and the number of demands .(n&lt;=10000,m&lt;=20000)<br>then m lines ,each line contains two integers a and b ,stands for a’s reward should be more than b’s.<br><code>Output</code><br>For every case ,print the least money dandelion ‘s uncle needs to distribute .If it’s impossible to fulfill all the works’ demands ,print -1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">Sample Output</span><br><span class="line">1777</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx], sum[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; y &gt;&gt; x;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int ans = 0, k = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">sum[i] = 888;</span><br><span class="line">&#125;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">k ++;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">sum[v[xx][i]] = sum[xx] + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">ans += sum[i];</span><br><span class="line">if(n != k) puts(&quot;-1&quot;);</span><br><span class="line">else cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ordering-Tasks"><a href="#Ordering-Tasks" class="headerlink" title="Ordering Tasks"></a>Ordering Tasks</h2><p>Description:<br>John has n tasks to do. Unfortunately, the tasks are not independent and the execution of one task is<br>only possible if other tasks have already been executed.<br>Input<br>The input will consist of several instances of the problem. Each instance begins with a line containing<br>two integers, 1 ≤ n ≤ 100 and m. n is the number of tasks (numbered from 1 to n) and m is the<br>number of direct precedence relations between tasks. After this, there will be m lines with two integers<br>i and j, representing the fact that task i must be executed before task j.<br>An instance with n = m = 0 will finish the input.<br>Output<br>For each instance, print a line with n integers representing the tasks in a possible order of execution.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">1 5</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">1 4 2 5 3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int in[maxx];</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, x, y;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">memset(in, 0, sizeof in);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">v[i].clear();</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">in[y] ++;</span><br><span class="line">&#125;</span><br><span class="line">//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i] == 0)</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">int flag = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int xx = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; xx;</span><br><span class="line">flag = 0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot; &quot; &lt;&lt; xx; </span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; v[xx].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">in[v[xx][i]] --;</span><br><span class="line">if(in[v[xx][i]] == 0)</span><br><span class="line">q.push(v[xx][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Rank-of-Tetris"><a href="#Rank-of-Tetris" class="headerlink" title="Rank of Tetris"></a>Rank of Tetris</h2><p>Description:<br>自从Lele开发了Rating系统，他的Tetris事业更是如虎添翼，不久他遍把这个游戏推向了全球。</p><p>为了更好的符合那些爱好者的喜好，Lele又想了一个新点子：他将制作一个全球Tetris高手排行榜，定时更新，名堂要比福布斯富豪榜还响。关于如何排名，这个不用说都知道是根据Rating从高到低来排，如果两个人具有相同的Rating，那就按这几个人的RP从高到低来排。</p><p>终于，Lele要开始行动了，对N个人进行排名。为了方便起见，每个人都已经被编号，分别从0到N-1,并且编号越大，RP就越高。<br>同时Lele从狗仔队里取得一些（M个）关于Rating的信息。这些信息可能有三种情况，分别是”A &gt; B”,”A = B”,”A &lt; B”，分别表示A的Rating高于B,等于B,小于B。</p><p>现在Lele并不是让你来帮他制作这个高手榜，他只是想知道，根据这些信息是否能够确定出这个高手榜，是的话就输出”OK”。否则就请你判断出错的原因，到底是因为信息不完全（输出”UNCERTAIN”），还是因为这些信息中包含冲突（输出”CONFLICT”）。<br>注意，如果信息中同时包含冲突且信息不完全，就输出”CONFLICT”。<br><code>Input</code><br>本题目包含多组测试，请处理到文件结束。<br>每组测试第一行包含两个整数N,M(0&lt;=N&lt;=10000,0&lt;=M&lt;=20000),分别表示要排名的人数以及得到的关系数。<br>接下来有M行，分别表示这些关系<br><code>Output</code><br>对于每组测试，在一行里按题目要求输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">0 &gt; 1</span><br><span class="line">1 &lt; 2</span><br><span class="line">0 &gt; 2</span><br><span class="line">4 4</span><br><span class="line">1 = 2</span><br><span class="line">1 &gt; 3</span><br><span class="line">2 &gt; 0</span><br><span class="line">0 &gt; 1</span><br><span class="line">3 3</span><br><span class="line">1 &gt; 0</span><br><span class="line">1 &gt; 2</span><br><span class="line">2 &lt; 1</span><br><span class="line">Sample Output</span><br><span class="line">OK</span><br><span class="line">CONFLICT</span><br><span class="line">UNCERTAIN</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node//边</span><br><span class="line">&#123;</span><br><span class="line">int a,b;//顶点</span><br><span class="line">char ch;//运算符</span><br><span class="line">&#125;c[10005];</span><br><span class="line">vector&lt;int&gt;map[10005];//map数组存贮邻接表</span><br><span class="line">int n,m,sum,in[10005],fa[10005];//in数组表示入度,fa[i]表示顶点i所在集合的根节点</span><br><span class="line">int find(int x)//查找根节点</span><br><span class="line">&#123;</span><br><span class="line">if(fa[x]!=x) fa[x]=find(fa[x]);</span><br><span class="line">return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">bool comb(int x,int y)//合并集合</span><br><span class="line">&#123;</span><br><span class="line">x=find(x);</span><br><span class="line">y=find(y);</span><br><span class="line">if(x==y)</span><br><span class="line">return false;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">fa[y]=x;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">void top_sort()//queue实现拓扑排序</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt;s;</span><br><span class="line">int flag=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(in[i]==0&amp;&amp;fa[i]==i)</span><br><span class="line">s.push(i);</span><br><span class="line">&#125;</span><br><span class="line">while(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">if(s.size()&gt;1)//即使发现信息不完整也要继续运行下去，因为如果信息同时不完整和冲突都是CONFLICT</span><br><span class="line">flag=1;</span><br><span class="line">int pos=s.front();</span><br><span class="line">s.pop(),sum--;</span><br><span class="line">for(int i=0;i&lt;map[pos].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">in[map[pos][i]]--;</span><br><span class="line">if(in[map[pos][i]]==0)</span><br><span class="line">s.push(map[pos][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(sum&gt;0) printf(&quot;CONFLICT\n&quot;);</span><br><span class="line">else if(flag) printf(&quot;UNCERTAIN\n&quot;);</span><br><span class="line">else printf(&quot;OK\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">sum=n;</span><br><span class="line">init();</span><br><span class="line">memset(map,0,sizeof(map));</span><br><span class="line">memset(in,0,sizeof(in));</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %c %d&quot;,&amp;c[i].a,&amp;c[i].ch,&amp;c[i].b);</span><br><span class="line">if(c[i].ch==&apos;=&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(comb(c[i].a,c[i].b))</span><br><span class="line">sum--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(c[i].ch==&apos;=&apos;)</span><br><span class="line">continue;</span><br><span class="line">int x=find(c[i].a);</span><br><span class="line">int y=find(c[i].b);</span><br><span class="line">if(c[i].ch==&apos;&gt;&apos;)</span><br><span class="line">&#123;</span><br><span class="line">map[x].push_back(y);</span><br><span class="line">in[y]++;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">map[y].push_back(x);</span><br><span class="line">in[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top_sort();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day19&quot;&gt;&lt;a href=&quot;#Day19&quot; class=&quot;headerlink&quot; title=&quot;Day19&quot;&gt;&lt;/a&gt;Day19&lt;/h1&gt;&lt;p&gt;今天讲的是拓扑排序算法&lt;br&gt;努力学习！！&lt;br&gt;&lt;a href=&quot;https://vjudge.net/contest/317983#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day18</title>
    <link href="http://yoursite.com/2019/08/06/Day18/"/>
    <id>http://yoursite.com/2019/08/06/Day18/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-07T14:30:49.761Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day18"><a href="#Day18" class="headerlink" title="Day18"></a>Day18</h1><p>今天讲的是最短路算法<br><code>补题</code><br><a href="https://vjudge.net/contest/317592#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><blockquote><p>提醒自己一下，因为今天有事没有写完这些题目，所以大部分的题解和代码都是在网上找到的，希望以后自己可以把这部分题补上</p></blockquote><h2 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h2><p>详情链接-&gt;<a href="https://cdreamer.cn/2019/06/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" target="_blank" rel="noopener">传送</a></p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>Description:<br>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><p><code>Input</code><br>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。<br><code>Output</code><br>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2 1</span><br><span class="line">1 2 3</span><br><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int map[maxx][maxx];</span><br><span class="line">int dj(int x, int n)</span><br><span class="line">&#123;</span><br><span class="line">int p;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">dis[i] = map[1][i];</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">vis[x] = 1;</span><br><span class="line">for(int i = 1; i &lt;= n ; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int minn = INF;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">&#123;</span><br><span class="line">minn = dis[j];</span><br><span class="line">p = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[p] = 1;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(!vis[j] &amp;&amp; dis[p] + map[p][j] &lt; dis[j])</span><br><span class="line">dis[j] = dis[p] + map[p][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int a, b, c;</span><br><span class="line">while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break; </span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">map[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">if(map[a][b] &gt; c)</span><br><span class="line">map[a][b] = map[b][a] = c;</span><br><span class="line">&#125;</span><br><span class="line">dj(1, n);</span><br><span class="line">cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Frogger"><a href="#Frogger" class="headerlink" title="Frogger"></a>Frogger</h2><p>Description:<br>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.<br>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.<br>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.<br>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.</p><p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.<br><code>Input</code><br>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.<br><code>Output</code><br>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">17 4</span><br><span class="line">19 4</span><br><span class="line">18 5</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Scenario #1</span><br><span class="line">Frog Distance = 5.000</span><br><span class="line"></span><br><span class="line">Scenario #2</span><br><span class="line">Frog Distance = 1.414</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">//Floyd解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for(int k=1; k&lt;=n; k++)</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=min(map[i][j],max(map[i][k],map[k][j]));//许多通路中最长边中的最小边</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        floyd();</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,map[1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//dijkstra解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">double dis[maxnum];</span><br><span class="line">int vis[maxnum];</span><br><span class="line">void dj(int s)</span><br><span class="line">&#123;</span><br><span class="line">    mem(vis,0);</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;//这里最好别用memset</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minn=inf,k;</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            if(vis[j]==0&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                k=j;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        vis[k]=1;</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            dis[j]=min(dis[j],max(dis[k],map[k][j]));//dis[j]为从一号石头到第j号石头所有通路中最长边中的最小边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        dj(1);</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,dis[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//SPFA解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">double dis[maxnum];</span><br><span class="line">int vis[maxnum];</span><br><span class="line">void spfa()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    dis[1]=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        vis[i]=0;</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int k=q.front();</span><br><span class="line">        vis[k]=0;</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            if(max(dis[k],map[k][j])&lt;dis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j]=max(dis[k],map[k][j]);</span><br><span class="line">                if(vis[j]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    vis[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        spfa();</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,dis[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Stockbroker-Grapevine"><a href="#Stockbroker-Grapevine" class="headerlink" title="Stockbroker Grapevine"></a>Stockbroker Grapevine</h2><p>Description:<br>Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way.</p><p>Unfortunately for you, stockbrokers only trust information coming from their “Trusted sources” This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.<br><code>Input</code><br>Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a ‘1’ means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules.</p><p>Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people.</p><p><code>Output</code><br>For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.<br>It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message “disjoint”. Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">2 2 4 3 5</span><br><span class="line">2 1 2 3 6</span><br><span class="line">2 1 2 2 2</span><br><span class="line">5</span><br><span class="line">3 4 4 2 8 5 3</span><br><span class="line">1 5 8</span><br><span class="line">4 1 6 4 10 2 7 5 2</span><br><span class="line">0</span><br><span class="line">2 2 5 1 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3 2</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">经典水题floyd这道题重点在于找到从某一个源点出发的最短路</span><br><span class="line">怎么找？可以找到从一个源点出发最长的时间，即是传递结束，</span><br><span class="line">然后找最长的最短。当然会出现有些人没有传递到，但是这道</span><br><span class="line">题的bug在于此，不会出现disjoint的情况。</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define inf 20</span><br><span class="line">#define M 210</span><br><span class="line"> </span><br><span class="line">int dist[M][M];</span><br><span class="line">int n;</span><br><span class="line"> </span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for(int k = 1;k &lt;= n; k++)</span><br><span class="line">        for(int i = 1;i &lt;= n; i++)</span><br><span class="line">            for(int j = 1;j &lt;= n; j++)</span><br><span class="line">                if(i != j &amp;&amp; dist[i][j] &gt; dist[i][k] + dist[k][j])</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line"> </span><br><span class="line">    int minlength = inf;</span><br><span class="line">    int maxlength,pos;</span><br><span class="line">    for(int i = 1;i &lt;= n; i++)&#123;</span><br><span class="line">        maxlength = 0;</span><br><span class="line">        for(int j = 1;j &lt;= n; j++)</span><br><span class="line">            if(i != j &amp;&amp; maxlength &lt; dist[i][j])</span><br><span class="line">                maxlength = dist[i][j];</span><br><span class="line">        if(minlength &gt; maxlength)&#123;</span><br><span class="line">            minlength = maxlength;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;minlength&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        memset(dist,inf,sizeof(dist));</span><br><span class="line"> </span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line"> </span><br><span class="line">        if(!n)</span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        for(int i = 1;i &lt;= n; i++)&#123;</span><br><span class="line">            int n1;</span><br><span class="line">            cin&gt;&gt;n1;</span><br><span class="line">            for(int j = 1;j &lt;= n1; j++)&#123;</span><br><span class="line">                int p,t;</span><br><span class="line">                cin&gt;&gt;p&gt;&gt;t;</span><br><span class="line">                dist[i][p] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Invitation-Cards"><a href="#Invitation-Cards" class="headerlink" title="Invitation Cards"></a>Invitation Cards</h2><p>Description:<br>In the age of television, not many people attend theater performances. Antique Comedians of Malidinesia are aware of this fact. They want to propagate theater and, most of all, Antique Comedies. They have printed invitation cards with all the necessary information and with the programme. A lot of students were hired to distribute these invitations among the people. Each student volunteer has assigned exactly one bus stop and he or she stays there the whole day and gives invitation to people travelling by bus. A special course was taken where students learned how to influence people and what is the difference between influencing and robbery.</p><p>The transport system is very special: all lines are unidirectional and connect exactly two stops. Buses leave the originating stop with passangers each half an hour. After reaching the destination stop they return empty to the originating stop, where they wait until the next full half an hour, e.g. X:00 or X:30, where ‘X’ denotes the hour. The fee for transport between two stops is given by special tables and is payable on the spot. The lines are planned in such a way, that each round trip (i.e. a journey starting and finishing at the same stop) passes through a Central Checkpoint Stop (CCS) where each passenger has to pass a thorough check including body scan.</p><p>All the ACM student members leave the CCS each morning. Each volunteer is to move to one predetermined stop to invite passengers. There are as many volunteers as stops. At the end of the day, all students travel back to CCS. You are to write a computer program that helps ACM to minimize the amount of money to pay every day for the transport of their employees.<br><code>Input</code><br>The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case begins with a line containing exactly two integers P and Q, 1 &lt;= P,Q &lt;= 1000000. P is the number of stops including CCS and Q the number of bus lines. Then there are Q lines, each describing one bus line. Each of the lines contains exactly three numbers - the originating stop, the destination stop and the price. The CCS is designated by number 1. Prices are positive integers the sum of which is smaller than 1000000000. You can also assume it is always possible to get from any stop to any other stop.<br><code>Output</code><br>For each case, print one line containing the minimum amount of money to be paid each day by ACM for the travel costs of its volunteers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 2 13</span><br><span class="line">2 1 33</span><br><span class="line">4 6</span><br><span class="line">1 2 10</span><br><span class="line">2 1 60</span><br><span class="line">1 3 20</span><br><span class="line">3 4 10</span><br><span class="line">2 4 5</span><br><span class="line">4 1 50</span><br><span class="line">Sample Output</span><br><span class="line">46</span><br><span class="line">210</span><br></pre></td></tr></table></figure><p><code>题意</code><br>求1到各个顶点和各个定点到1的路线总长最短。有向图。<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//各个点到1顶点的总和最短可以反向建图来实现。而不是反复最短路</span><br><span class="line">//因为有1000000的顶点所以采用了邻接表。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1000000+100;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int b[N],w[N],e[N];</span><br><span class="line">int fir[N],nxt[N];</span><br><span class="line">int n,m;</span><br><span class="line">int dis[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void  spfa(int &amp;ans)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=i==1?0:inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[1]=0;vis[1]=1;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int now=q.front();</span><br><span class="line">        int k=fir[now];</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now]=0;</span><br><span class="line">        while(k!=-1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(dis[e[k]]&gt;dis[b[k]]+w[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[e[k]]=dis[b[k]]+w[k];</span><br><span class="line">                if(!vis[e[k]]) q.push(e[k]),vis[e[k]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            k=nxt[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fir[i]=-1;</span><br><span class="line">            nxt[i]=-1;</span><br><span class="line">            dis[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;b[i],&amp;e[i],&amp;w[i]);</span><br><span class="line">            nxt[i]=fir[b[i]];</span><br><span class="line">            fir[b[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(ans);</span><br><span class="line">        memset(nxt,-1,sizeof nxt);</span><br><span class="line">        memset(fir,-1,sizeof fir);</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int t=b[i];</span><br><span class="line">            b[i]=e[i];</span><br><span class="line">            e[i]=t;</span><br><span class="line">            nxt[i]=fir[b[i]];</span><br><span class="line">            fir[b[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(ans);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Skiing"><a href="#Skiing" class="headerlink" title="Skiing"></a>Skiing</h2><p>Description:<br>Bessie and the rest of Farmer John’s cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 &lt;= R &lt;= 100) by C (1 &lt;= C &lt;= 100) grid of elevations E (-25 &lt;= E &lt;= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.</p><p>Bessie starts out travelling at a initial speed V (1 &lt;= V &lt;= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.</p><p>Find the both smallest amount of time it will take Bessie to join her cow friends.<br><code>Input</code></p><ul><li><p>Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie’s initial velocity and the number of rows and columns in the grid.</p></li><li><p>Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid.<br><code>Output</code><br>A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 3 3</span><br><span class="line">1 5 3</span><br><span class="line">6 3 5</span><br><span class="line">2 4 3</span><br><span class="line">Sample Output</span><br><span class="line">29.00</span><br><span class="line">Hint</span><br><span class="line">Bessie&apos;s best route is: </span><br><span class="line">Start at 1,1 time 0 speed 1 </span><br><span class="line">East to 1,2 time 1 speed 1/16 </span><br><span class="line">South to 2,2 time 17 speed 1/4 </span><br><span class="line">South to 3,2 time 21 speed 1/8 </span><br><span class="line">East to 3,3 time 29 speed 1/4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">//dijkstra解法</span><br><span class="line">/*dijkstra解法题解：每个节点的耗时就是从左上角（1，1）点到（i,j)点的2^高度差,而速度是其倒数，需输出的啦~，先把节点存储成耗时的静态邻接表，然后利用dijkstra的堆优化进行（nlogn)的求解。*/</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define maxn 111</span><br><span class="line">#define inf 999999999999</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">struct node&#123;</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">double dis;</span><br><span class="line">bool operator &lt; (const node &amp;a) const&#123;</span><br><span class="line">return dis&gt;a.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int dic[4][2]=&#123;0,1,1,0,-1,0,0,-1&#125;;</span><br><span class="line">int at[maxn][maxn];</span><br><span class="line">double mp[maxn][maxn];</span><br><span class="line">double dis[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int v,r,c;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">dis[i][j]=inf;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">double get_cost(int h)</span><br><span class="line">&#123;</span><br><span class="line">return v*1.0*pow(2*1.0,at[1][1]-h);</span><br><span class="line">&#125;</span><br><span class="line">bool ok(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">if(x&gt;0&amp;&amp;x&lt;=r&amp;&amp;y&gt;0&amp;&amp;y&lt;=c)</span><br><span class="line">return true;</span><br><span class="line">else </span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">node now,next;</span><br><span class="line">now.x=1;</span><br><span class="line">now.y=1;</span><br><span class="line">now.dis=0;</span><br><span class="line">dis[1][1]=0;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">now=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">if(vis[now.x][now.y]) continue;</span><br><span class="line">vis[now.x][now.y]=true;</span><br><span class="line">if(now.x==r&amp;&amp;now.y==c)</span><br><span class="line">break;</span><br><span class="line">int x;int y;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">x=now.x+dic[i][0];</span><br><span class="line">y=now.y+dic[i][1];</span><br><span class="line">if(!ok(x,y)) continue;</span><br><span class="line">if(!vis[x][y]&amp;&amp;dis[x][y]&gt;now.dis+1.0/mp[now.x][now.y])</span><br><span class="line">&#123;</span><br><span class="line">dis[x][y]=now.dis+1.0/mp[now.x][now.y];</span><br><span class="line">next.x=x;</span><br><span class="line">next.y=y;</span><br><span class="line">next.dis=dis[x][y];</span><br><span class="line">q.push(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d%d&quot;,&amp;v,&amp;r,&amp;c);</span><br><span class="line">init();</span><br><span class="line">//printf(&quot;%lf\n&quot;,dis[1][1]);</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">scanf(&quot;%d&quot;,&amp;at[i][j]);</span><br><span class="line">for(int i=1;i&lt;=r;i++)</span><br><span class="line">for(int j=1;j&lt;=c;j++)</span><br><span class="line">mp[i][j]=get_cost(at[i][j]);</span><br><span class="line">dijkstra();</span><br><span class="line">printf(&quot;%.2f\n&quot;,dis[r][c]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SPFA解法</span><br><span class="line">/*题解：可以看出每个点的速度都与第一个点有关，因为V*2^(A-B)*2^(B-C)它就等于V*2^(A-C)，所以每个点的速度都可以用第一个点算出来。然后把每个点对应到下一个点的时间存到这个点的位置上。*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cfloat&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double inf = 0x3f3f3f3f;</span><br><span class="line">const int MAX = 200;</span><br><span class="line">int v,r,c;</span><br><span class="line">int vis[MAX][MAX];</span><br><span class="line">double mp[MAX][MAX],t[MAX][MAX],dis[MAX][MAX];// mp要用double 待会用到pow函数要不然报错</span><br><span class="line">int mv[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">struct hh&#123;</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">void spfa()&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">for(int i=1;i&lt;=r;i++)&#123;// 赋一个很大的值给double类型的数组，要用这种形式，要不然用下面那种形式，不对。</span><br><span class="line">for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">dis[i][j] = DBL_MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//memset(dis,inf,sizeof(dis));</span><br><span class="line">queue&lt;hh&gt; q;</span><br><span class="line">hh tmp,nex;</span><br><span class="line">int xx,yy;</span><br><span class="line">tmp.x=1;</span><br><span class="line">tmp.y=1;</span><br><span class="line">dis[1][1]=0;//注意赋值为0，dis数组表示别的点到这个点需要的时间，不包括这个点到别的点的时间，也就是不包括这个点所存的时间</span><br><span class="line">q.push(tmp);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">tmp=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[tmp.x][tmp.y]=0;// 注意要赋值0，要不然会错，因为这个点我们可能需要重新走</span><br><span class="line">for (int i = 0; i &lt; 4;i++)&#123;</span><br><span class="line">xx=tmp.x+mv[i][0];</span><br><span class="line">yy=tmp.y+mv[i][1];</span><br><span class="line">if(xx&lt;1|yy&lt;1||xx&gt;r||yy&gt;c) continue;</span><br><span class="line">if(dis[xx][yy]&gt;t[tmp.x][tmp.y]+dis[tmp.x][tmp.y])&#123;</span><br><span class="line">dis[xx][yy]=t[tmp.x][tmp.y]+dis[tmp.x][tmp.y];</span><br><span class="line">if(!vis[xx][yy])&#123;</span><br><span class="line">vis[xx][yy]=1;</span><br><span class="line">nex.x=xx;</span><br><span class="line">nex.y=yy;</span><br><span class="line">q.push(nex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; r &gt;&gt; c;</span><br><span class="line">for (int i = 1; i &lt;= r;i++)&#123;</span><br><span class="line">for (int j = 1; j &lt;= c;j++)&#123;</span><br><span class="line">cin &gt;&gt; mp[i][j];</span><br><span class="line">t[i][j]=1/(v*(pow(2,mp[1][1]-mp[i][j])));//计算每个点到下一个点所需要的时间，存到这个点上</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">spfa();</span><br><span class="line">printf(&quot;%.2lf\n&quot;,dis[r][c]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cow-Hurdles"><a href="#Cow-Hurdles" class="headerlink" title="Cow Hurdles"></a>Cow Hurdles</h2><p>Description:<br>Farmer John wants the cows to prepare for the county jumping competition, so Bessie and the gang are practicing jumping over hurdles. They are getting tired, though, so they want to be able to use as little energy as possible to jump over the hurdles.</p><p>Obviously, it is not very difficult for a cow to jump over several very short hurdles, but one tall hurdle can be very stressful. Thus, the cows are only concerned about the height of the tallest hurdle they have to jump over.</p><p>The cows’ practice room has N (1 ≤ N ≤ 300) stations, conveniently labeled 1..N. A set of M (1 ≤ M ≤ 25,000) one-way paths connects pairs of stations; the paths are also conveniently labeled 1..M. Path i travels from station Si to station Ei and contains exactly one hurdle of height Hi (1 ≤ Hi ≤ 1,000,000). Cows must jump hurdles in any path they traverse.</p><p>The cows have T (1 ≤ T ≤ 40,000) tasks to complete. Task i comprises two distinct numbers, Ai and Bi (1 ≤ Ai ≤ N; 1 ≤ Bi ≤ N), which connote that a cow has to travel from station Ai to station Bi (by traversing over one or more paths over some route). The cows want to take a path the minimizes the height of the tallest hurdle they jump over when traveling from Ai to Bi . Your job is to write a program that determines the path whose tallest hurdle is smallest and report that height.</p><p><code>Input</code></p><ul><li>Line 1: Three space-separated integers: N, M, and T</li><li>Lines 2..M+1: Line i+1 contains three space-separated integers: Si , Ei , and Hi</li><li>Lines M+2..M+T+1: Line i+M+1 contains two space-separated integers that describe task i: Ai and Bi</li></ul><p><code>Output</code></p><ul><li>Lines 1..T: Line i contains the result for task i and tells the smallest possible maximum height necessary to travel between the stations. Output -1 if it is impossible to travel between the two stations.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ample Input</span><br><span class="line">5 6 3</span><br><span class="line">1 2 12</span><br><span class="line">3 2 8</span><br><span class="line">1 3 5</span><br><span class="line">2 5 3</span><br><span class="line">3 4 4</span><br><span class="line">2 4 8</span><br><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">5 1</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><blockquote><p>题意：有一头牛，要进行跳木桩训练，已知有n个木桩，而且知道m对木桩之间的高度差。但是它很懒，它想尽可能的跳最小的高度就完成从任意一个木桩到任意一个木桩的跳跃，给m对点，问是否存在最小的跳跃高度使得其能够完成跳跃，如果有就输出最小高度；否则输出-1。</p></blockquote><blockquote><p>解析：对于每一次询问，求的是每条路径上边权值的最大值（该路径所经过的相邻两木桩之间的差值的最大值），然后取其中的最小值即可。因为只要能跳过这个高度差最大的，高度差小的当然能跳过去了。由于是求任意两木桩之间的所有路径上最大高度差值的最小值，所以我们可以用Floyd算法，对其进行处理，处理之后得到的最终结果即为所求了。</p></blockquote><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 123456789</span><br><span class="line">int a[302][302];        //最大高度的最小值矩阵</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, t;</span><br><span class="line">    int x, y, w;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t)!=EOF)&#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)                 //初始化</span><br><span class="line">            for(int j=1; j&lt;=n; j++) a[i][j] = i==j ? 0 : INF;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)&#123;                //读入高度差</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            a[x][y] = min(a[x][y], w);          //更新最大高度差</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k=1; k&lt;=n; k++)                 //Floyd</span><br><span class="line">            for(int i=1; i&lt;=n; i++)</span><br><span class="line">                for(int j=1; j&lt;=n; j++)&#123;</span><br><span class="line">                    a[i][j] = min(a[i][j], max(a[i][k], a[k][j]));      </span><br><span class="line">                &#125;</span><br><span class="line">        for(int i=1; i&lt;=t; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">            printf(&quot;%d\n&quot;, a[x][y]==INF ? -1 : a[x][y]);       //输出，如果还是INF，那就代表不可达，两者时之间没有路径满足要求</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day18&quot;&gt;&lt;a href=&quot;#Day18&quot; class=&quot;headerlink&quot; title=&quot;Day18&quot;&gt;&lt;/a&gt;Day18&lt;/h1&gt;&lt;p&gt;今天讲的是最短路算法&lt;br&gt;&lt;code&gt;补题&lt;/code&gt;&lt;br&gt;&lt;a href=&quot;https://vjudge.net/contest/317592#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day17</title>
    <link href="http://yoursite.com/2019/08/05/Day17/"/>
    <id>http://yoursite.com/2019/08/05/Day17/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-05T14:17:27.973Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day17"><a href="#Day17" class="headerlink" title="Day17"></a>Day17</h1><p>今天讲的是并查集和最小生成树<br><a href="https://vjudge.net/contest/317297#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="并查集-最小生成树"><a href="#并查集-最小生成树" class="headerlink" title="并查集+最小生成树"></a>并查集+最小生成树</h2><p>具体内容点这里-&gt;<a href="https://cdreamer.cn/2019/06/02/%E5%B9%B6%E6%9F%A5%E9%9B%86+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" target="_blank" rel="noopener">链接</a></p><h2 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h2><p>Description:<br>Severe acute respiratory syndrome (SARS), an atypical pneumonia of unknown aetiology, was recognized as a global threat in mid-March 2003. To minimize transmission to others, the best strategy is to separate the suspects from others.<br>In the Not-Spreading-Your-Sickness University (NSYSU), there are many student groups. Students in the same group intercommunicate with each other frequently, and a student may join several groups. To prevent the possible transmissions of SARS, the NSYSU collects the member lists of all student groups, and makes the following rule in their standard operation procedure (SOP).<br>Once a member in a group is a suspect, all members in the group are suspects.<br>However, they find that it is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects.<br><code>Input</code><br>The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.<br>A case with n = 0 and m = 0 indicates the end of the input, and need not be processed.<br><code>Output</code><br>For each case, output the number of suspects in one line.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">100 4</span><br><span class="line">2 1 2</span><br><span class="line">5 10 13 11 12 14</span><br><span class="line">2 0 1</span><br><span class="line">2 99 2</span><br><span class="line">200 2</span><br><span class="line">1 5</span><br><span class="line">5 1 2 3 4 5</span><br><span class="line">1 0</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int sum;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">//路径压缩算法</span><br><span class="line">int i = x, j;</span><br><span class="line">while(pre[i] != r)</span><br><span class="line">&#123;</span><br><span class="line">j = pre[r];</span><br><span class="line">pre[i] = r;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, k;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">for(int i = 0; i &lt; n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">int num1, num;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;num1);</span><br><span class="line">k --;</span><br><span class="line">while(k --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">join(num1, num);</span><br><span class="line">num1 = num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">if(find(i) == pre[0]) sum ++;</span><br><span class="line">printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="畅通工程"><a href="#畅通工程" class="headerlink" title="畅通工程"></a>畅通工程</h2><p>Description:<br>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？<br><code>Input</code><br>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>注意:两个城市之间可以有多条道路相通,也就是说<br>3 3<br>1 2<br>1 2<br>2 1<br>这种输入也是合法的<br>当N为0时，输入结束，该用例不被处理。<br><code>Output</code><br>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br><span class="line"></span><br><span class="line">Huge input, scanf is recommended.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int x, y;</span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">join(x, y);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(pre[i] == i)</span><br><span class="line">ans ++; </span><br><span class="line">cout &lt;&lt; ans - 1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="还是畅通工程"><a href="#还是畅通工程" class="headerlink" title="还是畅通工程"></a>还是畅通工程</h2><p>Description:<br>某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。<br><code>Input</code><br>测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。<br>当N为0时，输入结束，该用例不被处理。<br><code>Output</code><br>对每个测试用例，在1行里输出最小的公路总长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">1 4 1</span><br><span class="line">2 3 3</span><br><span class="line">2 4 2</span><br><span class="line">3 4 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">Huge input, scanf is recommended.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int t;</span><br><span class="line">struct node&#123;</span><br><span class="line">int s, e, w;</span><br><span class="line">&#125;e_e[maxx];</span><br><span class="line">int cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">return x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">int kru()</span><br><span class="line">&#123;</span><br><span class="line">int len = t * (t - 1) / 2;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">pre[i] = i;</span><br><span class="line">sort(e_e + 1, e_e + len + 1, cmp);</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(e_e[i].s);</span><br><span class="line">int yy = find(e_e[i].e);</span><br><span class="line">if(xx != yy)</span><br><span class="line">&#123;</span><br><span class="line">ans += e_e[i].w;</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line">if(t == 0) break;</span><br><span class="line">int len = t * (t - 1) / 2;</span><br><span class="line">for(int i = 1; i &lt;= len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d %d&quot;,&amp;e_e[i].s, &amp;e_e[i].e, &amp;e_e[i].w);</span><br><span class="line">&#125;</span><br><span class="line">int ans = kru();</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ubiquitous-Religions"><a href="#Ubiquitous-Religions" class="headerlink" title="Ubiquitous Religions"></a>Ubiquitous Religions</h2><p>Description:<br>There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.</p><p>You know that there are n students in your university (0 &lt; n &lt;= 50000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.<br><code>Input</code><br>The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.<br><code>Output</code><br>For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">1 6</span><br><span class="line">1 7</span><br><span class="line">1 8</span><br><span class="line">1 9</span><br><span class="line">1 10</span><br><span class="line">10 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 8</span><br><span class="line">5 8</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 1</span><br><span class="line">Case 2: 7</span><br><span class="line">Hint</span><br><span class="line">Huge input, scanf is recommended.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">int x, y;</span><br><span class="line">int k = 1;</span><br><span class="line">while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0 &amp;&amp; m == 0) break;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">join(y, x);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(pre[i] == i)</span><br><span class="line">ans ++; </span><br><span class="line">printf(&quot;Case %d: %d\n&quot;,k ++, ans);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cube-Stacking"><a href="#Cube-Stacking" class="headerlink" title="Cube Stacking"></a>Cube Stacking</h2><p>Description:<br>Farmer John and Betsy are playing a game with N (1 &lt;= N &lt;= 30,000)identical cubes labeled 1 through N. They start with N stacks, each containing a single cube. Farmer John asks Betsy to perform P (1&lt;= P &lt;= 100,000) operation. There are two types of operations:<br>moves and counts.</p><ul><li>In a move operation, Farmer John asks Bessie to move the stack containing cube X on top of the stack containing cube Y.</li><li>In a count operation, Farmer John asks Bessie to count the number of cubes on the stack with cube X that are under the cube X and report that value.</li></ul><p>Write a program that can verify the results of the game.<br><code>Input</code></p><ul><li><p>Line 1: A single integer, P</p></li><li><p>Lines 2..P+1: Each of these lines describes a legal operation. Line 2 describes the first operation, etc. Each line begins with a ‘M’ for a move operation or a ‘C’ for a count operation. For move operations, the line also contains two integers: X and Y.For count operations, the line also contains a single integer: X.</p></li></ul><p>Note that the value for N does not appear in the input file. No move operation will request a move a stack onto itself.<br><code>Output</code><br>Print the output from each of the count operations in the same order as the input file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">6</span><br><span class="line">M 1 6</span><br><span class="line">C 1</span><br><span class="line">M 2 4</span><br><span class="line">M 2 6</span><br><span class="line">C 3</span><br><span class="line">C 4</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx], dis[maxx], cnt[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(pre[x] != x)</span><br><span class="line">&#123;</span><br><span class="line">int tmp = pre[x];</span><br><span class="line">pre[x] = find(pre[x]);</span><br><span class="line">dis[x] += dis[tmp];</span><br><span class="line">&#125;</span><br><span class="line">return pre[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">pre[x] = y;</span><br><span class="line">dis[x] += cnt[y];</span><br><span class="line">cnt[y] += cnt[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i = 0; i &lt; 31000; i ++)</span><br><span class="line">&#123;</span><br><span class="line">pre[i] = i;</span><br><span class="line">cnt[i] = 1;</span><br><span class="line">dis[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">char ch;</span><br><span class="line">int a, b;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">if(ch == &apos;M&apos;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a, &amp;b);</span><br><span class="line">if(find(a) != find(b))</span><br><span class="line">join(find(a), find(b));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">find(x);</span><br><span class="line">printf(&quot;%d\n&quot;,dis[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Dragon-Balls"><a href="#Dragon-Balls" class="headerlink" title="Dragon Balls"></a>Dragon Balls</h2><p>Description:<br>Five hundred years later, the number of dragon balls will increase unexpectedly, so it’s too difficult for Monkey King(WuKong) to gather all of the dragon balls together.<br>His country has N cities and there are exactly N dragon balls in the world. At first, for the ith dragon ball, the sacred dragon will puts it in the ith city. Through long years, some cities’ dragon ball(s) would be transported to other cities. To save physical strength WuKong plans to take Flying Nimbus Cloud, a magical flying cloud to gather dragon balls.<br>Every time WuKong will collect the information of one dragon ball, he will ask you the information of that ball. You must tell him which city the ball is located and how many dragon balls are there in that city, you also need to tell him how many times the ball has been transported so far.<br><code>Input</code><br>The first line of the input is a single positive integer T(0 &lt; T &lt;= 100).<br>For each case, the first line contains two integers: N and Q (2 &lt; N &lt;= 10000 , 2 &lt; Q &lt;= 10000).<br>Each of the following Q lines contains either a fact or a question as the follow format:<br>T A B : All the dragon balls which are in the same city with A have been transported to the city the Bth ball in. You can assume that the two cities are different.<br>Q A : WuKong want to know X (the id of the city Ath ball is in), Y (the count of balls in Xth city) and Z (the tranporting times of the Ath ball). (1 &lt;= A, B &lt;= N)<br><code>Output</code><br>For each test case, output the test case number formated as sample output. Then for each query, output a line with three integers X Y Z saparated by a blank space.</p><p><code>题目大意</code>：<br>有标号为1到n的n个龙珠，分别放在对应标号为1到n的n个城市里。<br>下面有两种操作:<br>T A B表示把A龙珠所在城市的所有龙珠都转移到B龙珠所在的城市中<br>Q A 表示查询A，需要知道A龙珠现在所在的城市，A所在的城市有几颗龙珠，A转移到这个城市移动了多少次,分别输出3个整数，表示上述信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">T 1 2</span><br><span class="line">T 3 2</span><br><span class="line">Q 2</span><br><span class="line">3 4</span><br><span class="line">T 1 2</span><br><span class="line">Q 1</span><br><span class="line">T 1 3</span><br><span class="line">Q 1</span><br><span class="line">Sample Output</span><br><span class="line">Case 1:</span><br><span class="line">2 3 0</span><br><span class="line">Case 2:</span><br><span class="line">2 2 1</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><blockquote><p>没写出来，先看着别人的代码和详解吧<br>code:<br><a href="https://blog.csdn.net/CSDN___CSDN/article/details/89424711" target="_blank" rel="noopener">详细链接</a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 10005;</span><br><span class="line"> </span><br><span class="line">int pre[maxn];//pre[i]表示第i个球所在的城市</span><br><span class="line">int sum[maxn];//sum[i]表示第i个城市所拥有的球的个数</span><br><span class="line">int cnt[maxn];//cnt[i]表示第i个球移动了几次</span><br><span class="line">int n,m,root;</span><br><span class="line">char str[3];</span><br><span class="line">//初始化，每一个球原来都呆在自己的城市，所以每一个城市里都只有1个球，每一个球的移动次数都是0。</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;maxn;i++)</span><br><span class="line">&#123;</span><br><span class="line">pre[i] = i;</span><br><span class="line">sum[i] = 1;</span><br><span class="line">cnt[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(x==pre[x])</span><br><span class="line">return x;</span><br><span class="line">int fx = find(pre[x]);</span><br><span class="line">cnt[x] += cnt[pre[x]];</span><br><span class="line">pre[x] = fx;</span><br><span class="line">return fx;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void join(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">int fx = find(x);</span><br><span class="line">int fy = find(y);</span><br><span class="line">if(fy==fx)</span><br><span class="line">return ;</span><br><span class="line">pre[fx] = fy;</span><br><span class="line">sum[fy] += sum[fx];</span><br><span class="line">sum[fx] = 0;</span><br><span class="line">cnt[fx] = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">int T,k=1,i;</span><br><span class="line">int x,y,a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">printf(&quot;Case %d:\n&quot;,k++);</span><br><span class="line">init();</span><br><span class="line">while(m--)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">if(str[0]==&apos;T&apos;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;x,&amp;y);</span><br><span class="line">join(x,y);</span><br><span class="line">&#125;</span><br><span class="line">else if(str[0]==&apos;Q&apos;)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">root = find(a);</span><br><span class="line">printf(&quot;%d %d %d\n&quot;,root,sum[root],cnt[a]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="Zjnu-Stadium"><a href="#Zjnu-Stadium" class="headerlink" title="Zjnu Stadium"></a>Zjnu Stadium</h2><p>Description:<br>In 12th Zhejiang College Students Games 2007, there was a new stadium built in Zhejiang Normal University. It was a modern stadium which could hold thousands of people. The audience Seats made a circle. The total number of columns were 300 numbered 1–300, counted clockwise, we assume the number of rows were infinite.<br>These days, Busoniya want to hold a large-scale theatrical performance in this stadium. There will be N people go there numbered 1–N. Busoniya has Reserved several seats. To make it funny, he makes M requests for these seats: A B X, which means people numbered B must seat clockwise X distance from people numbered A. For example: A is in column 4th and X is 2, then B must in column 6th (6=4+2).<br>Now your task is to judge weather the request is correct or not. The rule of your judgement is easy: when a new request has conflicts against the foregoing ones then we define it as incorrect, otherwise it is correct. Please find out all the incorrect requests and count them as R.<br><code>Input</code><br>There are many test cases:<br>For every case:<br>The first line has two integer N(1&lt;=N&lt;=50,000), M(0&lt;=M&lt;=100,000),separated by a space.<br>Then M lines follow, each line has 3 integer A(1&lt;=A&lt;=N), B(1&lt;=B&lt;=N), X(0&lt;=X&lt;300) (A!=B), separated by a space.</p><p><code>Output</code><br>For every case:<br>Output R, represents the number of incorrect request.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">10 10</span><br><span class="line">1 2 150</span><br><span class="line">3 4 200</span><br><span class="line">1 5 270</span><br><span class="line">2 6 200</span><br><span class="line">6 5 80</span><br><span class="line">4 7 150</span><br><span class="line">8 9 100</span><br><span class="line">4 8 50</span><br><span class="line">1 7 100</span><br><span class="line">9 2 100</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Hint:</span><br><span class="line">（PS： the 5th and 10th requests are incorrect）</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">//题目大意：给你n个人，m个关系，关系表示b在距离a顺时针方向的X距离的地、询问有哪些信息需要改正（也就是错的）。</span><br><span class="line">/*其中A表示a的祖先，B表示b的祖先，suma表示a到A的权值 ，sumb表示b到B的权值，我们已知a，b间距离，那么x也是可求距离。</span><br><span class="line">那么如果两个节点已经连接了，那么如何判断这两个节点之间的距离确实是w呢？直接用sum【b】-sum【a】就能得到a，b之间真实距离，如果和w不等，那么说明这条边需要更改消息。</span><br><span class="line">也就是说output要加1了</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[1000010];</span><br><span class="line">int sum[1000010];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x!=f[x])</span><br><span class="line">    &#123;</span><br><span class="line">//pre是x的一个父节点。</span><br><span class="line">        int pre=f[x];</span><br><span class="line">//递归找祖先。</span><br><span class="line">        f[x]=find(f[x]);</span><br><span class="line">        sum[x]+=sum[pre];</span><br><span class="line">    &#125;</span><br><span class="line">    return f[x];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        int output=0;</span><br><span class="line">        for(int i=0; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=i;</span><br><span class="line">            sum[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x,y,w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);</span><br><span class="line">            int xx=find(x);</span><br><span class="line">            int yy=find(y);</span><br><span class="line">            if(xx==yy)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sum[y]-sum[x]!=w)</span><br><span class="line">                &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                sum[yy]=w-sum[y]+sum[x];</span><br><span class="line">                f[yy]=xx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="How-Many-Tables"><a href="#How-Many-Tables" class="headerlink" title="How Many Tables"></a>How Many Tables</h2><p>Description:<br>Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.</p><p>One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.</p><p>For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least.<br><code>Input</code><br>The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases.<br><code>Output</code><br>For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line"></span><br><span class="line">5 1</span><br><span class="line">2 5</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">int r = x;</span><br><span class="line">while(pre[r] != r)</span><br><span class="line">&#123;</span><br><span class="line">r = pre[r];</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">void join(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">int xx = find(x), yy = find(y);</span><br><span class="line">if(xx != yy)</span><br><span class="line">pre[xx] = yy;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m, T;</span><br><span class="line">int x, y;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T);</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;m);</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) pre[i] = i;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;x, &amp;y);</span><br><span class="line">join(x, y);</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">if(pre[i] == i)</span><br><span class="line">ans ++; </span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day17&quot;&gt;&lt;a href=&quot;#Day17&quot; class=&quot;headerlink&quot; title=&quot;Day17&quot;&gt;&lt;/a&gt;Day17&lt;/h1&gt;&lt;p&gt;今天讲的是并查集和最小生成树&lt;br&gt;&lt;a href=&quot;https://vjudge.net/contest/317297#overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Day16</title>
    <link href="http://yoursite.com/2019/08/03/Day16/"/>
    <id>http://yoursite.com/2019/08/03/Day16/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-04T14:03:47.639Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h1><p>今天是一场积分赛，还行~~<br><a href="https://hpuoj.com/contest/25/" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="蚂蚁觅食（一）"><a href="#蚂蚁觅食（一）" class="headerlink" title="蚂蚁觅食（一）"></a>蚂蚁觅食（一）</h2><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的小蚂蚁发现了好多食物，但是它只有一次搬食物的机会。<br>可因为力气太小了，它不能搬走重量超过自己体重的食物,且只能搬走位置相邻的两个食物，或者只搬走其中一个。<br>食物的位置不会改变。<br>这可难住了这只蚂蚁，它不知道它最多能搬走多重的食物。请帮小蚂蚁计算。<br><code>输入格式</code><br>第一行一个正整数n，(n&gt;=0并且n&lt;=1000)</p><p>第二行n个正整数 A[1]…..A[n]，A[i] 表示在第i 个位置上食物的重量。A[i]&lt;=1e9.</p><p>第三行一个正整数m，表示蚂蚁的体重。(m&lt;=1e9).</p><p><code>输出格式</code><br>一个整数表示小蚂蚁能带走的食物的重量。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">3</span><br><span class="line">1 3 3</span><br><span class="line">4</span><br><span class="line">output</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int w[maxx], v[maxx], dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++) cin &gt;&gt; v[i];</span><br><span class="line">cin &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= v[i]; j --)</span><br><span class="line">dp[j] = max(dp[j], dp[j - v[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[V] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁觅食（二）"><a href="#蚂蚁觅食（二）" class="headerlink" title="蚂蚁觅食（二）"></a>蚂蚁觅食（二）</h2><p>Description:<br>一只饥饿的小蚂蚁外出觅食，幸运的的小蚂蚁发现了好多食物。<br>但是这些食物位于一个N∗M的方格魔法阵的右下角，而小蚂蚁位于方格法阵的左上角。<br>并且小蚂蚁被施展了魔法，它只能向下或者向右走。<br>请你帮助小蚂蚁计算一下，它一共有多少条路可以走到有食物的方格。</p><p><code>输入格式</code><br>多组输入，</p><p>每一组两个正整数N， M （N,M≤30）。表示一个方格魔法阵。</p><p><code>输出格式</code><br>一个整数表示一共有多少条路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2 3</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//dfs般写法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line">ll dp[50][50];</span><br><span class="line">int d[2][2] = &#123;0, 1, 1, 0&#125;;</span><br><span class="line">ll dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[x][y]) return dp[x][y];</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = x + d[i][0];</span><br><span class="line">int yy = y + d[i][1];</span><br><span class="line">if(xx &gt;= 1 &amp;&amp; yy &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m)</span><br><span class="line">dp[x][y] += dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">dp[n][m] = 1;</span><br><span class="line">cout &lt;&lt; dfs(1, 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//dp般写法</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">ll dp[1234][1234];</span><br><span class="line">ll n, m;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(int i = 1; i &lt; 1009; i ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][1] = 1;</span><br><span class="line">dp[1][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">while(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 2; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 2; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁觅食（三）"><a href="#蚂蚁觅食（三）" class="headerlink" title="蚂蚁觅食（三）"></a>蚂蚁觅食（三）</h2><p>Description:<br>马上就要冬天了，勤劳的小蚂蚁需要储存足够多的食物才能安全过冬。<br>今天，这只小蚂蚁走出巢穴寻找食物，但是这次蚁巢周围只有很少的食物，它需要去别的地方。<br>不幸的是小蚂蚁的体力很有限，而且每走一个单位长度就要消耗一点体力，不能找的时间太久，所以想让你帮忙计算一下它是否能用剩下的体力把足够多的食物搬回蚁巢。<br>由于蚂蚁的嘴太小，每次最多只能衔起一个食物。</p><p>输入格式<br>输入t组, t≤20<br>第一行三个数n,E,V表示食物的个数，蚂蚁剩余的体力，安全过冬需要的最少食物体积, 0&lt;n≤200,0&lt;E,V≤10000。<br>接下来n行，每行两个数pi,vi,表示第i个食物的位置和体积,0&lt;p[i],v[i]≤1000。<br>初始蚂蚁和蚁巢均在坐标轴原点。</p><p>输出格式<br>每个输出占一行。<br>如果蚂蚁能安全过冬，输出 “YES”,否则输出”NO”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">1 2 2</span><br><span class="line">1 2</span><br><span class="line">1 2 2</span><br><span class="line">2 1</span><br><span class="line">output</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int w[maxx], v[maxx], dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, E, V;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; E &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = E / 2; j &gt;= w[i]; j --)</span><br><span class="line">dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">if(dp[E / 2] &gt;= V) puts(&quot;YES&quot;);</span><br><span class="line">else puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>##<br>Description:<br>平面上有 n只蚂蚁，它走过的路径可以看作一条直线</p><p>由这n 条直线定义的某些区域是无界的，而另一些区域则是有界的。</p><p>有界区域的最大个数是多少？</p><p>比如现在有4条直线，只有下面最左边的图中直线定义的有界区域是最多的<br><img src="https://i.loli.net/2019/08/04/nNgw1ZJHtWMsipD.png" alt="jay.VpPvtTX2.png"><br><code>输入格式</code><br>T 组输入, (1≤T≤100)</p><p>每组一个数 n ，(1≤n≤109)</p><p><code>输出格式</code><br>对于每组数据，输出一个整数表示有界区域的最大个数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">ll n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">ll ans = 0;</span><br><span class="line">if(n &lt; 3) ans = 0;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">ans = (n - 1) * (n - 2) / 2;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁和斐波那契"><a href="#蚂蚁和斐波那契" class="headerlink" title="蚂蚁和斐波那契"></a>蚂蚁和斐波那契</h2><p>Description:<br>聪明的小蚂蚁最近学习了斐波那契数列,但是它想到了一个问题：<br>从L到R之间斐波那契数列和的奇偶是什么呢？<br>其中Fib[1]=1,Fib[2]=1 .</p><p><code>输入格式</code><br>单组输入:<br>每组输入两个以空格隔开的数字 L 和 R<br>其中 (0&lt;L&lt;=R&lt;1018)</p><p><code>输出格式</code><br>从 L 到 R 斐波那契数列和的奇偶，如果是奇数输出 “1” (不带引号) ，否则输出 “0” (不带引号)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">1 2</span><br><span class="line">output</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll ans[55];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll mid,miid,l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">mid=l%3,miid=r%3;</span><br><span class="line">if(mid==0&amp;&amp;miid==0)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==miid)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==0&amp;&amp;miid==1)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==0&amp;&amp;miid==2)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==1&amp;&amp;miid==0)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==2&amp;&amp;miid==0)puts(&quot;1&quot;);</span><br><span class="line">else if(mid==2&amp;&amp;miid==1)puts(&quot;0&quot;);</span><br><span class="line">else if(mid==1&amp;&amp;miid==2)puts(&quot;0&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁装修"><a href="#蚂蚁装修" class="headerlink" title="蚂蚁装修"></a>蚂蚁装修</h2><p>Description:<br>还有一个月就开学了，爱学习的小蚂蚁想庆祝一下！于是它要把它的“家”装修一下。<br>首先要做的就是贴地板。<br>小蚂蚁“家”的地面可以看成一个2∗N 的方格 ，它拥有无数块1∗2 和 2∗1的地板。<br>请你帮下蚂蚁计算一下一共有多少种方法能把地面给放满 。<br>地板不能切割，也不能重叠。</p><p><code>输入格式</code><br>单组输入：<br>只有一个数字 N<br>其中 (0&lt;N&lt;1018)</p><p><code>输出格式</code><br>输出放法数对109+7取模的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">output</span><br><span class="line">2</span><br><span class="line">input</span><br><span class="line">1</span><br><span class="line">output</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">const int maxx = 4;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll m[maxx][maxx];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.m, 0, sizeof ans.m);</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 2; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; 2; k ++)</span><br><span class="line">ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node kpow(node a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.m, 0, sizeof res.m);</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">res.m[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">node a, b, ans;</span><br><span class="line">a.m[0][0] = 2; a.m[0][1] = 0;</span><br><span class="line">a.m[1][0] = 1; a.m[1][1] = 0;</span><br><span class="line">b.m[0][0] = 1; b.m[0][1] = 1;</span><br><span class="line">b.m[1][0] = 1; b.m[1][1] = 0;</span><br><span class="line">if(n == 1) ans.m[0][0] = 1;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">ans = kpow(b, n - 2);</span><br><span class="line">ans = mul(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans.m[0][0] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁的镜像串"><a href="#蚂蚁的镜像串" class="headerlink" title="蚂蚁的镜像串"></a>蚂蚁的镜像串</h2><p>Description:<br>一只聪明的蚂蚁在学习了回文串之后，一直觉得回文串不够优美，所以它决定自己定义一种新的字符串——镜像串</p><p>所谓镜像串，就是对一个字符串进行一整个完全的翻转后，得到的新字符串与原字符串相同，也就是说左右镜像之后的字符串和原串相同。例如：AA就是一个镜像串,bb不是镜像串</p><p>现在给你一个字符串S，请你快速的判断字符串S是不是一个镜像串</p><p>字符串中出现的字母字体如下表</p><p><code>输入格式</code><br>第一行一个整数T (1≤T≤100)代表有T组输入</p><p>接下来T行，每行输入一个长度小于等于105的字符串S<br>保证每个字符串只包含大小写字母</p><p><code>输出格式</code><br>对于每组输入，判断S是否为镜像串</p><p>如果是，输出”YES”。否则输出”NO”。</p><p>每组输出占一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">5</span><br><span class="line">QAQ</span><br><span class="line">TAT</span><br><span class="line">oUo</span><br><span class="line">oVo</span><br><span class="line">XoX</span><br><span class="line">output</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">YES</span><br><span class="line">提示</span><br><span class="line">mm,nn,uu也是镜像串</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">int flag=1;</span><br><span class="line"> string mid=s;</span><br><span class="line"> reverse(mid.begin(),mid.end());</span><br><span class="line">for(int i=0;i&lt;s.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">if((s[i]==&apos;b&apos;&amp;&amp;mid[i]==&apos;d&apos;)||(s[i]==&apos;d&apos;&amp;&amp;mid[i]==&apos;b&apos;)||(s[i]==&apos;p&apos;&amp;&amp;mid[i]==&apos;q&apos;)||(s[i]==&apos;q&apos;&amp;&amp;mid[i]==&apos;p&apos;)||(s[i]==mid[i]&amp;&amp;(s[i]==&apos;A&apos;||s[i]==&apos;H&apos;||s[i]==&apos;I&apos;||s[i]==&apos;i&apos;||s[i]==&apos;l&apos;||s[i]==&apos;M&apos;||s[i]==&apos;m&apos;||s[i]==&apos;n&apos;||s[i]==&apos;O&apos;||s[i]==&apos;o&apos;||s[i]==&apos;T&apos;||s[i]==&apos;U&apos;||s[i]==&apos;u&apos;||s[i]==&apos;V&apos;||s[i]==&apos;v&apos;||s[i]==&apos;W&apos;||s[i]==&apos;w&apos;||s[i]==&apos;X&apos;||s[i]==&apos;x&apos;||s[i]==&apos;Y&apos;)))</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">flag=0;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag==1)puts(&quot;YES&quot;);</span><br><span class="line">elseputs(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁赛跑"><a href="#蚂蚁赛跑" class="headerlink" title="蚂蚁赛跑"></a>蚂蚁赛跑</h2><p>Description:<br>小白和小黑非常喜欢养蚂蚁，他们每个人都养了n只蚂蚁。<br>有一天，他们想比一比谁养蚂蚁的本领更强，于是就举办了一场蚂蚁赛跑比赛。假设蚂蚁都是匀速直线奔跑。<br>比赛的规则是这样的：每只蚂蚁必须且最多比一场，赢一场得10分，输一场扣10分。平局都不得分也不扣分。<br>狡猾的小黑同学为了赢得比赛，提前偷到了小白所有蚂蚁得速度，请你帮小黑算一算，他在比赛中最多得多少分。</p><p><code>输入格式</code><br>有多组测试案例，最多有100组，对于每一组案例：<br>第一行以正整数n ,（n≤1000），即每个人的蚂蚁数量。<br>第二行的n个整数是小黑的蚂蚁的速度。<br>第三行的n整数是小白的蚂蚁速度。<br>蚂蚁的速度小于100</p><p><code>输出格式</code><br>对于每个输入案例，输出一个整数，这是小黑能够获得的最大分数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">10 10</span><br><span class="line">2</span><br><span class="line">10 1</span><br><span class="line">100 8</span><br><span class="line">output</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁上树"><a href="#蚂蚁上树" class="headerlink" title="蚂蚁上树"></a>蚂蚁上树</h2><p>Description:<br>蚂蚁想知道这棵树上距离最远的两个点之间的距离</p><p>给你一个具有 n 个节点的树</p><p>求这棵树上距离最远的两个点之间的距离</p><p>输入格式<br>第一行一个整数 n ，(1≤n≤104)</p><p>接下来 n−1 行，每行三个整数 x,y,z 表示 x 与 y 之间有一条长度为 z 的边 (1≤x,y≤n,1≤z≤104)</p><p>输出格式<br>一个整数表示树上距离最远的两个点之间的距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">5</span><br><span class="line">1 2 9</span><br><span class="line">1 3 3</span><br><span class="line">1 5 2</span><br><span class="line">2 4 10</span><br><span class="line">output</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e4 + 10;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; v[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int ans, point;</span><br><span class="line">//struct node&#123;</span><br><span class="line">//int x, y, step;</span><br><span class="line">//&#125;;</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">//node e1, e2;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x] = 1;</span><br><span class="line">ans = 0;</span><br><span class="line">point = 0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[f] &gt; ans)</span><br><span class="line">&#123;</span><br><span class="line">ans = dis[f];</span><br><span class="line">point = f;</span><br><span class="line">//return ans;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;int, int&gt; t;</span><br><span class="line">for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">t = v[f][i];</span><br><span class="line">if(vis[t.first] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[t.first] = 1;</span><br><span class="line">dis[t.first] = t.second + dis[f];</span><br><span class="line">q.push(t.first);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">int a, b, c;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">v[a].push_back(make_pair(b, c));</span><br><span class="line">v[b].push_back(make_pair(a, c));</span><br><span class="line">&#125;</span><br><span class="line">bfs(1);</span><br><span class="line">bfs(point);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蚂蚁的游戏"><a href="#蚂蚁的游戏" class="headerlink" title="蚂蚁的游戏"></a>蚂蚁的游戏</h2><p>Description:<br>蚂蚁Bob和蚂蚁Alice是青梅竹蚁，Alice喜欢和Bob一起玩游戏，每当Alice想到新的游戏，都会找Bob一起玩</p><p>今天Alice的游戏是这样的：</p><p>n堆石子，两人轮流取。每次只能在1堆中取，不能不取，最先取完石子者胜</p><p>Alice先取石子，Alice和Bob都非常聪明，拿石子的过程中不会出现失误。</p><p><code>输入格式</code><br>第一行有一个整数T，有T组输入数据(T≤50)</p><p>每组第一行有一个数n表示有n堆石子，(1≤n≤20000)</p><p>第二行有n个非零整数x，表示每堆石子的数量(x≤103)</p><p><code>输出格式</code><br>请你判断Alice能否在游戏中获胜，如果不能获胜，输出NO。</p><p>否则，输出YES，并输出第一次取石子的所有方法（具体参见样例和提示）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">样例</span><br><span class="line">input</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">45 45</span><br><span class="line">5</span><br><span class="line">5 7 8 9 10</span><br><span class="line">output</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">3 1</span><br><span class="line">4 0</span><br><span class="line">5 3</span><br><span class="line">提示</span><br><span class="line">对于第一组样例，不论Alice怎么取，Bob总能拿到最后一个石子，所以输出为NO</span><br><span class="line"></span><br><span class="line">对于第二组样例，Alice可以第一次取石子有三种取法：</span><br><span class="line"></span><br><span class="line">第3堆取出7个，剩下1个</span><br><span class="line">第4堆全部取出，剩下0个</span><br><span class="line">第5堆取出7个，剩下3个</span><br><span class="line">对于每组输出，总是按照堆的编号顺序输出的</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day16&quot;&gt;&lt;a href=&quot;#Day16&quot; class=&quot;headerlink&quot; title=&quot;Day16&quot;&gt;&lt;/a&gt;Day16&lt;/h1&gt;&lt;p&gt;今天是一场积分赛，还行~~&lt;br&gt;&lt;a href=&quot;https://hpuoj.com/contest/25/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>Day15</title>
    <link href="http://yoursite.com/2019/08/02/Day15/"/>
    <id>http://yoursite.com/2019/08/02/Day15/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-08-04T13:02:08.134Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:11:59 GMT+0800 (GMT+08:00) --><h1 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h1><p>今天继续学习背包问题，刷题~刷题~刷题！<br><a href="https://www.acwing.com/problem/" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>Description:<br>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。</p><p><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">输出样例：</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int v[10001], w[10001];</span><br><span class="line">int dp[10001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= w[i]; j --)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">//下面的是没优化的部分</span><br><span class="line">//if(j &gt;= w[i])</span><br><span class="line">//dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">//else</span><br><span class="line">//dp[i][j] = dp[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[V];</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>Description:<br>有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。</p><p>第 i 种物品的体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。<br><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N,V≤1000<br>0&lt;vi,wi≤1000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">输出样例：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int w[10001], v[10001];</span><br><span class="line">int dp[10001][10001];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= V; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &gt;= w[i])</span><br><span class="line">dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">else</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[N][V] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="多重背包1"><a href="#多重背包1" class="headerlink" title="多重背包1"></a>多重背包1</h2><p>Description:<br>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N,V≤100<br>0&lt;vi,wi,si≤100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br><span class="line">输出样例：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int f = 300;</span><br><span class="line">int w[f], v[f], c[f];</span><br><span class="line">int dp[f][f];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= 0; j --)</span><br><span class="line">&#123;</span><br><span class="line">//其实就是把这类物品展开，调用c[i]次01背包代码</span><br><span class="line">for(int k = 0; k &lt;= c[i]; k ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &gt;= w[i] * k)</span><br><span class="line">dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i] * k] + v[i] * k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[N][V] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="多重背包2-用二进制优化"><a href="#多重背包2-用二进制优化" class="headerlink" title="多重背包2(用二进制优化)"></a>多重背包2(用二进制优化)</h2><p>Description:<br>有 N 种物品和一个容量是 V 的背包。</p><p>第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。</p><p>求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。<br>输出最大价值。</p><p><code>输入格式</code><br>第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</p><p>接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</p><p><code>输出格式</code><br>输出一个整数，表示最大价值。</p><p>数据范围<br>0&lt;N≤1000<br>0&lt;V≤2000<br>0&lt;vi,wi,si≤2000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">2 4 1</span><br><span class="line">3 4 3</span><br><span class="line">4 5 2</span><br><span class="line">输出样例：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int w[1001], v[1001], c[1001], dp[2001];</span><br><span class="line">int a[25000], b[25000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int N, V;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">for(int i = 0; i &lt; N; i ++)</span><br><span class="line">cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; c[i];</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0; i &lt; N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt; c[i]; j &lt;&lt;= 1)</span><br><span class="line">&#123;</span><br><span class="line">a[sum] = j * w[i];//存储容量 </span><br><span class="line">b[sum ++] = j * v[i];//存储价值</span><br><span class="line">c[i] -= j; </span><br><span class="line">&#125;</span><br><span class="line">if(c[i])</span><br><span class="line">&#123;</span><br><span class="line">a[sum] = c[i] * w[i];</span><br><span class="line">b[sum ++] = c[i] * v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; sum; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = V; j &gt;= a[i]; j --)</span><br><span class="line">dp[j] = max(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[V] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="掺杂个字符串的题-混入其中"><a href="#掺杂个字符串的题-混入其中" class="headerlink" title="掺杂个字符串的题(混入其中)"></a>掺杂个字符串的题(混入其中)</h2><p><a href="https://www.luogu.org/problem/P1055" target="_blank" rel="noopener">ISBN号码-字符串的题</a><br>Description:<br>每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括99位数字、11位识别码和33位分隔符，其规定格式如x-xxx-xxxxx-x，其中符号-就是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符-之后的三位数字代表出版社，例如670670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。</p><p>识别码的计算方法如下：</p><p>首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1,2,…,9再求和，即0×1+6×2+……+2×9=158，然后取158mod11的结果4作为识别码。</p><p>你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出Right；如果错误，则输出你认为是正确的ISBN号码。</p><p>输入格式<br>一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。</p><p>输出格式<br>一行，假如输入的ISBN号码的识别码正确，那么输出Right，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符-）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入输出样例</span><br><span class="line">输入</span><br><span class="line">0-670-82162-4</span><br><span class="line">输出</span><br><span class="line">Right</span><br><span class="line">输入</span><br><span class="line">0-670-82162-0</span><br><span class="line">输出</span><br><span class="line">0-670-82162-4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char str[13], a[12] = &#123;&quot;0123456789X&quot;&#125;;</span><br><span class="line">gets(str);</span><br><span class="line">int sum = 0;</span><br><span class="line">for(int i = 0, len = 1; i &lt; 12; i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(str[i] == &apos;-&apos;)</span><br><span class="line">continue;</span><br><span class="line">sum += (str[i] - &apos;0&apos;)* len;</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line">sum %= 11;</span><br><span class="line">if(a[sum] == str[12])</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;Right&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">str[12] = a[sum];</span><br><span class="line">puts(str);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:11:59 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day15&quot;&gt;&lt;a href=&quot;#Day15&quot; class=&quot;headerlink&quot; title=&quot;Day15&quot;&gt;&lt;/a&gt;Day15&lt;/h1&gt;&lt;p&gt;今天继续学习背包问题，刷题~刷题~刷题！&lt;br&gt;&lt;a href=&quot;https://www.acwing.com/problem/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OJ链接&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Day14</title>
    <link href="http://yoursite.com/2019/08/01/Day14/"/>
    <id>http://yoursite.com/2019/08/01/Day14/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-05T14:33:13.052Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h1><p>今天讲的是矩阵快速幂<br>相比于之前，算是好理解一点~<br><a id="more"></a></p><h2 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h2><p>就比如Fib<br>Fib[i] = Fib[i-1] + Fib[i-2]<br>int Fib[maxn] ;<br>Fib[1] = 1 ,Fib[2] = 1 ;<br>for (int i = 3 ; i &lt;= n ; i ++ ) {<br>Fib[i] = Fib[i-1] + Fib[i-2] ;<br>}</p><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p><a href="https://blog.csdn.net/MosBest/article/details/69264953" target="_blank" rel="noopener">链接</a></p><h2 id="矩阵的迹"><a href="#矩阵的迹" class="headerlink" title="矩阵的迹"></a>矩阵的迹</h2><p>在线性代数中，一个n×n矩阵A的主对角线（从左上方至右下方的对角线）上各个元素的总和被称为矩阵A的迹（或迹数），一般记作tr(A)。</p><h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>Description:<br>菲波那契数列是指这样的数列: 数列的第一个是0和第二个数是1，接下来每个数都等于前面2个数之和。 给出一个正整数a，要求菲波那契数列中第a个数的后四位是多少。<br><code>Input</code><br>多组数据 -1结束 范围1~10^9<br><code>Output</code><br>第x项的后4位<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">0</span><br><span class="line">9</span><br><span class="line">999999999</span><br><span class="line">1000000000</span><br><span class="line">-1</span><br><span class="line">Sample Output</span><br><span class="line">0</span><br><span class="line">34</span><br><span class="line">626</span><br><span class="line">6875</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 10000;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int N, M;</span><br><span class="line">int f = 2;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(ll i = 1; i &lt;= f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j = 1; j &lt;= f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll k = 1; k &lt;= f; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(ll i = 1; i &lt;= f; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, a, b;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;N))</span><br><span class="line">&#123;</span><br><span class="line">if(N == -1) break;</span><br><span class="line">if(N == 0)</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;0&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">a.materix[1][1] = 1 ; a.materix[1][2] = 0 ;</span><br><span class="line">a.materix[2][1] = 1 ; a.materix[2][2] = 0 ;</span><br><span class="line">b.materix[1][1] = 1 ; b.materix[1][2] = 1 ;</span><br><span class="line">b.materix[2][1] = 1 ; b.materix[2][2] = 0 ;</span><br><span class="line">ans = kpow(b, N - 2);</span><br><span class="line">ans = mul(ans, a);</span><br><span class="line">cout &lt;&lt; ans.materix[1][1] % 10000 &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Tr-A"><a href="#Tr-A" class="headerlink" title="Tr A"></a>Tr A</h2><p>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。<br><code>Input</code><br>数据的第一行是一个T，表示有T组数据。<br>每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt; 10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。<br><code>Output</code><br>对应每组数据，输出Tr(A^k)%9973。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">3 99999999</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">2686</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 9973;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll N, M;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= N; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, b;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">ll sum;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">sum = 0;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; b.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">ans = kpow(b, M - 1);</span><br><span class="line">ans = mul(ans, b);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">sum = (sum + ans.materix[i][i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A-Simple-Math-Problem"><a href="#A-Simple-Math-Problem" class="headerlink" title="A Simple Math Problem"></a>A Simple Math Problem</h2><p>Description:<br>Lele now is thinking about a simple function f(x).</p><p>If x &lt; 10 f(x) = x.<br>If x &gt;= 10 f(x) = a0 <em>f(x-1) + a1 </em>f(x-2) + a2 <em>f(x-3) + …… + a9 </em>f(x-10);<br>And ai(0&lt;=i&lt;=9) can only be 0 or 1 .</p><p>Now, I will give a0 ~ a9 and two positive integers k and m ,and could you help Lele to caculate f(k)%m.<br><code>Input</code><br>The problem contains mutiple test cases.Please process to the end of file.<br>In each case, there will be two lines.<br>In the first line , there are two positive integers k and m. ( k&lt;2*10^9 , m &lt; 10^5 )<br>In the second line , there are ten integers represent a0 ~ a9.<br><code>Output</code><br>For each case, output f(k) % m in one line.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">10 9999</span><br><span class="line">1 1 1 1 1 1 1 1 1 1</span><br><span class="line">20 500</span><br><span class="line">1 0 1 0 1 0 1 0 1 0</span><br><span class="line">Sample Output</span><br><span class="line">45</span><br><span class="line">104</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">int m;</span><br><span class="line">int f = 10;</span><br><span class="line">int x[10];</span><br><span class="line">struct node&#123;</span><br><span class="line">int materix[10][10];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; f; k ++)</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % m) % m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//矩阵快速幂 </span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, a, b, s;</span><br><span class="line">int n;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">cin &gt;&gt; x[i];</span><br><span class="line">if(n &lt; 10) ans.materix[0][0] = n % m;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">memset(a.materix, 0, sizeof a.materix);</span><br><span class="line">memset(b.materix, 0, sizeof b.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a.materix[i][0] = 10 - 1 - i;</span><br><span class="line">b.materix[0][i] = x[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt; 10; i ++)</span><br><span class="line">b.materix[i][i - 1] = 1;</span><br><span class="line">ans = kpow(b, n - 9);</span><br><span class="line">ans = mul(ans, a);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans.materix[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Recursive-sequence"><a href="#Recursive-sequence" class="headerlink" title="Recursive sequence"></a>Recursive sequence</h2><p>Description:<br>Farmer John likes to play mathematics games with his N cows. Recently, they are attracted by recursive sequences. In each turn, the cows would stand in a line, while John writes two positive numbers a and b on a blackboard. And then, the cows would say their identity number one by one. The first cow says the first number a and the second says the second number b. After that, the i-th cow says the sum of twice the (i-2)-th number, the (i-1)-th number, and i4. Now, you need to write a program to calculate the number of the N-th cow in order to check if John’s cows can make it right.<br><code>Input</code><br>The first line of input contains an integer t, the number of test cases. t test cases follow.<br>Each case contains only one line with three numbers N, a and b where N,a,b &lt; 231 as described above.<br><code>Output</code><br>For each test case, output the number of the N-th cow. This number might be very large, so you need to output it modulo 2147493647.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 1 2</span><br><span class="line">4 1 10</span><br><span class="line">Sample Output</span><br><span class="line">85</span><br><span class="line">369</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">In the first case, the third number is 85 = 2*1十2十3^4.</span><br><span class="line"> In the second case, the third number is 93 = 2*1十1*10十3^4 and the fourth number is 369 = 2 * 10 十 93 十 4^4.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod = 2147493647;</span><br><span class="line">const ll f = 7;</span><br><span class="line">ll n, x, y;</span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[f][f];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 0; i &lt; f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 0; k &lt; f; k ++)</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 0; i &lt; 7; i ++)</span><br><span class="line">for(int j = 0; j &lt; 7; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(i == j) res.materix[i][j] = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll T;</span><br><span class="line">node a, b, ans;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">if(n == 1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else if(n == 2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">memset(a.materix, 0, sizeof a.materix);</span><br><span class="line">memset(b.materix, 0, sizeof b.materix);</span><br><span class="line">a.materix[0][0]=1,a.materix[0][1]=2,a.materix[0][2]=1,a.materix[0][3]=0,a.materix[0][4]=0,a.materix[0][5]=0;a.materix[0][6]=0;</span><br><span class="line">        a.materix[1][0]=1,a.materix[1][1]=0,a.materix[1][2]=0,a.materix[1][3]=0,a.materix[1][4]=0,a.materix[1][5]=0;a.materix[1][6]=0;</span><br><span class="line">        a.materix[2][0]=0,a.materix[2][1]=0,a.materix[2][2]=1,a.materix[2][3]=4,a.materix[2][4]=6,a.materix[2][5]=4;a.materix[2][6]=1;</span><br><span class="line">        a.materix[3][0]=0,a.materix[3][1]=0,a.materix[3][2]=0,a.materix[3][3]=1,a.materix[3][4]=3,a.materix[3][5]=3;a.materix[3][6]=1;</span><br><span class="line">        a.materix[4][0]=0,a.materix[4][1]=0,a.materix[4][2]=0,a.materix[4][3]=0,a.materix[4][4]=1,a.materix[4][5]=2;a.materix[4][6]=1;</span><br><span class="line">        a.materix[5][0]=0,a.materix[5][1]=0,a.materix[5][2]=0,a.materix[5][3]=0,a.materix[5][4]=0,a.materix[5][5]=1;a.materix[5][6]=1;</span><br><span class="line">        a.materix[6][0]=0,a.materix[6][1]=0,a.materix[6][2]=0,a.materix[6][3]=0,a.materix[6][4]=0,a.materix[6][5]=0;a.materix[6][6]=1;</span><br><span class="line">        b.materix[0][0]=y % mod;</span><br><span class="line">        b.materix[1][0]=x % mod;</span><br><span class="line">        b.materix[2][0]=81;</span><br><span class="line">        b.materix[3][0]=27;</span><br><span class="line">        b.materix[4][0]=9;</span><br><span class="line">        b.materix[5][0]=3;</span><br><span class="line">        b.materix[6][0]=1;</span><br><span class="line">        ans = kpow(a, n - 2);</span><br><span class="line">        ans = mul(ans, b);</span><br><span class="line">        cout &lt;&lt; ans.materix[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="求递推序列的第N项"><a href="#求递推序列的第N项" class="headerlink" title="求递推序列的第N项"></a>求递推序列的第N项</h2><p>有一个序列是这样定义的：f(1) = 1, f(2) = 1, f(n) = (A <em>f(n - 1) + B </em>f(n - 2)) mod 7.<br>给出A，B和N，求f(n)的值。</p><p><code>输入</code><br>输入3个数：A,B,N。数字之间用空格分割。(-10000 &lt;= A, B &lt;= 10000, 1 &lt;= N &lt;= 10^9)<br><code>输出</code><br>输出f(n)的值。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">3 -1 5</span><br><span class="line">输出样例</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">int f = 2;</span><br><span class="line">const int mod = 7;</span><br><span class="line">struct node&#123;</span><br><span class="line">int materix[5][5];</span><br><span class="line">&#125;; </span><br><span class="line">//矩阵乘法</span><br><span class="line">node nul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= f; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= f; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= f; k ++)</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans; </span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">memset(res.materix, 0, sizeof res.materix);</span><br><span class="line">for(int i = 1; i &lt;= f ;i ++)</span><br><span class="line">res.materix[i][i] = 1; </span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = nul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = nul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int A, B, N;</span><br><span class="line">cin &gt;&gt; A &gt;&gt; B &gt;&gt; N;</span><br><span class="line">node a, b;</span><br><span class="line">if(N == 1 || N == 1)</span><br><span class="line">puts(&quot;1&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a.materix[1][1] = 1; a.materix[1][2] = 0;</span><br><span class="line">a.materix[2][1] = 1; a.materix[2][2] = 0;</span><br><span class="line">b.materix[1][1] = A; b.materix[1][2] = B;</span><br><span class="line">b.materix[2][1] = 1; b.materix[2][2] = 0;</span><br><span class="line">node ans = kpow(b, N - 2);</span><br><span class="line">ans = nul(ans, a);</span><br><span class="line">cout &lt;&lt; ans.materix[1][1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="矩阵快速幂-1"><a href="#矩阵快速幂-1" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>Description:</p><p>给出一个N <em>N的矩阵，其中的元素均为正整数。求这个矩阵的M次方。由于M次方的计算结果太大，只需要输出每个元素Mod (10^9 + 7）的结果。<br><code>输入</code><br>第1行：2个数N和M，中间用空格分隔。N为矩阵的大小，M为M次方。(2 &lt;= N &lt;= 100, 1 &lt;= M &lt;= 10^9)<br>第2 - N + 1行：每行N个数，对应N </em>N矩阵中的1行。(0 &lt;= N[i] &lt;= 10^9)<br><code>输出</code><br>共N行，每行N个数，对应M次方Mod (10^9 + 7)的结果。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">2 3</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">输出样例</span><br><span class="line">4 4</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int N, M;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= N; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">//矩阵快速幂</span><br><span class="line">node kpow(node a, int b)</span><br><span class="line">&#123;</span><br><span class="line">node res;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">res.materix[i][i] = 1;</span><br><span class="line">while(b)</span><br><span class="line">&#123;</span><br><span class="line">if(b &amp; 1) res = mul(res, a);</span><br><span class="line">b &gt;&gt;= 1;</span><br><span class="line">a = mul(a, a);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, b;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; b.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = kpow(b, M - 1);</span><br><span class="line">ans = mul(ans, b);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cout &lt;&lt; ans.materix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>Description:<br>给出2个N <em>N的矩阵M1和M2，输出2个矩阵相乘后的结果。<br><code>输入</code><br>第1行：1个数N，表示矩阵的大小(2 &lt;= N &lt;= 100)<br>第2 - N + 1行，每行N个数，对应M1的1行(0 &lt;= M1[i] &lt;= 1000)<br>第N + 2 - 2N + 1行，每行N个数，对应M2的1行(0 &lt;= M2[i] &lt;= 1000)<br><code>输出</code><br>输出共N行，每行N个数，对应M1 </em>M2的结果的一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入样例</span><br><span class="line">2</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">输出样例</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int N, M;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">ll materix[101][101];</span><br><span class="line">&#125;;</span><br><span class="line">//矩阵乘法</span><br><span class="line">node mul(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">node ans;</span><br><span class="line">memset(ans.materix, 0, sizeof ans.materix);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= N; k ++)</span><br><span class="line">&#123;</span><br><span class="line">ans.materix[i][j] = (ans.materix[i][j] + a.materix[i][k] * b.materix[k][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125; </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">node ans, a, b;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; a.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cin &gt;&gt; b.materix[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = mul(a, b);</span><br><span class="line">for(int i = 1; i &lt;= N; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= N; j ++)</span><br><span class="line">cout &lt;&lt; ans.materix[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day14&quot;&gt;&lt;a href=&quot;#Day14&quot; class=&quot;headerlink&quot; title=&quot;Day14&quot;&gt;&lt;/a&gt;Day14&lt;/h1&gt;&lt;p&gt;今天讲的是矩阵快速幂&lt;br&gt;相比于之前，算是好理解一点~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="矩阵快速幂" scheme="http://yoursite.com/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="http://yoursite.com/2019/07/31/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <id>http://yoursite.com/2019/07/31/背包九讲/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T15:22:58.048Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a><center>背包九讲</center></h1><p><center>学习背包问题，肯定是要学习背包就讲的，这篇就整理一个全一点的背包九讲<br>背包问题在实际问题中还是比较重要的<br>记录下来问题多多复习<br>争取熟练掌握<br><img src="/2019/07/31/背包九讲/1.jpg" alt></center></p><a id="more"></a><p><code>以下内容皆是参考的别人的博客内容整理而成</code></p><h2 id="P01-01背包问题"><a href="#P01-01背包问题" class="headerlink" title="P01: 01背包问题"></a>P01: 01背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本思路 </span><br><span class="line">这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 </span><br><span class="line"></span><br><span class="line">用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;。 </span><br><span class="line"></span><br><span class="line">这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。 </span><br><span class="line"></span><br><span class="line">注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </span><br><span class="line"></span><br><span class="line">优化空间复杂度 </span><br><span class="line">以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 </span><br><span class="line"></span><br><span class="line">先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1] [v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v -c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i -1][v-c[i]]的值。伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line">其中的f[v]=max&#123;f[v],f[v-c[i]]&#125;一句恰就相当于我们的转移方程f[i][v]=max&#123;f[i-1][v],f[i- 1][v-c[i]]&#125;，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</span><br></pre></td></tr></table></figure><h2 id="P02-完全背包问题"><a href="#P02-完全背包问题" class="headerlink" title="P02: 完全背包问题"></a>P02: 完全背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本思路 </span><br><span class="line">这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;= v&#125;。这跟01背包问题一样有O(N*V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 </span><br><span class="line"></span><br><span class="line">将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 </span><br><span class="line"></span><br><span class="line">一个简单有效的优化 </span><br><span class="line">完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题求解 </span><br><span class="line">既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c [i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 </span><br><span class="line"></span><br><span class="line">更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。 * O(VN)的算法这个算法使用一维数组，先看伪代码： &lt;pre class&quot;example&quot;&gt; for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 </span><br><span class="line"></span><br><span class="line">这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max&#123;f[i-1][v],f[i][v-c[i]]+w[i]&#125;，将这个方程用一维数组实现，便得到了上面的伪代码。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</span><br></pre></td></tr></table></figure><h2 id="P03-多重背包问题"><a href="#P03-多重背包问题" class="headerlink" title="P03: 多重背包问题"></a>P03: 多重背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本算法 </span><br><span class="line">这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取 n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max&#123;f[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]&#125;。复杂度是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题 </span><br><span class="line">另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 </span><br><span class="line"></span><br><span class="line">方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 </span><br><span class="line"></span><br><span class="line">分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 </span><br><span class="line"></span><br><span class="line">这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 </span><br><span class="line"></span><br><span class="line">O(VN)的算法 </span><br><span class="line">多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">这里我们看到了将一个算法的复杂度由O(V*∑n[i])改进到O(V*∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</span><br></pre></td></tr></table></figure><h2 id="P04-混合三种背包问题"><a href="#P04-混合三种背包问题" class="headerlink" title="P04: 混合三种背包问题"></a>P04: 混合三种背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">问题 </span><br><span class="line">如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？ </span><br><span class="line"></span><br><span class="line">01背包与完全背包的混合 </span><br><span class="line">考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN)。伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">if 第i件物品是01背包 </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line">else if 第i件物品是完全背包 </span><br><span class="line">for v=0..V </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line">再加上多重背包 </span><br><span class="line">如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n[i])个01背包的物品的方法也已经很优了。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。</span><br></pre></td></tr></table></figure><h2 id="P05-二维费用的背包问题"><a href="#P05-二维费用的背包问题" class="headerlink" title="P05: 二维费用的背包问题"></a>P05: 二维费用的背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">问题 </span><br><span class="line">二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。 </span><br><span class="line"></span><br><span class="line">算法 </span><br><span class="line">费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：f [i][v][u]=max&#123;f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]&#125;。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用顺序的循环，当物品有如完全背包问题时采用逆序的循环。当物品有如多重背包问题时拆分物品。 </span><br><span class="line"></span><br><span class="line">物品总个数的限制 </span><br><span class="line">有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。 </span><br><span class="line"></span><br><span class="line">另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一纬以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。</span><br></pre></td></tr></table></figure><h2 id="P06-分组的背包问题"><a href="#P06-分组的背包问题" class="headerlink" title="P06: 分组的背包问题"></a>P06: 分组的背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">问题 </span><br><span class="line">有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">算法 </span><br><span class="line">这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]=max&#123;f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于第k组&#125;。 </span><br><span class="line"></span><br><span class="line">使用一维数组的伪代码如下： </span><br><span class="line"></span><br><span class="line">for 所有的组k </span><br><span class="line">for 所有的i属于组k </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125; </span><br><span class="line"></span><br><span class="line">另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。</span><br></pre></td></tr></table></figure><h2 id="P07-有依赖的背包问题"><a href="#P07-有依赖的背包问题" class="headerlink" title="P07: 有依赖的背包问题"></a>P07: 有依赖的背包问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">简化的问题 </span><br><span class="line">这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。 </span><br><span class="line"></span><br><span class="line">算法 </span><br><span class="line">这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。 </span><br><span class="line"></span><br><span class="line">按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。） </span><br><span class="line"></span><br><span class="line">考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 </span><br><span class="line"></span><br><span class="line">再考虑P06中的一句话：可以对每组中的物品应用P02中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c[i]所有这些值时相应的最大价值f&apos;[0..V-c[i]]。那么这个主件及它的附件集合相当于V-c[i]+1个物品的物品组，其中费用为c[i]+k的物品的价值为f&apos;[k]+w[i]。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-c[i]+1个物品的物品组，就可以直接应用P06的算法解决问题了。 </span><br><span class="line"></span><br><span class="line">更一般的问题 </span><br><span class="line">更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。 </span><br><span class="line"></span><br><span class="line">解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。 </span><br><span class="line"></span><br><span class="line">事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。 </span><br><span class="line"></span><br><span class="line">我想说：失败不是什么丢人的事情，从失败中全无收获才是。</span><br></pre></td></tr></table></figure><h2 id="P08-泛化物品"><a href="#P08-泛化物品" class="headerlink" title="P08: 泛化物品"></a>P08: 泛化物品</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定义 </span><br><span class="line">考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。 </span><br><span class="line"></span><br><span class="line">更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。 </span><br><span class="line"></span><br><span class="line">这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。 </span><br><span class="line"></span><br><span class="line">一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c*w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c*w仅当v被c整除且v/c&lt;=n，其它情况函数值均为0。 </span><br><span class="line"></span><br><span class="line">一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 </span><br><span class="line"></span><br><span class="line">泛化物品的和 </span><br><span class="line">如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即f(v)=max&#123;h(k) +l(v-k)|0&lt;=k&lt;=v&#125;。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和 l决定的泛化物品。 </span><br><span class="line"></span><br><span class="line">由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足f(v)=max&#123;h(k)+l(v-k)|0&lt;=k&lt;=v&#125;，则称f是h与l的和，即f=h+l。这个运算的时间复杂度是O(V^2)。 </span><br><span class="line"></span><br><span class="line">泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。 </span><br><span class="line"></span><br><span class="line">背包问题的泛化物品 </span><br><span class="line">一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。 </span><br><span class="line"></span><br><span class="line">综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 Scheme 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。 </span><br><span class="line"></span><br><span class="line">我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。</span><br></pre></td></tr></table></figure><h2 id="P09-背包问题问法的变化"><a href="#P09-背包问题问法的变化" class="headerlink" title="P09: 背包问题问法的变化"></a>P09: 背包问题问法的变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。 </span><br><span class="line"></span><br><span class="line">例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。 </span><br><span class="line"></span><br><span class="line">还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。 </span><br><span class="line"></span><br><span class="line">下面说一些变化更大的问法。 </span><br><span class="line"></span><br><span class="line">输出方案 </span><br><span class="line">一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。 </span><br><span class="line"></span><br><span class="line">还是以01背包为例，方程为f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;。再用一个数组g[i] [v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）： </span><br><span class="line"></span><br><span class="line">i=N </span><br><span class="line">v=V </span><br><span class="line">while(i&gt;0) </span><br><span class="line">if(g[i][v]==0) </span><br><span class="line">print &quot;未选第i项物品&quot; </span><br><span class="line">else if(g[i][v]==1) </span><br><span class="line">print &quot;选了第i项物品&quot; </span><br><span class="line">v=v-c[i] </span><br><span class="line"></span><br><span class="line">另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i] [v]==0改成f[i][v]==f[i-1][v]，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。 </span><br><span class="line"></span><br><span class="line">输出字典序最小的最优方案 </span><br><span class="line">这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。 </span><br><span class="line"></span><br><span class="line">一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。 </span><br><span class="line"></span><br><span class="line">在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果f[i][v]==f[i-v]及f[i][v]==f[i-1][f-c[i]]+w[i]同时成立，应该按照后者（即选择了物品i）来输出方案。 </span><br><span class="line"></span><br><span class="line">求方案总数 </span><br><span class="line">对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。 </span><br><span class="line"></span><br><span class="line">对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为f[i][v]=sum&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;，初始条件f[0][0]=1。 </span><br><span class="line"></span><br><span class="line">事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。 </span><br><span class="line"></span><br><span class="line">最优方案的总数 </span><br><span class="line">这里的最优方案是指物品总价值最大的方案。还是以01背包为例。 </span><br><span class="line"></span><br><span class="line">结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">for v=0..V </span><br><span class="line">f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125; </span><br><span class="line">g[i][v]=0 </span><br><span class="line">if(f[i][v]==f[i-1][v]) </span><br><span class="line">inc(g[i][v],g[i-1][v] </span><br><span class="line">if(f[i][v]==f[i-1][v-c[i]]+w[i]) </span><br><span class="line">inc(g[i][v],g[i-1][v-c[i]]) </span><br><span class="line"></span><br><span class="line">如果你是第一次看到这样的问题，请仔细体会上面的伪代码。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。</span><br></pre></td></tr></table></figure><p>不出去看看，又怎么会知道这个世界的魅力！<br><img src="/2019/07/31/背包九讲/2.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;背包九讲&quot;&gt;&lt;a href=&quot;#背包九讲&quot; class=&quot;headerlink&quot; title=&quot;背包九讲&quot;&gt;&lt;/a&gt;&lt;center&gt;背包九讲&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;center&gt;学习背包问题，肯定是要学习背包就讲的，这篇就整理一个全一点的背包九讲&lt;br&gt;背包问题在实际问题中还是比较重要的&lt;br&gt;记录下来问题多多复习&lt;br&gt;争取熟练掌握&lt;br&gt;&lt;img src=&quot;/2019/07/31/背包九讲/1.jpg&quot; alt&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="背包九讲" scheme="http://yoursite.com/categories/ACM/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Day13</title>
    <link href="http://yoursite.com/2019/07/31/Day13/"/>
    <id>http://yoursite.com/2019/07/31/Day13/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T15:21:19.039Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h1><p>今天讲的是 <code>背包</code> 问题<br>背包九讲(自闭快乐~~)<br><a id="more"></a></p><h2 id="今天先背包三讲"><a href="#今天先背包三讲" class="headerlink" title="今天先背包三讲"></a>今天先背包三讲</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目：</span><br><span class="line">有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><br><span class="line">基本思路 </span><br><span class="line">这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 </span><br><span class="line"></span><br><span class="line">用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;。 </span><br><span class="line"></span><br><span class="line">这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f [i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。 </span><br><span class="line"></span><br><span class="line">注意f[i][v]有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[i][v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </span><br><span class="line"></span><br><span class="line">优化空间复杂度 </span><br><span class="line">以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。 </span><br><span class="line"></span><br><span class="line">先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1] [v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v -c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i -1][v-c[i]]的值。伪代码如下： </span><br><span class="line"></span><br><span class="line">for i=1..N </span><br><span class="line">for v=V..0 </span><br><span class="line">f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line">其中的f[v]=max&#123;f[v],f[v-c[i]]&#125;一句恰就相当于我们的转移方程f[i][v]=max&#123;f[i-1][v],f[i- 1][v-c[i]]&#125;，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本思路 </span><br><span class="line">这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;= v&#125;。这跟01背包问题一样有O(N*V)个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度是超过O(VN)的。 </span><br><span class="line"></span><br><span class="line">将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。 </span><br><span class="line"></span><br><span class="line">一个简单有效的优化 </span><br><span class="line">完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c[i]&lt;=c[j]且w[i]&gt;=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题求解 </span><br><span class="line">既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c [i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 </span><br><span class="line"></span><br><span class="line">更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k&lt;V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c[i]))件物品，是一个很大的改进。但我们有更优的O(VN)的算法。 * O(VN)的算法这个算法使用一维数组，先看伪代码： &lt;pre class&quot;example&quot;&gt; for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 </span><br><span class="line"></span><br><span class="line">这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[i][v]=max&#123;f[i-1][v],f[i][v-c[i]]+w[i]&#125;，将这个方程用一维数组实现，便得到了上面的伪代码。 </span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN)的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。</span><br></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目 </span><br><span class="line">有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line"></span><br><span class="line">基本算法 </span><br><span class="line">这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取 n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[i][v]=max&#123;f[i-1][v-k*c[i]]+ k*w[i]|0&lt;=k&lt;=n[i]&#125;。复杂度是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">转化为01背包问题 </span><br><span class="line">另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为∑n[i]的01背包问题，直接求解，复杂度仍然是O(V*∑n[i])。 </span><br><span class="line"></span><br><span class="line">但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 </span><br><span class="line"></span><br><span class="line">方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1&gt;0的最大整数。例如，如果n[i]为13，就将这种物品分成系数分别为1,2,4,6的四件物品。 </span><br><span class="line"></span><br><span class="line">分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。 </span><br><span class="line"></span><br><span class="line">这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为O(V*∑log n[i])的01背包问题，是很大的改进。 </span><br><span class="line"></span><br><span class="line">O(VN)的算法 </span><br><span class="line">多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。 </span><br><span class="line"></span><br><span class="line">小结 </span><br><span class="line">这里我们看到了将一个算法的复杂度由O(V*∑n[i])改进到O(V*∑log n[i])的过程，还知道了存在应用超出NOIP范围的知识的O(VN)算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。</span><br></pre></td></tr></table></figure><h2 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h2><p>Description:<br>涂奥最近迷上了吃鸡，房间有n个配件，每个配件有c(c&lt;=1e3)的重量和v(v&lt;=1e3)的价值，哇，涂奥捡了一个2级包，容量为s，所以涂奥最多当多肥的快递员呢？<br>Input<br>输入的第一行是T, 表示有一共要打T场比赛.<br>每组数据由三行组成.<br>第1行包含两个整数n和s 第2行包含n个整数, 表示每一个配件的价值. 第3行包含n个整数, 表示每个配件的重量.<br>Output<br>对每一组数据, 输出涂奥可以多肥.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">10 10</span><br><span class="line">1 3 5 7 9 11 13 15 17 19</span><br><span class="line">19 17 15 13 11 9 7 5 3 1</span><br><span class="line">Sample Output</span><br><span class="line">51</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e3 + 10;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int w[maxx], v[maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, s;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i];</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int  j = 0; j &lt;= s; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &lt; w[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n][s] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="饭卡"><a href="#饭卡" class="headerlink" title="饭卡"></a>饭卡</h2><p>Description:<br>电子科大本部食堂的饭卡有一种很诡异的设计，即在购买之前判断余额。如果购买一个商品之前，卡上的剩余金额大于或等于5元，就一定可以购买成功（即使购买后卡上余额为负），否则无法购买（即使金额足够）。所以大家都希望尽量使卡上的余额最少。<br>某天，食堂中有n种菜出售，每种菜可购买一次。已知每种菜的价格以及卡上的余额，问最少可使卡上的余额为多少。<br>Input<br>多组数据。对于每组数据：<br>第一行为正整数n，表示菜的数量。n&lt;=1000。<br>第二行包括n个正整数，表示每种菜的价格。价格不超过50。<br>第三行包括一个正整数m，表示卡上的余额。m&lt;=1000。</p><p>n=0表示数据结束。<br>Output<br>对于每组输入,输出一行,包含一个整数，表示卡上可能的最小余额。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">50</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1 2 3 2 1 1 2 3 2 1</span><br><span class="line">50</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">-45</span><br><span class="line">32</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int w[maxx], v[maxx], num[maxx], dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))//n表示菜的数量 </span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">int maxn = 0, max_id = -1, ans = 0, m;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">memset(w, 0, sizeof w);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; w[i];//菜的价格 </span><br><span class="line">if(w[i] &gt; maxn)</span><br><span class="line">&#123;</span><br><span class="line">maxn = w[i];//记录最贵的菜价</span><br><span class="line">max_id = i;//记录最贵菜的下标 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w[max_id] = 0;</span><br><span class="line">cin &gt;&gt; m;//卡上余额 </span><br><span class="line">m -= 5;//预留5元最后买最贵的菜 </span><br><span class="line">int cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = m; j &gt;= w[i]; j --)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[j] &lt; dp[j - w[i]] + w[i])</span><br><span class="line">dp[j] = dp[j - w[i]] + w[i];</span><br><span class="line">if(dp[j] &gt; cnt)</span><br><span class="line">cnt = dp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(m &gt;= 0)</span><br><span class="line">ans = m - cnt - maxn + 5;</span><br><span class="line">else</span><br><span class="line">ans = m + 5;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="CD"><a href="#CD" class="headerlink" title="CD"></a>CD</h2><p>Description:<br>You have a long drive by car ahead. You have a tape recorder, but unfortunately your best music is on CDs. You need to have it on tapes so the problem to solve is: you have a tape N minutes long. How to choose tracks from CD to get most out of tape space and have as short unused space as possible. Assumptions: • number of tracks on the CD does not exceed 20 • no track is longer than N minutes • tracks do not repeat • length of each track is expressed as an integer number • N is also integer Program should find the set of tracks which fills the tape best and print it in the same sequence as the tracks are stored on the CD Input Any number of lines.<br>Each one contains value N, (after space) number of tracks and durations of the tracks. For example from first line in sample data: N = 5, number of tracks=3, first track lasts for 1 minute, second one 3 minutes, next one 4 minutes Output Set of tracks (and durations) which are the correct solutions and string ‘sum:’ and sum of duration times.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input </span><br><span class="line">5 3 1 3 4 </span><br><span class="line">10 4 9 8 4 2 </span><br><span class="line">20 4 10 5 7 4 </span><br><span class="line">90 8 10 23 1 2 3 4 5 7 </span><br><span class="line">45 8 4 10 44 43 12 9 8 2 </span><br><span class="line">Sample Output </span><br><span class="line">1 4 sum:5 </span><br><span class="line">8 2 sum:10 </span><br><span class="line">10 5 4 sum:19 </span><br><span class="line">10 23 1 2 3 4 5 7 sum:55 </span><br><span class="line">4 10 12 9 8 2 sum:45</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,num;</span><br><span class="line">const int maxn=10005;</span><br><span class="line">int a[maxn],dp[maxn],flag[maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">cin.tie(0);</span><br><span class="line">while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;m;i++)cin&gt;&gt;a[i];</span><br><span class="line">memset(flag,0,sizeof(flag));</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">for(int i=m-1;i&gt;=0;i--)//这里倒序主要是在输出的时候方便</span><br><span class="line">&#123;</span><br><span class="line">for(int j=n;j&gt;=a[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[j]&lt;dp[j-a[i]]+a[i])//选上了a[i]的情况</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=dp[j-a[i]]+a[i];</span><br><span class="line">flag[i][j]=1;//进行标记</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0,j=n;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(flag[i][j])//标价到的就输出</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">j-=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;sum:&quot;&lt;&lt;dp[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Piggy-Bank"><a href="#Piggy-Bank" class="headerlink" title="Piggy-Bank"></a>Piggy-Bank</h2><p>Description:<br>在 ACM 能够开展之前，必须准备预算，并获得必要的财力支持。该活动的主要收入来自于 Irreversibly Bound Money (IBM)。思路很简单。任何时候，某位 ACM 会员有少量的钱时，他将所有的硬币投入到小猪储钱罐中。这个过程不可逆，因为只有把小猪储钱罐打碎才能取出硬币。在足够长的时间之后，小猪储钱罐中有了足够的现金，用于支付 ACM 活动所需的花费。<br>但是，小猪储钱罐存在一个大的问题，即无法确定其中有多少钱。因此，我们可能在打碎小猪储钱罐之后，发现里面的钱不够。显然，我们希望避免这种不愉快的情况。唯一的可能是，称一下小猪储钱罐的重量，并尝试猜测里面的有多少硬币。假定我们能够精确判断小猪储钱罐的重量，并且我们也知道给定币种的所有硬币的重量。那么，我们可以保证小猪储钱罐中最少有多少钱。<br>你的任务是找出最差的情形，即判断小猪储钱罐中的硬币最少有多少钱。我们需要你的帮助。不能再贸然打碎小猪储钱罐了！<br>小猪储钱罐了！<br>输入<br>输入包含 T 组测试数据。输入文件的第一行，给出了 T 的值。<br>对于每组测试数据，第一行包含 E 和 F 两个整数，它们表示空的小猪储钱罐的重量，以及装有硬币的小猪储钱罐的重量。两个重量的计量单位都是 g (克)。小猪储钱罐的重量不会超过 10 kg (千克)，即 1 &lt;= E &lt;= F &lt;= 10000 。每组测试数据的第二行，有一个整数 N (1 &lt;= N &lt;= 500)，提供了给定币种的不同硬币有多少种。接下来的 N 行，每行指定一种硬币类型，每行包含两个整数 P 和 W (1 &lt;= P &lt;= 50000，1 &lt;= W &lt;=10000)。P 是硬币的金额 (货币计量单位)；W 是它的重量，以 g (克) 为计量单位。<br>输出<br>对于每组测试数据，打印一行输出。每行必须包含句子 “The minimum amount of money in the piggy-bank is X.” 其中，X 表示对于给定总重量的硬币，所能得到的最少金额。如果无法恰好得到给定的重量，则打印一行 “This is impossible.” 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例输入</span><br><span class="line">3</span><br><span class="line">10 110</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">30 50</span><br><span class="line">10 110</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">50 30</span><br><span class="line">1 6</span><br><span class="line">2</span><br><span class="line">10 3</span><br><span class="line">20 4</span><br><span class="line">示例输出</span><br><span class="line">The minimum amount of money in the piggy-bank is 60.</span><br><span class="line">The minimum amount of money in the piggy-bank is 100.</span><br><span class="line">This is impossible.</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e5;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int v[mod], w[mod];</span><br><span class="line">int dp[mod];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T, n, m;</span><br><span class="line">int E, F;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; E &gt;&gt; F;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">for(int i = 1; i &lt;= F - E; i ++) dp[i] = INF;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = w[i]; j &lt;= F - E; j ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = min(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(dp[F - E] != INF)</span><br><span class="line">printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[F - E]);</span><br><span class="line">else</span><br><span class="line">puts(&quot;This is impossible.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Dividing-coins"><a href="#Dividing-coins" class="headerlink" title="Dividing coins"></a>Dividing coins</h2><p>Description:<br>It’s commonly known that the Dutch have invented copper-wire. Two Dutch men were fighting over a nickel, which was made of copper. They were both so eager to get it and the fighting was so fierce, they stretched the coin to great length and thus created copper-wire. Not commonly known is that the fighting started, after the two Dutch tried to divide a bag with coinsbetweenthetwoofthem. Thecontentsofthebagappearednottobeequallydivisible. TheDutch of the past couldn’t stand the fact that a division should favour one of them and they always wanted a fair share to the very last cent. Nowadays fighting over a single cent will not be seen anymore, but being capable of making an equal division as fair as possible is something that will remain important forever… That’s what this whole problem is about. Not everyone is capable of seeing instantly what’s the most fair division of a bag of coins between two persons. Your help is asked to solve this problem. Given a bag with a maximum of 100 coins, determine the most fair division between two persons. This means that the difference between the amount each person obtains should be minimised.<br>The value of a coin varies from 1 cent to 500 cents. It’s not allowed to split a single coin. Input A line with the number of problems n, followed by n times: • a line with a non negative integer m (m ≤ 100) indicating the number of coins in the bag • a line with m numbers separated by one space, each number indicates the value of a coin. Output The output consists of n lines. Each line contains the minimal positive difference between the amount the two persons obtain when they divide the coins from the corresponding bag.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line"> 2 </span><br><span class="line"> 3 </span><br><span class="line"> 2 3 5</span><br><span class="line"> 4 </span><br><span class="line"> 1 2 4 6 </span><br><span class="line"> Sample Output </span><br><span class="line"> 0 </span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int tx=1e5+10;</span><br><span class="line">int m[tx],dp[tx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,t;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">int sum=0;</span><br><span class="line">for(int i=0;i&lt;t;i++)cin&gt;&gt;m[i],sum+=m[i];</span><br><span class="line">for(int i=0;i&lt;t;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=sum/2;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]+m[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum-dp[sum/2]-dp[sum/2]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Robberies"><a href="#Robberies" class="headerlink" title="Robberies"></a>Robberies</h2><p>Description:<br>可怜的POIUYTREWQ最近想买下dota2的商品，但是手头缺钱。他想起了之前看过的一部大片，觉得抢银行也许是个不错的选择。他认为，坏人被抓是因为没有预先规划。于是他在之前的几个月对各大银行进行了一次评估； 评估内容包括安全性和可盗窃金额： 他想知道在在某个风险系数下可以偷窃的最大金额<br>Input<br>第一行给出了一个整数T, 表示有T组测试数据. 对于每一组数据，第一行给出了一个浮点数P, 表示POIUYTREWQ允许被抓的最大概率, 和一个整数N，表示他计划去抢劫的N个银行. 接下来N行, 每行给出一个整数数Mj和浮点数Pj.<br>抢劫银行 j 可获得 Mj 百万美金, 被抓的概率是 Pj .<br>Output<br>对于每组数据，每行输出一个整数，表示POIUYTREWQ在被抓概率小于P的情况下，可抢到的最多的金钱。</p><p>Notes and Constraints<br>0 &lt; T &lt;= 100<br>0.0 &lt;= P &lt;= 1.0<br>0 &lt; N &lt;= 100<br>0 &lt; Mj &lt;= 100<br>0.0 &lt;= Pj &lt;= 1.0<br>你可以认为每家银行都是独立的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">0.04 3</span><br><span class="line">1 0.02</span><br><span class="line">2 0.03</span><br><span class="line">3 0.05</span><br><span class="line">0.06 3</span><br><span class="line">2 0.03</span><br><span class="line">2 0.03</span><br><span class="line">3 0.05</span><br><span class="line">0.10 3</span><br><span class="line">1 0.03</span><br><span class="line">2 0.02</span><br><span class="line">3 0.05</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 105;</span><br><span class="line">int m[maxn];double dp[100005],p[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ios::sync_with_stdio(0);</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">double pp;int n,sum=0;</span><br><span class="line">cin&gt;&gt;pp&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m[i]&gt;&gt;p[i];</span><br><span class="line">sum+=m[i];</span><br><span class="line">p[i]=1-p[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[0]=1;//这个初始化很重要</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=sum;j&gt;=m[i];j--)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-m[i]]*p[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=sum;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[i]&gt;=1-pp)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h2><p>Description:</p><p>Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to make changes with these coins for a given amount of money. For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-cent coin, two 5-cent coins and one 1-cent coin, one 5-cent coin and six 1-cent coins, or eleven 1-cent coins. So there are four ways of making changes for 11 cents with the above coins. Note that we count that there is one way of making change for zero cent. Write a program to find the total number of different ways of making changes for any amount of money in cents. Your program should be able to handle up to 7489 cents. Input The input file contains any number of lines, each one consisting of a number for the amount of money in cents. Output For each input line, output a line containing the number of different ways of making changes with the above 5 types of coins.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input </span><br><span class="line">11 </span><br><span class="line">26 </span><br><span class="line">Sample Output </span><br><span class="line">4 </span><br><span class="line">13</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll maxx = 10005;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line"></span><br><span class="line">ll a[5] = &#123;1, 5, 10, 25, 50&#125;;</span><br><span class="line">ll dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">while(cin &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">dp[0] = 1;</span><br><span class="line">for(ll i = 0; i &lt; 5; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(ll j = a[i]; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = dp[j] + dp[j - a[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"><a href="#悼念512汶川大地震遇难同胞——珍惜现在，感恩生活" class="headerlink" title="悼念512汶川大地震遇难同胞——珍惜现在，感恩生活"></a>悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</h2><p>Description:<br>急！灾区的食物依然短缺！<br>为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。<br>请问：你用有限的资金最多能采购多少公斤粮食呢？</p><p>后记：<br>人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。<br>月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——<br>感谢父母，他们给予我们生命，抚养我们成人；<br>感谢老师，他们授给我们知识，教我们做人<br>感谢朋友，他们让我们感受到世界的温暖；<br>感谢对手，他们令我们不断进取、努力。<br>同样，我们也要感谢痛苦与艰辛带给我们的财富～<br>Input<br>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。<br>Output<br>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">8 2</span><br><span class="line">2 100 4</span><br><span class="line">4 100 2</span><br><span class="line">Sample Output</span><br><span class="line">400</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 110;</span><br><span class="line">const int mod = 1e7;</span><br><span class="line">int p[maxx];</span><br><span class="line">int h[maxx];</span><br><span class="line">int c[maxx];</span><br><span class="line">int dp[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T, n, m;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; p[i] &gt;&gt; h[i] &gt;&gt; c[i];</span><br><span class="line">for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = n; j &gt;= 0; j --)</span><br><span class="line">&#123;</span><br><span class="line">for(int k = 1; k &lt;= c[i]; k ++)</span><br><span class="line">&#123;</span><br><span class="line">if(j &gt;= p[i] * k)</span><br><span class="line">dp[j] = max(dp[j], dp[j - p[i] * k] + h[i] * k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">外循环i大米种类，中间循环j经费，内循环k该大米数量，递推式即为：dp[j]=max(dp[j],dp[j-p[i]*k]+h[i]*k)。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day13&quot;&gt;&lt;a href=&quot;#Day13&quot; class=&quot;headerlink&quot; title=&quot;Day13&quot;&gt;&lt;/a&gt;Day13&lt;/h1&gt;&lt;p&gt;今天讲的是 &lt;code&gt;背包&lt;/code&gt; 问题&lt;br&gt;背包九讲(自闭快乐~~)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="背包问题" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Day12</title>
    <link href="http://yoursite.com/2019/07/30/Day12/"/>
    <id>http://yoursite.com/2019/07/30/Day12/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-07-31T15:04:25.958Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h1><p>今天学习的是 记忆化搜索(还是和dp有关)</p><a id="more"></a><p><a href="https://vjudge.net/contest/315672#overview" target="_blank" rel="noopener">OJ</a></p><h2 id="什么是记忆化搜索？"><a href="#什么是记忆化搜索？" class="headerlink" title="什么是记忆化搜索？"></a>什么是记忆化搜索？</h2><p>搜索的低效在于没有能够很好地处理重叠子问题；动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目面前，又显得无奈。记忆化搜索正是在这样的情况下产生的，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起，扬长避短，简单实用，在信息学中有着重要的作用。<br>用一个公式简单地说：记忆化搜索=搜索的形式+动态规划的思想。<br>动态规划的一种变形就是记忆化搜索，就是根据动归方程写出递归式，然后在函数的开头直接返回以前计算过的结果，当然这样做也需要一个存储结构记下前面计算过的结果，所以又称为记忆化搜索。<br>记忆化搜索递归式动态规划</p><h3 id="记忆化搜索的思想"><a href="#记忆化搜索的思想" class="headerlink" title="记忆化搜索的思想"></a>记忆化搜索的思想</h3><pre><code>记忆化搜索的思想是,在搜索过程中，会有很多重复计算,如果我们能记录一些状态的答案，就可以减少重复搜索量 </code></pre><h3 id="记忆化搜索的适用范围"><a href="#记忆化搜索的适用范围" class="headerlink" title="记忆化搜索的适用范围"></a>记忆化搜索的适用范围</h3><pre><code>根据记忆化搜索的思想，它是解决重复计算，而不是重复生成，也就是说，这些搜索必须是在搜索扩展路径的过程中分步计算的题目，也就是“搜索答案与路径相关”的题目，而不能是搜索一个路径之后才能进行计算的题目，必须要分步计算，并且搜索过程中，一个搜索结果必须可以建立在同类型问题的结果上，也就是类似于动态规划解决的那种。 </code></pre><p>也就是说，他的问题表达，不是单纯生成一个走步方案，而是生成一个走步方案的代价等，而且每走一步，在搜索树/图中生成一个新状态，都可以精确计算出到此为止的费用，也就是，可以分步计算，这样才可以套用已经得到的答案</p><h3 id="记忆化搜索的核心实现"><a href="#记忆化搜索的核心实现" class="headerlink" title="记忆化搜索的核心实现"></a>记忆化搜索的核心实现</h3><pre><code> a. 首先，要通过一个表记录已经存储下的搜索结果，一般用哈希表实现  b.状态表示，由于是要用哈希表实现，所以状态最好可以用数字表示，常用的方法是把一个状态连写成一个p进制数字，然后把这个数字对应的十进制数字作为状态 c.在每一状态搜索的开始，高效的使用哈希表搜索这个状态是否出现过，如果已经做过，直接调用答案，回溯 d.如果没有，则按正常方法搜索 </code></pre><h3 id="记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"><a href="#记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。" class="headerlink" title="记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"></a>记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。</h3><h2 id="Function-Run-Fun"><a href="#Function-Run-Fun" class="headerlink" title="Function Run Fun"></a>Function Run Fun</h2><p>Description:<br>We all love recursion! Don’t we?</p><p>Consider a three-parameter recursive function w(a, b, c):</p><p>if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns: 1</p><p>if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns: w(20, 20, 20)</p><p>if a &lt; b and b &lt; c, then w(a, b, c) returns: w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)</p><p>otherwise it returns: w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)</p><p>This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.<br><code>Input</code><br>The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.<br><code>Output</code><br>Print the value for w(a,b,c) for each triple.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">10 4 6</span><br><span class="line">50 50 50</span><br><span class="line">-1 7 18</span><br><span class="line">-1 -1 -1</span><br><span class="line">Sample Output</span><br><span class="line">w(1, 1, 1) = 2</span><br><span class="line">w(2, 2, 2) = 4</span><br><span class="line">w(10, 4, 6) = 523</span><br><span class="line">w(50, 50, 50) = 1048576</span><br><span class="line">w(-1, 7, 18) = 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//注意数组越界问题</span><br><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 500;</span><br><span class="line">//int ans;</span><br><span class="line">//int dp[maxx];</span><br><span class="line">int mp[maxx][maxx][maxx];</span><br><span class="line">int w(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return 1;</span><br><span class="line">if(mp[a][b][c]) return mp[a][b][c];</span><br><span class="line">else if(a &gt; 20 || b &gt; 20 || c &gt; 20) return mp[a][b][c] = w(20, 20, 20);</span><br><span class="line">else if(a &lt; b &amp;&amp; b &lt; c) return mp[a][b][c] = w(a, b, c- 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);</span><br><span class="line">else return mp[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a, b, c;</span><br><span class="line">while(~scanf(&quot;%d %d %d&quot;,&amp;a, &amp;b, &amp;c))</span><br><span class="line">&#123;</span><br><span class="line">if(a == -1 &amp;&amp; b == -1 &amp;&amp; c== -1) break;</span><br><span class="line">printf(&quot;w(%d, %d, %d) = %d\n&quot;,a, b, c,w(a, b, c));</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h2><p>Description:<br>Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。<br><code>Input</code><br>第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000)<br><code>Output</code><br>输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">9 1 2</span><br><span class="line">5 6 7</span><br><span class="line">8 4 3</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">Sample Input</span><br><span class="line">4 7</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">1 5 1 1 1 1 1</span><br><span class="line">1 4 3 1 1 1 1</span><br><span class="line">1 5 6 7 8 1 1</span><br><span class="line">Sample Output</span><br><span class="line">7</span><br><span class="line">hint</span><br><span class="line">样例1：7-&gt;6-&gt;4-&gt;3 长度为4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 200;</span><br><span class="line">int mp[maxx][maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int n , m; </span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">-1, 0,</span><br><span class="line">1, 0</span><br><span class="line">&#125;;</span><br><span class="line">int dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">//如果已经找过，退出此次搜索 </span><br><span class="line">if(dp[x][y]) return dp[x][y];</span><br><span class="line">int maxlen = 1;</span><br><span class="line">int len;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = x + d[i][0];</span><br><span class="line">int yy = y + d[i][1];</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; mp[xx][yy] &gt; mp[x][y])</span><br><span class="line">&#123;</span><br><span class="line">//能够遍历一次，步数+1 </span><br><span class="line">len = dfs(xx, yy) + 1;</span><br><span class="line">//不断比较，找该点所能够到达的最大长度 </span><br><span class="line">maxlen = max(maxlen, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y] = maxlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int ans;</span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(mp, 0, sizeof mp);</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">cin &gt;&gt; mp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">//便利搜索每一个点所能到达的最大距离并保存 </span><br><span class="line">dp[i][j] = dfs(i, j);</span><br><span class="line">//不断比较找出最大值 </span><br><span class="line">ans = max(ans, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="漫步校园"><a href="#漫步校园" class="headerlink" title="漫步校园"></a>漫步校园</h2><p>Description:<br>LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?<br><code>Input</code><br>每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。<br><code>Output</code><br>针对每组测试数据，输出总的路线数(小于2^63)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">int x,y,c;</span><br><span class="line">bool friend operator &lt; (node a,node b)&#123;</span><br><span class="line">return a.c &gt; b.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;r,w;</span><br><span class="line">ll ma[330][330];</span><br><span class="line">int vis[330][330];</span><br><span class="line">ll dis[330][330];</span><br><span class="line">ll dp[330][330];  //记忆数组 要用long long  </span><br><span class="line">int Next[4][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;//bfs求终点到其余各点的最短路 </span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">r.x = r.y = n-1;r.c = ma[n-1][n-1];//以终点作为起点 </span><br><span class="line">dis[n-1][n-1] = ma[n-1][n-1];;</span><br><span class="line">vis[n-1][n-1] = 1;</span><br><span class="line">q.push(r);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">r = q.top();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">int nx = r.x + Next[i][0];</span><br><span class="line">int ny = r.y + Next[i][1];</span><br><span class="line">if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n || vis[nx][ny]) continue;</span><br><span class="line">w.x = nx;</span><br><span class="line">w.y = ny;</span><br><span class="line">w.c = r.c + ma[nx][ny];</span><br><span class="line">vis[nx][ny] = 1;</span><br><span class="line">q.push(w); </span><br><span class="line">dis[nx][ny] = w.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dfs(int x,int y)</span><br><span class="line">&#123;//dfs求最短路径条数 </span><br><span class="line">if(x == n-1 &amp;&amp; y == n-1)</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if(dp[x][y] != -1) return dp[x][y];</span><br><span class="line">dp[x][y] = 0;</span><br><span class="line">for(int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">int nx = x + Next[i][0];</span><br><span class="line">int ny = y + Next[i][1];</span><br><span class="line">if( nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n || dis[nx][ny] &gt;= dis[x][y]) continue;</span><br><span class="line">dp[x][y] += dfs(nx,ny);</span><br><span class="line">&#125;</span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n)</span><br><span class="line">&#123; </span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j++)</span><br><span class="line">cin &gt;&gt; ma[i][j];</span><br><span class="line">&#125;</span><br><span class="line">memset(vis,0,sizeof vis); </span><br><span class="line">memset(dp,-1,sizeof dp);</span><br><span class="line">bfs();</span><br><span class="line">cout &lt;&lt; dfs(0,0) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Free-Candies"><a href="#Free-Candies" class="headerlink" title="Free Candies"></a>Free Candies</h2><p>Description:<br>Little Bob is playing a game. He wants to win some candies in it - as many as possible. There are 4 piles, each pile contains N candies. Bob is given a basket which can hold at most 5 candies. Each time, he puts a candy at the top of one pile into the basket, and if there’re two candies of the same color in it, he can take both of them outside the basket and put them into his own pocket. When the basket is full and there are no two candies of the same color, the game ends. If the game is played perfectly, the game will end with no candies left in the piles. For example, Bob may play this game like this (N = 5):<br><img src="https://i.loli.net/2019/07/30/5d3fd1fb6077481048.png" alt><br>Note that diﬀerent numbers indicate diﬀerent colors, there are 20 kinds of colors numbered 1..20. ‘Seems so hard…’ Bob got very much puzzled. How many pairs of candies could he take home at most?<br><code>Input</code><br>The input will contain not more than 10 test cases. Each test case begins with a line containing a single integer n(1 ≤ n ≤ 40) representing the height of the piles. In the following n lines, each line contains four integers xi1, xi2, xi3, xi4 (in the range 1..20). Each integer indicates the color of the corresponding candy. The test case containing n = 0 will terminate the input, you should not give an answer to this case.<br><code>Output</code><br>Output the number of pairs of candies that the cleverest little child can take home. Print your answer in a single line for each test case.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 2 3 4 1 5 6 7 2 3 3 3 4 9 8 6 8 7 2 1 1 1 2 3 4 3 1 2 3 4 5 6 7 8 1 2 3 4 0</span><br><span class="line">Sample Output</span><br><span class="line">8 0 3</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int dp[55][55][55][55];   //记忆数组 </span><br><span class="line">bool Basket[555];//标记篮子内的糖果 </span><br><span class="line">int ma[5][55];//存糖果 </span><br><span class="line">int top[5];//记录取到第几个糖果 例如 top[0] = 1 表示已经取到了第0堆的第一个糖果 </span><br><span class="line">int dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[top[0]][top[1]][top[2]][top[3]] != -1) return dp[top[0]][top[1]][top[2]][top[3]];//判断是否搜索 </span><br><span class="line">if(x == 5) return 0;//如果篮子内糖果数为5  游戏结束 </span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(top[i] == n) continue;//top[i] == n 表示第i堆取完，continue即取下一堆 </span><br><span class="line"></span><br><span class="line">int now = ma[i][top[i]]; //now 表示即将要放入篮子的糖果 </span><br><span class="line">top[i]++;//top[i]++为下次取糖果准备，即下一次取第i堆的下一个糖果 </span><br><span class="line"></span><br><span class="line">if(Basket[now])</span><br><span class="line">&#123;//如果篮子中存在与即将要放入篮子的糖果相同的糖果 </span><br><span class="line">Basket[now] = 0;//从篮子中拿出糖果 </span><br><span class="line">ans = max(ans,dfs(x-1) + 1);//更新结果 </span><br><span class="line">Basket[now] = 1;//回溯 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Basket[now] = 1;//如果篮子中不存在这个糖果，将糖果放入篮子 </span><br><span class="line">ans = max(ans,dfs(x+1)) ;  //更新结果 </span><br><span class="line">Basket[now] = 0;//回溯 </span><br><span class="line">&#125;</span><br><span class="line">top[i]--;//回溯 </span><br><span class="line">&#125;</span><br><span class="line">return dp[top[0]][top[1]][top[2]][top[3]] = ans;  //记忆 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 0; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 4; j++)</span><br><span class="line">cin &gt;&gt; ma[j][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memset(dp,-1,sizeof dp);</span><br><span class="line">memset(Basket,0,sizeof Basket);</span><br><span class="line">memset(top,0,sizeof top);</span><br><span class="line">cout &lt;&lt; dfs(0) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h2><p>Description:<br>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.</p><p>For example, consider forming “tcraete” from “cat” and “tree”:</p><p>String A: cat<br>String B: tree<br>String C: tcraete</p><p>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming “catrtee” from “cat” and “tree”:</p><p>String A: cat<br>String B: tree<br>String C: catrtee</p><p>Finally, notice that it is impossible to form “cttaree” from “cat” and “tree”.<br><code>Input</code><br>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.</p><p><code>Output</code><br>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">cat tree tcraete</span><br><span class="line">cat tree catrtee</span><br><span class="line">cat tree cttaree</span><br><span class="line">Sample Output</span><br><span class="line">Data set 1: yes</span><br><span class="line">Data set 2: yes</span><br><span class="line">Data set 3: no</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">string str1, str2, str;</span><br><span class="line">bool pos;</span><br><span class="line">bool vis[maxx][maxx];</span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">//如果长度相同的话就回溯，表示结束 </span><br><span class="line">if(x == str1.length() &amp;&amp; y == str2.length())</span><br><span class="line">&#123;</span><br><span class="line">//能够都遍历表示可以 </span><br><span class="line">pos = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(str1[x] != str[z] &amp;&amp; str2[y] != str[z]) return;</span><br><span class="line">if(vis[x][y]) return;</span><br><span class="line">vis[x][y] = 1;</span><br><span class="line">if(str1[x] == str[z]) dfs(x + 1, y, z + 1); </span><br><span class="line">if(str2[y] == str[z]) dfs(x, y + 1, z + 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k = 1;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str;</span><br><span class="line">pos = 0;</span><br><span class="line">dfs(0, 0, 0);</span><br><span class="line">if(pos)</span><br><span class="line">printf(&quot;Data set %d: yes\n&quot;,k ++);</span><br><span class="line">else</span><br><span class="line">printf(&quot;Data set %d: no\n&quot;, k ++);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h2><p>Description:<br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br><code>Input</code><br>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.<br><code>Output</code><br>One integer per line representing the maximum of the total value (this number will be less than 2 31).<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5 10</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line">Sample Output</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e3 + 10;</span><br><span class="line">int w[maxx];</span><br><span class="line">int v[maxx];</span><br><span class="line">int s[maxx][maxx]; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n, m;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">memset(s, 0, sizeof s);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i];//骨骼价值 </span><br><span class="line">for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; //骨骼体积 </span><br><span class="line">//i表示第i个骨骼,j表示背包容量</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">//是否选择第i个就要看容量是否大于它的重量 </span><br><span class="line">if(j &gt;= w[i])</span><br><span class="line">&#123;</span><br><span class="line">//拿，那么就必须要占用当前背包的空间。即用当前背包总容量 j-w[i]，再占用1个物品空间，所以i-1，此时的总价值就是m [i-1][j-w[i]] 的解+当前的价值v[i] ，得到的就是放入当前物品得到的最优解。 </span><br><span class="line">s[i][j] = max(s[i - 1][j], s[i - 1][j-w[i]] + v[i]);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">//不拿，那么就还是上一步的解，m[i-1][j]</span><br><span class="line">s[i][j] = s[i - 1][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s[n][m] &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h2><p>Description:<br>有一种游戏是的玩法是这样的：<br>有一个n*n的格子,每个格子有一个数字。<br>遵循以下规则:</p><ol><li>玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m</li><li>玩家一开始在第一行第一列，并且已经获得该格子的分值</li><li>玩家获得每一次移动到的格子的分值</li><li>玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。</li><li>游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围</li><li>玩家仅能在n*n的格子内移动，超出格子边界属于非法操作</li><li>当玩家不能再次移动时，游戏结束<br>现在问你，玩家所能获得的最大得分是多少？<br><code>Input</code><br>有多组测试数据<br>每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可<br>之后n行，每行n个数字，描述n*n的格子里的数字<br><code>Output</code><br>对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 1</span><br><span class="line">1 2 5</span><br><span class="line">10 11 6</span><br><span class="line">12 12 7</span><br><span class="line">-1 -1</span><br><span class="line">Sample Output</span><br><span class="line">37</span><br></pre></td></tr></table></figure></li></ol><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 200;</span><br><span class="line">int a[maxx][maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int m, n;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0</span><br><span class="line">&#125;;</span><br><span class="line">int dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[x][y]) return dp[x][y];</span><br><span class="line">int maxsorce = 0;</span><br><span class="line">int sorce;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 1; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">int xx = x + (d[i][0]) * j; </span><br><span class="line">int yy = y + (d[i][1]) * j;</span><br><span class="line">if(xx &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; a[xx][yy] &gt; a[x][y])</span><br><span class="line">&#123;</span><br><span class="line">sorce = dfs(xx, yy);</span><br><span class="line">maxsorce = max(sorce, maxsorce);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[x][y] = maxsorce + a[x][y];//回溯到x，y的最大和(顺序从大到小) </span><br><span class="line">return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">memset(dp, 0, sizeof dp);</span><br><span class="line">if(n == -1 &amp;&amp; m == -1) break;</span><br><span class="line">for(int i = 0; i &lt; n ; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(0, 0);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dp[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1.关于移动问题：由于题中移动范围并不是1可以扩大到1*k所以仍然需要构造移动方向，只是需要dfs四周范围为k。 </span><br><span class="line">2.可以从最后一个节点往回遍历，也就是需要先找到最大的值，然后往回找，如何实现呢，用递归。但是需要标记路径不然会爆的。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="送披萨"><a href="#送披萨" class="headerlink" title="送披萨"></a>送披萨</h2><p>Description:<br>何老板开了一家披萨店，有一天突然收到了n个客户的订单。<br>何老板所在的城市只有一条笔直的大街，我们可以将它想象成数轴，其中位置0是何老板的披萨店，第i个客户所在的位置为Pi,每个客户的位置都不同。如果何老板给第i个客户送披萨，客户会支付Ei-Ti块钱，其中Ti是何老板到达他家的时刻。当然，如果到得太晚，会使得Ei-Ti＜0,这时，何老板可以选择不给他送餐，免得他反过来找何老板要钱。<br>何老板店里面只有一个送餐车（单位时间行驶单位长度的距离），因此只能往返送餐，如下图所示就是一条线路，图中第一行的数字是位置Pi,第二行是Ei。<br>你的任务是帮助何老板计算出最大的收益。<br><img src="https://i.loli.net/2019/07/30/5d3fd359c720210349.jpg" alt><br><code>Input</code><br>第一行，一个整数n<br>第二行，n个空格间隔的整数，从左往右给出了每个客户的位置Pi，即P1,P2,……,Pn<br>第三行，n个空格间隔的整数，从左往右给出了每个客户对应的Ei，即E1,E2,……,En<br><code>Output</code><br>一行，一个整数，表示所求的最佳收益。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">-6 -3 -1 2 5</span><br><span class="line"> 27 10 2 5 20</span><br><span class="line">Sample Output</span><br><span class="line">32</span><br><span class="line">Sample Input</span><br><span class="line">6</span><br><span class="line"> 1 2 4 7 11 14</span><br><span class="line"> 3 6 2 5 18 10</span><br><span class="line">Sample Output</span><br><span class="line">13</span><br><span class="line">Sample Input</span><br><span class="line">11</span><br><span class="line">-14 -13 -12 -11 -10 1 2 3 4 5 100</span><br><span class="line"> 200 200 200 200 200 200 200 200 200 200 200</span><br><span class="line">Sample Output</span><br><span class="line">1937</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1 ≤ n ≤ 100</span><br><span class="line">-100,000 ≤ Pi ≤ 100,000  且Pi!=0</span><br><span class="line"> 0＜ Ei ≤ 100,000</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[205][205][205][2];</span><br><span class="line">bool mark[205][205][205][2];</span><br><span class="line">int n;</span><br><span class="line">int pos[205],e[205],start;</span><br><span class="line">int dp(int l,int r,int cnt,int p)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(mark[l][r][cnt][p])return f[l][r][cnt][p];</span><br><span class="line">    mark[l][r][cnt][p]=true;</span><br><span class="line">    if(cnt==0)return f[l][r][cnt][p]=0;</span><br><span class="line">    if(p==0)&#123;</span><br><span class="line">        for(i=1;i&lt;l;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(i,r,cnt-1,0)+e[i]-cnt*abs(pos[l]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=r+1;i&lt;=n+1;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(l,i,cnt-1,1)+e[i]-cnt*abs(pos[l]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(i=1;i&lt;l;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(i,r,cnt-1,0)+e[i]-cnt*abs(pos[r]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=r+1;i&lt;=n+1;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(l,i,cnt-1,1)+e[i]-cnt*abs(pos[r]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[l][r][cnt][p];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,j,ans=0;</span><br><span class="line">    start=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;pos[i];</span><br><span class="line">        if(pos[i]&gt;0&amp;&amp;start==0)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            pos[i+1]=pos[i];</span><br><span class="line">            pos[i]=0;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;e[i];</span><br><span class="line">        if(start==i)&#123;</span><br><span class="line">            e[i+1]=e[i];</span><br><span class="line">            e[i]=0;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=max(ans,dp(start,start,i,0));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day12&quot;&gt;&lt;a href=&quot;#Day12&quot; class=&quot;headerlink&quot; title=&quot;Day12&quot;&gt;&lt;/a&gt;Day12&lt;/h1&gt;&lt;p&gt;今天学习的是 记忆化搜索(还是和dp有关)&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Day11</title>
    <link href="http://yoursite.com/2019/07/29/Day11/"/>
    <id>http://yoursite.com/2019/07/29/Day11/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-30T13:55:31.091Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h1><p>今天学习的是 动态规划(dp) + 最大字段和问题 + 最长公共子序列 + 编辑距离 + 最长递增子序列<br>重点还是动态规划(dp)</p><a id="more"></a><h2 id="动态规划简介："><a href="#动态规划简介：" class="headerlink" title="动态规划简介："></a>动态规划简介：</h2><p>动态规划：就是一个最优化问题，先将问题分解为子问题，并且对于这些分解的子问题自身就是最优的才能在这个基础上得出我们要解决的问题的最优方案，要不然的话就能找到一个更优的解来替代这个解，得出新的最优自问题，这当然是和前提是矛盾的。动态规划不同于 贪心算法，因为贪心算法是从局部最优来解决问题，而动态规划是全局最优的。用动态规划的时候不可能在子问题还没有得到最优解的情况下就做出决策，而是必须等待子问题得到了最优解之后才对当下的情况做出决策，所以往往动态规划都可以用 一个或多个递归式来描述。而贪心算法却是先做出一个决策，然后在去解决子问题。这就是贪心和动态规划的不同。<br>一般遇到一个动态规划类型的问题，都先要确定最优子结构，还有重叠子问题，这两个是动态规划最大的特征，然后就是要写 动态规划的状态方程，这个步骤十分十分的重要的，写动归方程是需要一定的经验的，这可以通过训练来达到目的。接着就是要自底向上的求解问题的，先将最小规模的子问题的最优解求出，一般都用一张表来记录下求得的解，到后来遇到同样的子问题的时候就可以直接查表得到答案，最后就是通过一步一步的迭代得出最后问题的答案了。<br>我的理解最重要的东西就是一定会要一个数组或者其他的存储结构存储得到的子问题的解。这样就可以省很多时间，也就是典型的空间换时间</p><h2 id="The-King’s-Ups-and-Downs"><a href="#The-King’s-Ups-and-Downs" class="headerlink" title="The King’s Ups and Downs"></a>The King’s Ups and Downs</h2><p>Description:<br>The king has guards of all different heights. Rather than line them up in increasing or decreasing height order, he wants to line them up so each guard is either shorter than the guards next to him or taller than the guards next to him (so the heights go up and down along the line). For example, seven guards of heights 160, 162, 164, 166, 168, 170 and 172 cm. could be arranged as:<br><img src="/2019/07/29/Day11/1.png" alt><br>or perhaps:<img src="/2019/07/29/Day11/2.png" alt><br>he king wants to know how many guards he needs so he can have a different up and down order at each changing of the guard for rest of his reign. To be able to do this, he needs to know for a given number of guards, n, how many different up and down orders there are:<br>For example, if there are four guards: 1, 2, 3,4 can be arrange as:<br>1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423<br>For this problem, you will write a program that takes as input a positive integer n, the number of guards and returns the number of up and down orders for n guards of differing heights.<br><code>Input</code><br>The first line of input contains a single integer P, (1 &lt;= P &lt;= 1000), which is the number of data sets that follow. Each data set consists of single line of input containing two integers. The first integer, D is the data set number. The second integer, n (1 &lt;= n &lt;= 20), is the number of guards of differing heights.<br><code>Output</code><br>For each data set there is one line of output. It contains the data set number (D) followed by a single space, followed by the number of up and down orders for the n guards.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 20</span><br><span class="line">Sample Output</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 10</span><br><span class="line">4 740742376475050</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=25;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll dp[maxn][maxn],ans[maxn];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">dp[1][1]=1;ans[1]=1;</span><br><span class="line">for(int i=2;i&lt;=20;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=2;k&lt;=i;k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][k]=dp[i-1][i+1-k]+dp[i][k-1];</span><br><span class="line">ans[i]+=dp[i][k];</span><br><span class="line">&#125;</span><br><span class="line">ans[i]*=2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int p,m,n;</span><br><span class="line">cin&gt;&gt;p;</span><br><span class="line">while(p--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;&quot; &quot;&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="数塔"><a href="#数塔" class="headerlink" title="数塔"></a>数塔</h2><p>Description:<br>在讲述DP算法的时候，一个经典的例子就是数塔问题，它是这样描述的：<br>有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？<br><img src="/2019/07/29/Day11/3.png" alt><br>已经告诉你了，这是个DP的题目，你能AC吗?<br><code>Input</code><br>输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 &lt;= N &lt;= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。<br><code>Output</code><br>对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br><span class="line">Sample Output</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1000;</span><br><span class="line">int a[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; i + 1; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = n - 2; i &gt;= 0; i --)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt;= i; j ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j] = max(a[i + 1][j], a[i + 1][j + 1]) + a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[0][0] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="母牛的故事"><a href="#母牛的故事" class="headerlink" title="母牛的故事"></a>母牛的故事</h2><p>Description:<br>有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br><code>Input</code><br>输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt;n&lt;55)，n的含义如题目中描述。<br>n=0表示输入数据的结束，不做处理。<br><code>Output</code><br>对于每个测试实例，输出在第n年的时候母牛的数量。<br>每个输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e7;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">a[1] = 1, a[2] = 2, a[3] = 3, a[4] = 4;</span><br><span class="line">for(int i = 5; i &lt; 55; i ++) a[i] = a[i - 1] + a[i - 3];</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">if(n == 0) break;</span><br><span class="line">cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="一只小蜜蜂…"><a href="#一只小蜜蜂…" class="headerlink" title="一只小蜜蜂…"></a>一只小蜜蜂…</h2><p>Description:<br>有一只经过训练的蜜蜂只能爬向右侧相邻的蜂房，不能反向爬行。请编程计算蜜蜂从蜂房a爬到蜂房b的可能路线数。<br>其中，蜂房的结构如下所示。<br><img src="/2019/07/29/Day11/4.png" alt><br><code>Input</code><br>输入数据的第一行是一个整数N,表示测试实例的个数，然后是N 行数据，每行包含两个整数a和b(0&lt;a&lt;b&lt;50)。<br><code>Output</code><br>对于每个测试实例，请输出蜜蜂从蜂房a爬到蜂房b的可能路线数，每个实例的输出占一行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e6;</span><br><span class="line">long long a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, x, y;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">a[0] = 1, a[1] = 1, a[2] = 2;</span><br><span class="line">for(int i = 3; i &lt; 60; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i - 1] + a[i - 2];</span><br><span class="line">&#125;</span><br><span class="line">while(n --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; a[y - x] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="超级楼梯"><a href="#超级楼梯" class="headerlink" title="超级楼梯"></a>超级楼梯</h2><p>Description:<br>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？<br><code>Input</code><br>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。<br><code>Output</code><br>对于每个测试实例，请输出不同走法的数量<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e6;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t, n;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">a[0] = 0;</span><br><span class="line">a[1] = 1;</span><br><span class="line">a[2] = 2;</span><br><span class="line">for(int i = 3; i &lt;= 40; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i - 1] + a[i - 2]; </span><br><span class="line">&#125;</span><br><span class="line">while(t --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; a[n - 1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Tickets"><a href="#Tickets" class="headerlink" title="Tickets"></a>Tickets</h2><p>Description:<br>现在有n个人要买电影票，如果知道每个人单独买票花费的时间，还有和前一个人一起买花费的时间，问最少花多长时间可以全部买完票。<br><code>Input</code><br>给出 N(1&lt;=N&lt;=10)，表示有N组样例 　　　　给出K (1&lt;=K&lt;=2000)，表示有K个人买票.. 　　　　给出K个数表示这个人单独买票会花的时间..保证每个数 (0s&lt;=Si&lt;=25s) 　　　　给出K-1个数，表示这个人和前面那个人一起买票会花的时间..保证每个数 (0s&lt;=Si&lt;=50s)<br><code>Output</code><br>对于每一组数据，你需要给出电影院售票结束的时间，售票开始的时间为 08:00:00 am. 时间格式为： HH:MM:SS am|pm. 具体看样例输出<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">20 25</span><br><span class="line">40</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">Sample Output</span><br><span class="line">08:00:40 am</span><br><span class="line">08:00:08 am</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=2005;</span><br><span class="line">int s[maxn],d[maxn],ans[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,k;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">while(n--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">for(int i=1;i&lt;=k;i++)cin&gt;&gt;s[i];</span><br><span class="line">for(int j=2;j&lt;=k;j++)cin&gt;&gt;d[j];</span><br><span class="line">ans[1]=s[1];</span><br><span class="line">for(int i=2;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=min(ans[i-1]+s[i],ans[i-2]+d[i]);</span><br><span class="line">&#125;</span><br><span class="line">int time=ans[k];int h,m,s;</span><br><span class="line">h=time/3600;</span><br><span class="line">m=time%3600/60;</span><br><span class="line">s=time%3600%60;</span><br><span class="line">h+=8;</span><br><span class="line">if(h&lt;=12)</span><br><span class="line">printf(&quot;%02d:%02d:%02d am\n&quot;,h,m,s);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%02d:%02d:%02d pm\n&quot;,h-12,m,s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="钱币兑换问题"><a href="#钱币兑换问题" class="headerlink" title="钱币兑换问题"></a>钱币兑换问题</h2><p>Description:<br>在一个国家仅有1分，2分，3分硬币，将钱N兑换成硬币有很多种兑法。请你编程序计算出共有多少种兑法。<br><code>Input</code><br>每行只有一个正整数N，N小于32768。<br><code>Output</code><br>对应每个输入，输出兑换方法数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2934</span><br><span class="line">12553</span><br><span class="line">Sample Output</span><br><span class="line">718831</span><br><span class="line">13137761</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">int a[33005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">a[0] = 1;</span><br><span class="line">for(int i = 1; i &lt;= 3; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = i; j &lt;= 33000; j ++)</span><br><span class="line">&#123;</span><br><span class="line">a[j] = max(a[j], a[j] + a[j - i]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Ignatius-and-the-Princess-IV"><a href="#Ignatius-and-the-Princess-IV" class="headerlink" title="Ignatius and the Princess IV"></a>Ignatius and the Princess IV</h2><p>Description:<br>给你n个数字，请你找出出现至少(n+1)/2次的数字。<br><code>输入</code><br>本题包含多组数据，请处理到EOF：<br>每组数据包含两行。<br>第一行一个数字N(1&lt;=N&lt;=999999) ，保证N为奇数。<br>第二行为N个用空格隔开的整数。<br><code>输出</code><br>对于每组数据，输出一行，表示要求找到的那个数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">1 3 2 3 3</span><br><span class="line">11</span><br><span class="line">1 1 1 1 1 5 5 5 5 5 5</span><br><span class="line">7</span><br><span class="line">1 1 1 1 1 1 1</span><br><span class="line">样例输出</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a[1000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, t, ans;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">memset(a, 0, sizeof a);</span><br><span class="line">ans = 0;</span><br><span class="line">//遍历查找，如果数字相同，加一 </span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">a[t] ++;</span><br><span class="line">if(a[t] &gt;= (n + 1) / 2) ans = t;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="最少拦截系统"><a href="#最少拦截系统" class="headerlink" title="最少拦截系统"></a>最少拦截系统</h2><p>Description:<br>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br>怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.<br><code>Input</code><br>输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是不大于30000的正整数,用空格分隔)<br><code>Output</code><br>对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">8 389 207 155 300 299 170 158 65</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXX=100000+5;</span><br><span class="line">const int INF=INT_MAX;</span><br><span class="line"></span><br><span class="line">int a[MAXX],dp[MAXX];</span><br><span class="line">// a数组为数据，dp[i]表示以a[i]结尾的最长递增子序列长度</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            dp[i]=1; // 初始化为1，长度最短为自身</span><br><span class="line">        &#125;</span><br><span class="line">        int ans=1;</span><br><span class="line">        for(int i=1; i&lt;n; i++)//枚举子序列的终点</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0; j&lt;i; j++)//从头向终点检查每一个元素</span><br><span class="line">            &#123;</span><br><span class="line">                if(a[i]&gt;a[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+1);  // 状态转移</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=max(ans,dp[i]);  // 比较每一个dp[i],最大值为答案</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day11&quot;&gt;&lt;a href=&quot;#Day11&quot; class=&quot;headerlink&quot; title=&quot;Day11&quot;&gt;&lt;/a&gt;Day11&lt;/h1&gt;&lt;p&gt;今天学习的是 动态规划(dp) + 最大字段和问题 + 最长公共子序列 + 编辑距离 + 最长递增子序列&lt;br&gt;重点还是动态规划(dp)&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Day10</title>
    <link href="http://yoursite.com/2019/07/27/Day10/"/>
    <id>http://yoursite.com/2019/07/27/Day10/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-28T13:55:33.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><p>今天是 又一次 <code>积分赛</code><br>我心态很好，真的很好，，，，真的很好。。。。</p><a id="more"></a><p><a href="https://hpuoj.com/contest/23/" target="_blank" rel="noopener">OJ</a></p><h2 id="再战斐波那契"><a href="#再战斐波那契" class="headerlink" title="再战斐波那契"></a>再战斐波那契</h2><p><code>Problem Description</code><br>Description:<br>小z 学会了斐波那契和 gcd 后，老师又给他出了个难题，求第N个和第M个斐波那契数的最大公约数，这可难倒了小z ，不过在小z 的再三请求下，老师又告诉他了个条件，gcd(N,M)∈[1,90]。<br>可是，笨拙的小z 还是不会，于是请求你帮他解答这个问题。<br>已知:<br><img src="https://i.loli.net/2019/07/28/5d3d9d5e7339863828.png" alt><br>输入格式<br>输入包括 T 组，T∈[1,10].<br>接下来 T 行,每行两个整数 N,M, 表示斐波那契的第 N 项和第 M 项，(N,M∈[1,1e18]).<br>输出格式<br>输出包含 T 行,每行输出一个整数.<br>样例<br><code>input</code><br>3<br>1 2<br>2 3<br>3 4<br><code>output</code><br>1<br>1<br>1</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//gcd(f(m),f(n)) = f(gcd(m,n))这个是规律</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a[1000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">ll x, y;</span><br><span class="line">a[2] = 1, a[1] = 1;</span><br><span class="line">for(int i = 3; i &lt;= 100; i ++) a[i] = a[i - 1] + a[i - 2];</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld %lld&quot;,&amp;x, &amp;y);</span><br><span class="line">printf(&quot;%lld\n&quot;,a[__gcd(x, y)]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="恐怖的怪物"><a href="#恐怖的怪物" class="headerlink" title="恐怖的怪物"></a>恐怖的怪物</h2><p>Description:<br>一天早上，Dicer一觉醒来，发现自己来到了MineCraft的世界里面，身为MineCraft游戏爱好者的他欣喜不已，于是他在地下挖了一片长方体的空间作为秘密基地，可是他发现光照亮度小于等于7时，会有恐怖的怪物出现，并且他通过查阅资料发现光源方块产生光照每一米（方格）衰减1光照等级。<br>此规律在坐标轴的3个方向上（东西、南北、上下）均成立。换句话来说，对角线方向的光照衰减依照“曼哈顿距离”（两个点在坐标系上的绝对轴距总和）计算。这意味着，假如地上插着一支火把（光照等级14），则在水平面上与火把相邻的4个方向的方格上光照等级均为13，而在水平面上与火把对角的4个方格上光照等级均为12（譬如，西北方格的光照等级为14-向西1级-向北1级）。<br>上述这种衰减特性会在光源周围产生菱形的照明。该效果会在光源周围的光源扩散呈钻石状。如果被不透明方块阻挡，光照也可以沿着复杂而弯曲的路径扩散。<br>如下图所示，红色为光源（亮度等级为14）,黑色为秘密物品，其余各个位置光照强度如图所示。<br><img src="https://i.loli.net/2019/07/28/5d3d9e0943f8067086.png" alt><br>秘密基地为N∗M的空间，不考虑高度，初始地面光照强度为0。为了不生成恐怖的怪物，Dicer布置了一些光源，但他不知道是否仍会生成怪物，现在请你帮助Dicer判断。<br>注：光源及秘密物品均为不透明方块，且其上方均不会生成怪物。<br>输入格式<br>第一行是一个T。（1≤T≤100）<br>接下来有T组数据，每一组第一行是N,M,（1≤N,M≤1000）,接下来有N行，每行M个字符，代表秘密基地地面放置的方块，0代表空气，#代表秘密物品，Y代表萤石(光照等级为15)，H代表火把(光照等级为14)，F代表附魔台(光照等级为12)，R代表激活的红石火把(光照等级为7)。<br>输出格式<br>输出包含T行，每行如果仍会生成怪物，输出”Yes”,否则输出”No”。<br>样例<br><code>input</code><br>2<br>2 3<br>0Y0<br>00#<br>3 4<br>R00#<br>00R0<br>0R00<br>output<br>No<br>Yes<br><code>input</code><br>2<br>1 5<br>0Y0R0<br>2 4<br>Y#0R<br>0000<br><code>output</code><br>Yes<br>No<br><code>input</code><br>1<br>5 4<br>Y0F0<br>0000<br>0000<br>0000<br>0000<br><code>output</code><br>No</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">#define pii pair&lt;int,int&gt;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">const ll INF=0x3f3f3f3f3f3f3f3f;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line"></span><br><span class="line">int t,n,m;</span><br><span class="line">char mp[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int d[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;</span><br><span class="line">queue&lt;pii&gt;H,F;</span><br><span class="line">queue&lt;pii&gt;que;</span><br><span class="line">void init()&#123;</span><br><span class="line">while(!que.empty()) que.pop();</span><br><span class="line">while(!H.empty()) H.pop();</span><br><span class="line">while(!F.empty()) F.pop();</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">vis[i][j]=0;</span><br><span class="line">&#125;</span><br><span class="line">bool BFS()&#123;</span><br><span class="line">while(!que.empty())&#123;</span><br><span class="line">int x=que.front().first;</span><br><span class="line">int y=que.front().second;</span><br><span class="line">que.pop();</span><br><span class="line">if(vis[x][y]==8) break;</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">int xx=x+d[i][0];</span><br><span class="line">int yy=y+d[i][1];</span><br><span class="line">if(xx&lt;=0 || xx&gt;n || yy&lt;=0 || yy&gt;m || vis[xx][yy] || mp[xx][yy]!=&apos;0&apos;) continue;</span><br><span class="line">vis[xx][yy]=vis[x][y]-1;</span><br><span class="line">que.push(pii(xx,yy));</span><br><span class="line">while(vis[xx][yy]==14 &amp;&amp; (!H.empty()))&#123;</span><br><span class="line">que.push(H.front());</span><br><span class="line">H.pop();</span><br><span class="line">&#125;</span><br><span class="line">while(vis[xx][yy]==12 &amp;&amp; (!F.empty()))&#123;</span><br><span class="line">que.push(F.front());</span><br><span class="line">F.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">for(int j=1;j&lt;=m;j++)</span><br><span class="line">if(vis[i][j]&lt;=7 &amp;&amp; mp[i][j]==&apos;0&apos;) return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,mp[i]+1);</span><br><span class="line">for(int j=1;j&lt;=m;j++)&#123;</span><br><span class="line">if(mp[i][j]==&apos;Y&apos;) que.push(pii(i,j)),vis[i][j]=15 ;//15</span><br><span class="line">if(mp[i][j]==&apos;H&apos;) H.push(pii(i,j)),vis[i][j]=14;//14</span><br><span class="line">if(mp[i][j]==&apos;F&apos;) F.push(pii(i,j)),vis[i][j]=12;//12</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(BFS()) printf(&quot;No\n&quot;);</span><br><span class="line">else printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="连连看"><a href="#连连看" class="headerlink" title="连连看"></a>连连看</h2><p>Description:<br>众所周知，《连连看》是一个老少皆宜的游戏。<br>《连连看》是由黄兴武创作的一款PC端益智类游戏，只要将相同的两张牌用三根以内的线段连在一起就可以消除，规则简单容易上手。<br>现在呢，Boctorio学长突然想玩连连看了，但不是单纯的玩游戏，他想自己出一局连连看。<br>由于Boctorio学长是一个蒟蒻，他不知道自己出的连连看是否符合能够通过多次操作将其全部消除，所以想要你帮他检查一下他出的连连看是否符合规则。<br>输入格式<br>第一行输入个T,表示T组数据（1≤t≤100）<br>每组数据第一行两个数 n,m ,表示连连看棋盘的长和宽（1≤n,m≤100）<br>接下来 n 行，每行输入 m 个正整数aij，表示 m 个棋子 (1≤aij≤n∗m)。<br>每种棋子只会出现一对，因此数据保证只有一种有效结果。<br>输出格式<br>每组数据输出一行。<br>如果棋盘符合规定，输出”Yes”，否则，输出”No”（不包括引号）。<br>样例<br><code>input</code><br>3<br>2 2<br>1 2<br>2 1<br>3 4<br>1 6 2 3<br>4 5 3 1<br>4 2 6 5<br>4 4<br>1 2 3 6<br>8 4 7 8<br>5 6 5 7<br>1 2 3 4<br><code>output</code><br>No<br>No<br>Yes</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">int mp[200][200];</span><br><span class="line">int n,m;</span><br><span class="line">int sx,sy;</span><br><span class="line">int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;//分别对应下，右，左，上</span><br><span class="line">int check(int x,int y)&#123;</span><br><span class="line">if(x&lt;0 || x&gt;n+1 || y&lt;0 || y&gt;m+1)</span><br><span class="line">return 1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool judge(int x,int y,int step,int pos)&#123;//pos表示上一步方向</span><br><span class="line">if(step&gt;3) return 0;//如果超过了三步，不符合规则</span><br><span class="line">if(mp[x][y]==mp[sx][sy] &amp;&amp; pos!=-1)&#123;//如果两个字符相等并且不是同一个（由于下面有方向限制，所以两个值不可能相等）</span><br><span class="line">mp[x][y]=0;//删去配对字符 </span><br><span class="line">mp[sx][sy]=0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if(mp[x][y]!=0 &amp;&amp; pos!=-1) return 0;//如果不相等并且不是通路，不符合规则 </span><br><span class="line">int i,x1,y1;</span><br><span class="line">for(i=0;i&lt;4;i++)&#123;</span><br><span class="line">if(i+pos==3) continue;//不能有正相反的方向 (0.下 3.上)   (1.右 2.左)</span><br><span class="line">x1=x+dir[i][0];</span><br><span class="line">y1=y+dir[i][1];</span><br><span class="line">if(check(x1,y1)) continue;//检查是否越界 </span><br><span class="line">if(judge(x1,y1,step+(pos==i?0:1),i))&#123;//找到一个就返回 </span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t,times,sum;</span><br><span class="line">int i,j;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">memset(mp,0,sizeof(mp));</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;mp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum=0;</span><br><span class="line">times=0;//times表示查找的次数，大于等于n*m相当于查找一遍还没有找到 </span><br><span class="line">i=j=1;</span><br><span class="line">while(sum&lt;n*m &amp;&amp; times&lt;n*m)&#123;</span><br><span class="line">for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(j=1;j&lt;=m;j++)&#123;</span><br><span class="line">times++;</span><br><span class="line">sx=i,sy=j;</span><br><span class="line">if(mp[i][j]!=0 &amp;&amp; judge(i,j,0,-1))&#123;</span><br><span class="line">sum+=2;</span><br><span class="line">times=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(sum==n*m)&#123;</span><br><span class="line">printf(&quot;Yes\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;No\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Points-in-rectangle"><a href="#Points-in-rectangle" class="headerlink" title="Points in rectangle"></a>Points in rectangle</h2><p>Description:<br>在二维平面中有一个矩形，它的四个坐标点分别为(0,a),(a,0),(n,n−a),(n−a,n)。你现在有m个点，现在你想知道有多少个点是在这个矩形内的(边上的也算)。<br>输入格式<br>第一行输入n,a(1≤a\&lt;n≤1e3)。<br>第二行一个正整数m(1≤m≤1e3),代表你拥有的点的个数，接下来m行，每行一个点的坐标xi,yi(1≤xi,yi≤1e3)。<br>输出格式<br>第一行输出在矩形内的点的个数，然后输出在矩形内点的坐标，横坐标大的优先，如果横坐标相同，则纵坐标大的优先。如果没有，输出−1。<br>样例<br><code>input</code><br>6 1<br>5<br>1 2<br>1 3<br>2 3<br>3 4<br>4 5<br><code>output</code><br>4<br>4 5<br>3 4<br>2 3<br>1 2</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, a;</span><br><span class="line">int m;</span><br><span class="line">struct node&#123;</span><br><span class="line">int xo, yo;</span><br><span class="line">&#125;biao[10001];</span><br><span class="line">node biao1[10001];</span><br><span class="line">int cmp(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">if(a.xo == b.xo) return a.yo &gt; b.yo;</span><br><span class="line">return a.xo &gt; b.xo;</span><br><span class="line">&#125;</span><br><span class="line">int cnt;</span><br><span class="line">bool solve(node point)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">return point.yo &gt;= -point.xo + a &amp;&amp; point.yo &gt;= point.xo - a &amp;&amp; point.yo &lt;= point.xo + a &amp;&amp; point.yo &lt;= -point.xo + 2 * n - a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; a &gt;&gt; m;</span><br><span class="line">cnt = 0;</span><br><span class="line">for(int i = 0; i &lt; m; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; biao[i].xo &gt;&gt; biao[i].yo;</span><br><span class="line">if(solve(biao[i]))</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">biao1[i].xo = biao[i].xo;</span><br><span class="line">biao1[i].yo = biao[i].yo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(biao1, biao1 + m, cmp);</span><br><span class="line">if(cnt == 0) puts(&quot;-1&quot;);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">for(int i = 0; i &lt; cnt; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; biao1[i].xo &lt;&lt; &quot; &quot; &lt;&lt; biao1[i].yo &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>code2:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e3+100;</span><br><span class="line">struct point&#123;</span><br><span class="line">long long x,y;</span><br><span class="line">bool friend operator&lt;(point a,point b)&#123;</span><br><span class="line">if(a.x==b.x) return a.y&gt;b.y;</span><br><span class="line">return a.x&gt;b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">long long n,a;</span><br><span class="line">bool check(point P)&#123;</span><br><span class="line">return -P.x+a&lt;=P.y&amp;&amp;-P.x+2*n-a&gt;=P.y&amp;&amp;P.x-a&lt;=P.y&amp;&amp;P.x+a&gt;=P.y;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">//freopen(&quot;17.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//freopen(&quot;17.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">vector&lt;point&gt; re;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a;</span><br><span class="line">int m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">if(check(p[i])) re.push_back(p[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(re.begin(),re.end());</span><br><span class="line">if(re.empty())&#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;re.size()&lt;&lt;endl;</span><br><span class="line">for(auto v:re) cout&lt;&lt;v.x&lt;&lt;&apos; &apos;&lt;&lt;v.y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Numbers-of-interval"><a href="#Numbers-of-interval" class="headerlink" title="Numbers of interval"></a>Numbers of interval</h2><p>Description:<br><img src="https://i.loli.net/2019/07/28/5d3da6d6aee4330530.png" alt></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1e6;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll a[maxx];</span><br><span class="line">ll b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">b[i] = a[i] + b[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">ll ans = 0;</span><br><span class="line">for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">int pos = lower_bound(b + 1, b + n + 1, k + b[i - 1]) - b;</span><br><span class="line">ans += (n - pos + 1);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">这题很巧妙，利用了前缀和与二分查找中的lower_bound</span><br><span class="line">首先是前缀和，不断相加前面每一个数的值，(比普通的定义一个变量相加更好用)存值，方便后便用到 </span><br><span class="line">找到第一个大于等于要求数的值，然后后边的数肯定都大，只要计数就行了 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="剪纸"><a href="#剪纸" class="headerlink" title="剪纸"></a>剪纸</h2><p>Description:<br>中国剪纸是一种用剪刀或刻刀在纸上剪刻花纹，用于装点生活或配合其他民俗活动的民间艺术。在中国，剪纸具有广泛的群众基础，交融于各族人民的社会生活，是各种民俗活动的重要组成部分。其传承赓续的视觉形象和造型格式，蕴涵了丰富的文化历史信息，表达了广大民众的社会认以、道德观念、实践经验、生活理想和审美情趣，具有认知、教化、表意、抒情、娱乐、交往等多重社会价值。<br>2006年5月20日，剪纸艺术遗产经国务院批准列入第一批国家级非物质文化遗产名录 。2009年9月28日至10月2日举行的联合国教科文组织保护非物质文化遗产政府间委员会第四次会议上，中国申报的中国剪纸项目入选“人类非物质文化遗产代表作名录”。<br>剪窗花最基本的操作为将剪纸进行多次对折，然后对对折之后的纸进行裁剪，展开后就是一个精美的艺术品。现在我们对问题进行化简，我们利用如下方法将一张形状矩形的纸按照对阵轴进行对折：<br><img src="https://i.loli.net/2019/07/28/5d3da765b1bc845726.png" alt><br>假设剪后的形状为一个三角形，则展开效果为：<br><img src="https://i.loli.net/2019/07/28/5d3da7671a20c72428.png" alt><br>现在给你一个对折两次且剪切后的图形，请你给出展开的图形形状。<br>输入格式<br>多组输入，处理到文件结束。<br>每组输入第一行两个数字n,m（1≤n,m≤100)。<br>接下来n行，每行m个字符，表示对折且剪切后的图形。<br>保证输入字符只包含 ‘.’ 和 ‘<em>’ 。<br>输出格式<br>输出展开后的图形。<br>样例<br><code>input</code><br>3 3<br>**. </em>..<br>…<br><code>output</code><br>……<br>..<strong>..<br>.**</strong>.<br>.<strong>**.<br>..</strong>..<br>……</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//F</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 1000+10;</span><br><span class="line">char mmp[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">&#123;</span><br><span class="line">memset(mmp, &apos;.&apos;, sizeof mmp);</span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; mmp[i][j];</span><br><span class="line">if(mmp[i][j] == &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">mmp[i + n][j + m] = &apos;*&apos;;</span><br><span class="line">mmp[i][j] = &apos;.&apos;;</span><br><span class="line">&#125;</span><br><span class="line">//cout &lt;&lt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">//puts(&quot;&quot;);</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">&#125;    </span><br><span class="line">for(int i = 0; i &lt; n * 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; m * 2; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(mmp[i][j] != &apos;*&apos;) mmp[i][j] = &apos;.&apos;;</span><br><span class="line">if(mmp[i][j] == &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">mmp[2 * n - i - 1][j] = &apos;*&apos;;</span><br><span class="line">mmp[i][2 * m - j - 1] = &apos;*&apos;;</span><br><span class="line">mmp[2 * n - i - 1][2 * m - j - 1] = &apos;*&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 2 * n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; 2 * m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; mmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">puts(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Fake-hpuoj-predictor"><a href="#Fake-hpuoj-predictor" class="headerlink" title="Fake hpuoj predictor"></a>Fake hpuoj predictor</h2><p>Description:<br>总所周知，HPU(Harmonious and Peaceful University) Online Judge具有一个强大的的rating(积分)系统，它采用的是国际上权威的ELO等级分制度(ELO Rating System)，LOL，守望先锋,codeforces,topcoder等知名游戏的排行均是采用此制度。<br>具体算法为：<br><img src="https://i.loli.net/2019/07/28/5d3da85871d0767682.png" alt><br>其中R(A)和R(B)为选手A和B初始的rating，那么E(A)和E(B)即为这两者进行对战后A和B各自获胜的期望。<br>本场比赛的积分公式即为<br><img src="https://i.loli.net/2019/07/28/5d3da86c66e9925370.png" alt><br>RA代表上轮比赛结束后的积分。<br>K为积分系数,对于不同等级的选手的K是不同的。<br>SA代表比赛实际总得分，对于每局比赛来说，每赢一个人就会加1分,输了不扣分。<br>EAi代表A与第i个选手比赛获胜的期望。<br>对于HPU Online Judge，用户等级表为:<br><img src="https://i.loli.net/2019/07/28/5d3da86da0dab96224.png" alt><br>codancer有一个成为Grand Master的梦想，已知他的初始rating为0，他总共参加了m场比赛，对于每场比赛有一个榜单，对于codancer来说，排在他前面的人都打败了他，排在他后面的人都输给了他，因此你可以通过和每个参加比赛的选手比较计算出总得分SA和总期望∑EAi。<br>那么最终codancer打完本场比赛后的rating为<br><img src="https://i.loli.net/2019/07/28/5d3da878ae7f273328.png" alt><br>现在他打完了这m场比赛后他迫切的想知道自己的rating变为了多少(因为管理员太懒了，已经鸽了m场的rating计算了)，现在他想让你帮他写一个预测器来预测一下。<br>输入格式<br>单组输入，第一行输入一个m(1≤m≤100)，代表codancer参加的比赛的数量。<br>接下来对于每场比赛：<br>第一行输入一个整数n代表有n(1≤n≤100)个人参加的比赛。<br>接下来n行每行输入一个字符串和数字，代表参赛选手的用户名和他的rating，codancer即为他自己的用户名(用户名长度不超过20)，假如输入的名字为codancer,则不用输入数字(其他参赛选手的rating是不会更新的，因为管理员太懒了)。<br>输出格式<br>输出codancer最终的rating，向上取整。<br>样例<br><code>input</code><br>3<br>5<br>tourist 2000<br>capryang 1900<br>boctorio 1800<br>dicer 1800<br>codancer<br>2<br>codancer<br>rookie 200<br>2<br>wzy 1500<br>codancer<br><code>output</code><br>12</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000+10;</span><br><span class="line">int n,m,a;</span><br><span class="line">struct node&#123;</span><br><span class="line">char name[30];</span><br><span class="line">double rating;</span><br><span class="line">&#125;p[maxn];</span><br><span class="line">double cal(double rating)&#123;</span><br><span class="line">if(rating&lt;1350) return 15.0;</span><br><span class="line">else if(rating&lt;1500) return 20.0;</span><br><span class="line">else if(rating&lt;1600) return 25.0;</span><br><span class="line">else if(rating&lt;1700) return 30.0;</span><br><span class="line">else if(rating&lt;1800) return 35.0;</span><br><span class="line">else return 50.0;</span><br><span class="line">&#125;</span><br><span class="line">double Rating(double rating)&#123;</span><br><span class="line">double k=cal(rating);</span><br><span class="line">double ea=0,sa=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0) continue; </span><br><span class="line">ea+=1.0/(1.0+pow(10,(p[i].rating-rating)/400.0));</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">sa=n-1-i;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">double now_rating=rating+k*(sa-ea);</span><br><span class="line">//return now_rating;</span><br><span class="line">return ceil(now_rating);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int m;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">double codancerNB_rating=0.0;</span><br><span class="line">while(m--)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,p[i].name);</span><br><span class="line">if(strcmp(p[i].name,&quot;codancer&quot;)==0)&#123;</span><br><span class="line">p[i].rating=codancerNB_rating;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">scanf(&quot;%lf&quot;,&amp;p[i].rating);</span><br><span class="line">&#125;</span><br><span class="line">codancerNB_rating=Rating(codancerNB_rating);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%.0lf\n&quot;,ceil(codancerNB_rating));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="花花与三猫Catlive"><a href="#花花与三猫Catlive" class="headerlink" title="花花与三猫Catlive"></a>花花与三猫Catlive</h2><p>Description:<br>“大佬”中分和“呆B”李白正在玩一个游戏，游戏规则是这样的：<br>游戏刚开始的时候，中分和李白相距L步，相对而望。<br>老父亲和老母亲手中各有一个M个面的均匀骰子。（也就是说可以随机生成[1,m]内的任意一个数字，且概率均等）<br>在每个回合开始的时候，老父亲和老母亲都会掷一下手中的骰子。<br>当老父亲的骰子掷到1的时候，中分可以向李白走一步。<br>当老母亲的骰子掷到m的时候，李白可以向中分走一步。<br>当中分和李白相遇的时候，游戏结束。<br>可是老父亲和老母亲刚刚拍完新节目，他们太累了，不想做这个游戏，但是他们还很想知道，这个游戏平均需要多少次才能结束。聪明的你，能告诉他们吗？<br>结果是一个实数s，可以证明s能被表示成一个分数 qp，请输出q⋅p−1，其中q−1表示q在模109+7意义下的逆元。<br>输入格式<br>第一行是一个正整数 T(1≤T≤1000)，表示测试样例的组数。<br>接下来T行，每行两个正整数L,M(1≤L,M≤1000)，含义如题面描述。<br>输出格式<br>输出包括T行，每行一个答案。<br>样例<br><code>input</code><br>2<br>1 2<br>2 1<br><code>output</code><br>1<br>1</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MOD = 1e9 + 7;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    int L, M;</span><br><span class="line">    while(T--)</span><br><span class="line">&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>code2:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//为啥多了几行，学长的意思是打cf的，防止被hack，哈哈</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">const int MOD = 1e9 + 7;</span><br><span class="line">int qpow(int a, int b, int mod)&#123;</span><br><span class="line">    int res = 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res = 1LL * res * a % mod;</span><br><span class="line">        a = 1LL * a * a % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int inv(int p, int mod)&#123;</span><br><span class="line">    return qpow(p, mod - 2, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    int L, M;</span><br><span class="line">    while(T--)&#123;</span><br><span class="line">        scanf(&quot;%d %d&quot;, &amp;L, &amp;M);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 1LL * L * M * 500000004 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Same-String"><a href="#Same-String" class="headerlink" title="Same String"></a>Same String</h2><p>Description:<br>有两个只由小写字母组成的长度为n的字符串s1,s2和m组字母对应关系，每一组关系由两个字母c1和c2组成，代表c1可以直接变成c2,你需要判断s1是否可以通过这m组关系转换为s2。<br>输入格式<br>第一行输入一个n(1≤n≤100)，代表字符串的长度。<br>第二行和第三行输入两个字符串s1,s2。<br>第四行输入一个m(1≤m≤325)，代表有m组关系。<br>接下来m行，第i行两个字符ui,vi,代表ui可以直接变为vi。<br>输出格式<br>如果s1可以通过这些m组关系转化变为s2，输出”YES”，否则输出”NO”。<br>样例<br><code>input</code><br>6<br>aabbcc<br>cdbcad<br>4<br>a c<br>c a<br>a d<br>b c<br><code>output</code><br>YES</p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+100;</span><br><span class="line">typedef long long ll;</span><br><span class="line">bool f[26][26];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,m;</span><br><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">char u,v;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">f[u-&apos;a&apos;][v-&apos;a&apos;]=1;</span><br><span class="line">&#125;</span><br><span class="line">for(int j=0;j&lt;26;j++)&#123;</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;</span><br><span class="line">for(int k=0;k&lt;26;k++)&#123;</span><br><span class="line">f[i][k]|=(f[i][j]&amp;f[j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool check=0;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">if(s1[i]!=s2[i])&#123;</span><br><span class="line">if(f[s1[i]-&apos;a&apos;][s2[i]-&apos;a&apos;]==0)&#123;</span><br><span class="line">check=1;break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(check)&#123;</span><br><span class="line">puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else puts(&quot;YES&quot;);</span><br><span class="line">// &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day10&quot;&gt;&lt;a href=&quot;#Day10&quot; class=&quot;headerlink&quot; title=&quot;Day10&quot;&gt;&lt;/a&gt;Day10&lt;/h1&gt;&lt;p&gt;今天是 又一次 &lt;code&gt;积分赛&lt;/code&gt;&lt;br&gt;我心态很好，真的很好，，，，真的很好。。。。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Day9</title>
    <link href="http://yoursite.com/2019/07/26/Day9/"/>
    <id>http://yoursite.com/2019/07/26/Day9/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-27T15:04:15.774Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --><h1 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h1><p>今天是 dfs 和 bfs 加训<br>继续学习 dfs 和 bfs，毕竟这一块还是非常重要的</p><a id="more"></a><p>OJ链接：<a href="https://vjudge.net/contest/314510#overview" target="_blank" rel="noopener">https://vjudge.net/contest/314510#overview</a></p><h2 id="Knight-Moves"><a href="#Knight-Moves" class="headerlink" title="Knight Moves"></a>Knight Moves</h2><p><code>Problem Description</code><br>Background<br>Mr Somurolov, fabulous chess-gamer indeed, asserts that no one else but him can move knights from one position to another so fast. Can you beat him?<br>The Problem<br>Your task is to write a program to calculate the minimum number of moves needed for a knight to reach one point from another, so that you have the chance to be faster than Somurolov.<br>For people not familiar with chess, the possible knight moves are shown in Figure 1.<br><img src="https://i.loli.net/2019/07/27/5d3c67890610a60979.jpg" alt></p><p><code>Input</code><br>The input begins with the number n of scenarios on a single line by itself.<br>Next follow n scenarios. Each scenario consists of three lines containing integer numbers. The first line specifies the length l of a side of the chess board (4 &lt;= l &lt;= 300). The entire board has size l <em>l. The second and third line contain pair of integers {0, …, l-1}</em>{0, …, l-1} specifying the starting and ending position of the knight on the board. The integers are separated by a single blank. You can assume that the positions are valid positions on the chess board of that scenario.<br><code>Output</code><br>For each scenario of the input you have to calculate the minimal amount of knight moves which are necessary to move from the starting point to the ending point. If starting point and ending point are equal,distance is zero. The distance must be written on a single line.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">0 0</span><br><span class="line">7 0</span><br><span class="line">100</span><br><span class="line">0 0</span><br><span class="line">30 50</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">Sample Output</span><br><span class="line">5</span><br><span class="line">28</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">int c, d;</span><br><span class="line">int ans, n;</span><br><span class="line">int vis[400][400];</span><br><span class="line">int dd[8][2] = &#123;</span><br><span class="line">-2, 1,</span><br><span class="line">-1, 2,</span><br><span class="line">1, 2,</span><br><span class="line">2, 1,</span><br><span class="line">-2, -1,</span><br><span class="line">-1, -2,</span><br><span class="line">1, -2,</span><br><span class="line">2, -1</span><br><span class="line">&#125;;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, step; </span><br><span class="line">&#125;;</span><br><span class="line">void bfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">ans = 0;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = x, e1.y = y, e1.step = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == c &amp;&amp; e1.y == d)</span><br><span class="line">&#123;</span><br><span class="line">ans = e1.step;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 8; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + dd[i][0];</span><br><span class="line">e2.y = e1.y + dd[i][1];</span><br><span class="line">if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; n &amp;&amp; vis[e2.x][e2.y] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[e2.x][e2.y] = 1;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">int a, b;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">bfs(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="变形课"><a href="#变形课" class="headerlink" title="变形课"></a>变形课</h2><p><code>Problem Description</code><br>呃……变形课上Harry碰到了一点小麻烦,因为他并不像Hermione那样能够记住所有的咒语而随意的将一个棒球变成刺猬什么的,但是他发现了变形咒语的一个统一规律:如果咒语是以a开头b结尾的一个单词,那么它的作用就恰好是使A物体变成B物体.<br>Harry已经将他所会的所有咒语都列成了一个表,他想让你帮忙计算一下他是否能完成老师的作业,将一个B(ball)变成一个M(Mouse),你知道,如果他自己不能完成的话,他就只好向Hermione请教,并且被迫听一大堆好好学习的道理.<br><code>Input</code><br>测试数据有多组。每组有多行，每行一个单词,仅包括小写字母,是Harry所会的所有咒语.数字0表示一组输入结束.<br><code>Output</code><br>如果Harry可以完成他的作业,就输出”Yes.”,否则就输出”No.”(不要忽略了句号)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">so</span><br><span class="line">soon</span><br><span class="line">river</span><br><span class="line">goes</span><br><span class="line">them</span><br><span class="line">got</span><br><span class="line">moon</span><br><span class="line">begin</span><br><span class="line">big</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Yes.</span><br><span class="line"></span><br><span class="line">Hint</span><br><span class="line">Harry 可以念这个咒语:&quot;big-got-them&quot;.</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">string ss;</span><br><span class="line">bool vis[1000 + 10];</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">int flag;</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;a[1000 + 10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(a[x].y == &apos;m&apos;)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int j = 0; j &lt; i; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[x].y == a[j].x &amp;&amp; vis[j] == 0)</span><br><span class="line">&#123;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">dfs(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">flag = 0;</span><br><span class="line">i = 0;</span><br><span class="line">while(cin &gt;&gt; ss)</span><br><span class="line">&#123;</span><br><span class="line">if(ss[0] != &apos;0&apos;)</span><br><span class="line">&#123;</span><br><span class="line">a[i].x = ss[0];</span><br><span class="line">a[i].y = ss[ss.size() - 1];</span><br><span class="line">i ++;</span><br><span class="line">&#125;</span><br><span class="line">else break;</span><br><span class="line">for(int j = 0; j &lt; i; j ++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[j].x == &apos;b&apos;)</span><br><span class="line">&#123;</span><br><span class="line">vis[j] = 1;</span><br><span class="line">dfs(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag) puts(&quot;Yes.&quot;);</span><br><span class="line">else puts(&quot;No.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Pet"><a href="#Pet" class="headerlink" title="Pet"></a>Pet</h2><p><code>Problem Description</code><br>一天早上小明醒来时发现他的宠物仓鼠不见了。 他在房间寻找但是没找到仓鼠。 他想用奶酪诱饵去找回仓鼠。 他把奶酪诱饵放在房间并且等待了好几天。 但是可怜的小明除了老鼠和蟑螂没见到任何东西。 他找到学校的地图发现地图上没有环路，并且学校里的每个站点都可以从他的房间到达。 奶酪诱饵的手册提到在距离D之内宠物必定会被吸引回来. 你的任务是帮助小明从给定的地图中有多少可能的站点是仓鼠的藏身处. 假定仓鼠一直藏在学校的某个站点并且两个相邻站点间的距离都是1个单位。<br><code>Input</code><br>输入包含多组数据。 第一行一个整数T (0&lt;T&lt;=10), 表示测试数据的组数。 每组数据, 第一行包含两个整数 N (0&lt;N&lt;=100000) 和 D(0&lt;D&lt;N). N 是学校里的站点数， D 是诱饵的影响距离。 下面 N-1行为地图描述, 每行一对 x 和 y(0&lt;=x,y&lt;N), 用一个空格隔开, 表示x和y两个站点是相邻的。小明的房间用0表示。<br><code>Output</code><br>对于每组数据，输出可能找到仓鼠的站点数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">10 2</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 8</span><br><span class="line">6 9</span><br><span class="line">Sample Output</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">bfs解法:</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">vector&lt;int&gt; v[maxx];</span><br><span class="line">int n, d;</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">memset(dis, 0, sizeof dis);</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(0);</span><br><span class="line">vis[0] = 1;</span><br><span class="line">dis[0] = 0;</span><br><span class="line">int cnt = 0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int f = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(dis[f] &gt; d)</span><br><span class="line">&#123;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">&#123;</span><br><span class="line">if(vis[v[f][i]] == 0)</span><br><span class="line">&#123;</span><br><span class="line">dis[v[f][i]] = dis[f] + 1;</span><br><span class="line">vis[v[f][i]] = 1;</span><br><span class="line">q.push(v[f][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//ios::sync_with_stdio(false);</span><br><span class="line">int T;</span><br><span class="line">int a, b;</span><br><span class="line">while(~scanf(&quot;%d&quot;,&amp;T))</span><br><span class="line">&#123;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;d);</span><br><span class="line">for(int i = 0; i &lt; n; i ++) v[i].clear();</span><br><span class="line">for(int i = 0;i &lt; n - 1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a, &amp;b);</span><br><span class="line">v[a].push_back(b);</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs解法:</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 1e5 + 50 ;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;G[maxn] ;</span><br><span class="line">int ans ;</span><br><span class="line">int n ,m ; </span><br><span class="line">int vis[maxn] ;</span><br><span class="line"></span><br><span class="line">void dfs(int st ,int l)</span><br><span class="line">&#123;</span><br><span class="line">if ( l &gt; m ) ans ++ ;</span><br><span class="line">int len = G[st].size() ;</span><br><span class="line">for (int i = 0 ; i &lt; len ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">if ( !vis[G[st][i]] )</span><br><span class="line">&#123;</span><br><span class="line">dfs(G[st][i] ,l + 1 ) ;</span><br><span class="line">vis[G[st][i]] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int t ; </span><br><span class="line">while(scanf(&quot;%d&quot;,&amp;t)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">while ( t -- )</span><br><span class="line">&#123;</span><br><span class="line">ans = 0 ;</span><br><span class="line">int a ,b ;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n ,&amp;m);</span><br><span class="line">for (int i = 0 ; i &lt;= n ; i ++ ) G[i].clear() ,vis[i] = 0 ;</span><br><span class="line">for (int i = 1 ; i &lt;= n - 1 ; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;a ,&amp;b ) ;</span><br><span class="line">G[a].push_back(b) ;</span><br><span class="line">//G[b].push_back(a) ;</span><br><span class="line">&#125;</span><br><span class="line">dfs(0 ,0 ) ;</span><br><span class="line">printf(&quot;%d\n&quot;,ans) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="蜘蛛牌"><a href="#蜘蛛牌" class="headerlink" title="蜘蛛牌"></a>蜘蛛牌</h2><p><code>Problem Description</code><br>蜘蛛牌是windows xp操作系统自带的一款纸牌游戏，游戏规则是这样的：只能将牌拖到比她大一的牌上面（A最小，K最大），如果拖动的牌上有按顺序排好的牌时，那么这些牌也跟着一起移动，游戏的目的是将所有的牌按同一花色从小到大排好，为了简单起见，我们的游戏只有同一花色的10张牌，从A到10，且随机的在一行上展开，编号从1到10，把第i号上的牌移到第j号牌上，移动距离为abs(i-j)，现在你要做的是求出完成游戏的最小移动距离。<br><code>Input</code><br>第一个输入数据是T，表示数据的组数。<br>每组数据有一行，10个输入数据，数据的范围是[1,10]，分别表示A到10，我们保证每组数据都是合法的。<br><code>Output</code><br>对应每组数据输出最小移动距离。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">Sample Output</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">思路：桶排原理记录每张牌的位置，遍历每张牌，枚举所有可能位置。</span><br><span class="line">将牌的大小作为下标。然后依次遍历。。。</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX = 0x3f3f3f3f;</span><br><span class="line">char a[100];</span><br><span class="line">char visit[100];</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line">void dfs(int num, int sum)</span><br><span class="line">&#123;</span><br><span class="line">    if (num==9)</span><br><span class="line">    &#123;</span><br><span class="line">        if(sum&lt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1; i&lt;10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(visit[i]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i] = 1;</span><br><span class="line">            for(int j=i+1; j&lt;=10; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(visit[j]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(num+1, sum + abs(a[j]-a[i]));</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visit[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T, x;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=1; i&lt;=10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">            a[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(visit, 0, sizeof(visit));</span><br><span class="line">        ans = MAX;</span><br><span class="line">        dfs(0, 0);</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h2><p><code>Problem Description</code><br>给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？<br><code>Input</code><br>第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x 1, y 1, x 2, y 2 (1 ≤ k ≤ 10, 1 ≤ x 1, x 2 ≤ n, 1 ≤ y 1, y 2 ≤ m),其中k表示gloria最多能转的弯数，(x 1, y 1), (x 2, y 2)表示两个位置，其中x 1，x 2对应列，y 1, y 2对应行。<br><code>Output</code><br>每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 5</span><br><span class="line">...**</span><br><span class="line">*.**.</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">*....</span><br><span class="line">1 1 1 1 3</span><br><span class="line">5 5</span><br><span class="line">...**</span><br><span class="line">*.**.</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">*....</span><br><span class="line">2 1 1 1 3</span><br><span class="line">Sample Output</span><br><span class="line">no</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e2 + 10;</span><br><span class="line">int n, m, a1, b1, a2, b2, k;</span><br><span class="line">char a[maxx][maxx];</span><br><span class="line">bool vis[maxx][maxx];</span><br><span class="line">int flag;</span><br><span class="line"></span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0,</span><br><span class="line">0, 1,</span><br><span class="line">0, -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2, e3;</span><br><span class="line">e1.x = a1 - 1, e1.y = b1 - 1, e1.step = -1;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.x == a2 - 1 &amp;&amp; e1.y == b2 - 1 &amp;&amp; e1.step &lt;= k)</span><br><span class="line">&#123;</span><br><span class="line">flag = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">while(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; a[e2.x][e2.y] == &apos;.&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(vis[e2.x][e2.y] == 0)</span><br><span class="line">&#123;</span><br><span class="line">e2.step = e1.step + 1;</span><br><span class="line">vis[e2.x][e2.y] = 1;</span><br><span class="line">q.push(e2);</span><br><span class="line">&#125;</span><br><span class="line">e3.x = e2.x + d[i][0];</span><br><span class="line">e3.y = e2.y + d[i][1];</span><br><span class="line">e2 = e3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;T); </span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i ++)</span><br><span class="line">for(int j = 0; j &lt; m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d %d %d %d %d&quot;,&amp;k, &amp;b1, &amp;a1, &amp;b2, &amp;a2);</span><br><span class="line">flag = 0;</span><br><span class="line">bfs();</span><br><span class="line">if(flag) puts(&quot;yes&quot;);</span><br><span class="line">else puts(&quot;no&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Kaitou-Kid-The-Phantom-Thief-2"><a href="#Kaitou-Kid-The-Phantom-Thief-2" class="headerlink" title="Kaitou Kid - The Phantom Thief (2)"></a>Kaitou Kid - The Phantom Thief (2)</h2><p><code>Problem Description</code><br>破解字迷之后，你得知Kid将会在展览开始后T分钟内盗取至少一颗宝石，并离开展馆。整个展馆呈矩形分布，划分为N*M个区域，有唯一的入口和出口（不能从出口进入，同样不能从入口出去）。由某个区域可直接移动至相邻四个区域中的一个，且最快需要一分钟。假设Kid进入放有宝石的区域即可盗取宝石，无需耗时。问至少要封锁几个区域（可以封锁放有宝石的区域，但不能封锁入口和出口）才能保证Kid无法完成任务。<br><code>Input</code><br>输入的第一行有一个整数C，代表有C组测试数据。每组测试数据的第一行有三个整数N，M，T(2&lt;=N,M&lt;=8,T&gt;0)。接下来N行M列为展馆布置图，其中包括：</p><p>‘S’：入口<br>‘E’：出口<br>‘J’：放有宝石的区域，至少出现一次<br>‘.’：空白区域<br>‘#’：墙<br><code>Output</code><br>对每组测试数据，输出至少要封锁的区域数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">5 5 5</span><br><span class="line">SJJJJ</span><br><span class="line">..##J</span><br><span class="line">.JJJJ</span><br><span class="line">.J...</span><br><span class="line">EJ...</span><br><span class="line">5 5 6</span><br><span class="line">SJJJJ</span><br><span class="line">..##J</span><br><span class="line">.JJJJ</span><br><span class="line">.J...</span><br><span class="line">EJ...</span><br><span class="line">Sample Output</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char mapp[10][10];</span><br><span class="line">int visit[10][10];</span><br><span class="line">int dir[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">int n,m,o;</span><br><span class="line">int sx,sy,ex,ey;</span><br><span class="line">int flag;</span><br><span class="line"></span><br><span class="line">struct stu</span><br><span class="line">&#123;</span><br><span class="line">int x,y;</span><br><span class="line">int d;</span><br><span class="line">int flag;</span><br><span class="line">&#125;;</span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(visit,0,sizeof(visit));</span><br><span class="line">stu x,y;</span><br><span class="line">queue&lt;stu&gt;root;</span><br><span class="line">x.x=sx;x.y=sy;x.flag=1;x.d=0;</span><br><span class="line">visit[x.x][x.y]=1;</span><br><span class="line">root.push(x);</span><br><span class="line">while(root.size())</span><br><span class="line">&#123;</span><br><span class="line">x=root.front();</span><br><span class="line">root.pop();</span><br><span class="line">if(x.x==ex&amp;&amp;x.y==ey&amp;&amp;x.flag==2&amp;&amp;x.d&lt;=o) return 0;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">y.x=x.x+dir[i][0];</span><br><span class="line">y.y=x.y+dir[i][1];</span><br><span class="line">y.d=x.d+1;</span><br><span class="line">if(mapp[y.x][y.y]==&apos;J&apos;) y.flag=2;</span><br><span class="line">else y.flag=x.flag;</span><br><span class="line">if(y.x&lt;0||y.x&gt;=n||y.y&lt;0||y.y&gt;=m||visit[y.x][y.y]==y.flag||mapp[y.x][y.y]==&apos;#&apos;||y.d&gt;o) continue;</span><br><span class="line">visit[y.x][y.y]=y.flag;</span><br><span class="line">root.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">if(bfs()) flag=1;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">char ma=mapp[i][j];</span><br><span class="line">if(ma==&apos;.&apos;||ma==&apos;J&apos;)</span><br><span class="line">&#123;</span><br><span class="line">mapp[i][j]=&apos;#&apos;;</span><br><span class="line">if(x&gt;0) dfs(x-1);</span><br><span class="line">if(flag) return;</span><br><span class="line">mapp[i][j]=ma;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin.sync_with_stdio(false);</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;o;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;mapp[i][j];</span><br><span class="line">if(mapp[i][j]==&apos;S&apos;) sx=i,sy=j;</span><br><span class="line">if(mapp[i][j]==&apos;E&apos;) ex=i,ey=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">flag=0;</span><br><span class="line">re=1&lt;&lt;30;</span><br><span class="line">for(int i=0;i&lt;=4;i++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(i);</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A计划"><a href="#A计划" class="headerlink" title="A计划"></a>A计划</h2><p><code>Problem Description</code><br>可怜的公主在一次次被魔王掳走一次次被骑士们救回来之后，而今，不幸的她再一次面临生命的考验。魔王已经发出消息说将在T时刻吃掉公主，因为他听信谣言说吃公主的肉也能长生不老。年迈的国王正是心急如焚，告招天下勇士来拯救公主。不过公主早已习以为常，她深信智勇的骑士LJ肯定能将她救出。<br>现据密探所报，公主被关在一个两层的迷宫里，迷宫的入口是S（0，0，0），公主的位置用P表示，时空传输机用#表示，墙用<em>表示，平地用.表示。骑士们一进入时空传输机就会被转到另一层的相对位置，但如果被转到的位置是墙的话，那骑士们就会被撞死。骑士们在一层中只能前后左右移动，每移动一格花1时刻。层间的移动只能通过时空传输机，且不需要任何时间。<br><code>Input</code><br>输入的第一行C表示共有C个测试数据，每个测试数据的前一行有三个整数N，M，T。 N，M迷宫的大小N</em>M（1 &lt;= N,M &lt;=10)。T如上所意。接下去的前N<em>M表示迷宫的第一层的布置情况，后N</em>M表示迷宫第二层的布置情况。<br><code>Output</code><br>如果骑士们能够在T时刻能找到公主就输出“YES”，否则输出“NO”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5 5 14</span><br><span class="line">S*#*.</span><br><span class="line">.#...</span><br><span class="line">.....</span><br><span class="line">****.</span><br><span class="line">...#.</span><br><span class="line"></span><br><span class="line">..*.P</span><br><span class="line">#.*..</span><br><span class="line">***..</span><br><span class="line">...*.</span><br><span class="line">*.#..</span><br><span class="line">Sample Output</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">int n, m, p;</span><br><span class="line">int ans;</span><br><span class="line">char a[2][30][30];</span><br><span class="line">bool vis[2][30][30];</span><br><span class="line">//int step[2][30][30];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x, y, z;</span><br><span class="line">int t;</span><br><span class="line">friend bool operator &lt; (node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">return a.t &gt; b.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">0, 1,</span><br><span class="line">0, -1,</span><br><span class="line">1, 0,</span><br><span class="line">-1, 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int bfs()</span><br><span class="line">&#123;</span><br><span class="line">memset(vis, 0, sizeof vis);</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">node e1, e2;</span><br><span class="line">e1.x = 0, e1.y = 0, e1.z = 0, e1.t = 0;</span><br><span class="line">q.push(e1);</span><br><span class="line">vis[e1.x][e1.y][e1.z] = 1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">e1 = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(e1.z == e.z &amp;&amp; e1.x == e.x &amp;&amp; e1.y == e.y)</span><br><span class="line">&#123;</span><br><span class="line">return e1.t;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">&#123;</span><br><span class="line">e2.x = e1.x + d[i][0];</span><br><span class="line">e2.y = e1.y + d[i][1];</span><br><span class="line">e2.z = e1.z;</span><br><span class="line">if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; vis[e2.z][e2.x][e2.y] == 0 &amp;&amp; a[e2.z][e2.x][e2.y] != &apos;*&apos;)</span><br><span class="line">&#123;</span><br><span class="line">if(a[e2.z][e2.x][e2.y] == &apos;#&apos;)</span><br><span class="line">&#123;</span><br><span class="line">e2.z = 1 - e2.z;</span><br><span class="line">if(a[e2.z][e2.x][e2.y] == &apos;*&apos; || a[e2.z][e2.x][e2.y] == &apos;#&apos;) continue;</span><br><span class="line">&#125;</span><br><span class="line">e2.t = e1.t + 1;</span><br><span class="line">if(e2.t &gt; p) continue;//必须剪枝 </span><br><span class="line">q.push(e2);</span><br><span class="line">vis[e2.z][e2.x][e2.y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while(T --)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">for(int i = 0; i &lt; 2; i ++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = 0; j &lt; n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(int k = 0; k &lt; m; k ++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i][j][k];</span><br><span class="line">if(a[i][j][k] == &apos;P&apos;)</span><br><span class="line">&#123;</span><br><span class="line">e.z = i;</span><br><span class="line">e.x = j;</span><br><span class="line">e.y = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = bfs();</span><br><span class="line">//cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">if(ans != -1 &amp;&amp; ans &lt;= p) puts(&quot;YES&quot;);</span><br><span class="line">else puts(&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Nightmare"><a href="#Nightmare" class="headerlink" title="Nightmare"></a>Nightmare</h2><p><code>Problem Description</code><br>Ignatius had a nightmare last night. He found himself in a labyrinth with a time bomb on him. The labyrinth has an exit, Ignatius should get out of the labyrinth before the bomb explodes. The initial exploding time of the bomb is set to 6 minutes. To prevent the bomb from exploding by shake, Ignatius had to move slowly, that is to move from one area to the nearest area(that is, if Ignatius stands on (x,y) now, he could only on (x+1,y), (x-1,y), (x,y+1), or (x,y-1) in the next minute) takes him 1 minute. Some area in the labyrinth contains a Bomb-Reset-Equipment. They could reset the exploding time to 6 minutes.</p><p>Given the layout of the labyrinth and Ignatius’ start position, please tell Ignatius whether he could get out of the labyrinth, if he could, output the minimum time that he has to use to find the exit of the labyrinth, else output -1.</p><p>Here are some rules:</p><ol><li>We can assume the labyrinth is a 2 array.</li><li>Each minute, Ignatius could only get to one of the nearest area, and he should not walk out of the border, of course he could not walk on a wall, too.</li><li>If Ignatius get to the exit when the exploding time turns to 0, he can’t get out of the labyrinth.</li><li>If Ignatius get to the area which contains Bomb-Rest-Equipment when the exploding time turns to 0, he can’t use the equipment to reset the bomb.</li><li>A Bomb-Reset-Equipment can be used as many times as you wish, if it is needed, Ignatius can get to any areas in the labyrinth as many times as you wish.</li><li>The time to reset the exploding time can be ignore, in other words, if Ignatius get to an area which contain Bomb-Rest-Equipment, and the exploding time is larger than 0, the exploding time would be reset to 6.<br><code>Input</code><br>The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.<br>Each test case starts with two integers N and M(1&lt;=N,Mm=8) which indicate the size of the labyrinth. Then N lines follow, each line contains M integers. The array indicates the layout of the labyrinth.<br>There are five integers which indicate the different type of area in the labyrinth:<br>0: The area is a wall, Ignatius should not walk on it.<br>1: The area contains nothing, Ignatius can walk on it.<br>2: Ignatius’ start position, Ignatius starts his escape from this position.<br>3: The exit of the labyrinth, Ignatius’ target position.<br>4: The area contains a Bomb-Reset-Equipment, Ignatius can delay the exploding time by walking to these areas.<br><code>Output</code><br>For each test case, if Ignatius can get out of the labyrinth, you should output the minimum time he needs, else you should just output -1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">3 3</span><br><span class="line">2 1 1</span><br><span class="line">1 1 0</span><br><span class="line">1 1 3</span><br><span class="line">4 8</span><br><span class="line">2 1 1 0 1 1 1 0</span><br><span class="line">1 0 4 1 1 0 4 1</span><br><span class="line">1 0 0 0 0 0 0 1</span><br><span class="line">1 1 1 4 1 1 1 3</span><br><span class="line">5 8</span><br><span class="line">1 2 1 1 1 1 1 4 </span><br><span class="line">1 0 0 0 1 0 0 1 </span><br><span class="line">1 4 1 0 1 1 0 1 </span><br><span class="line">1 0 0 0 0 3 0 1 </span><br><span class="line">1 1 4 1 1 1 1 1 </span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">13</span><br></pre></td></tr></table></figure></li></ol><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,a[10][10];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,step,time;</span><br><span class="line">&#125;;</span><br><span class="line">int d[4][2]=&#123;1,0,0,1,0,-1,-1,0&#125;;</span><br><span class="line">int ans;</span><br><span class="line">node now,mid;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(now);</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">now=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(now.time&lt;=0)continue;</span><br><span class="line">if(a[now.x][now.y]==3)</span><br><span class="line">&#123;</span><br><span class="line">ans=now.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">mid.x=now.x+d[i][0];</span><br><span class="line">mid.y=now.y+d[i][1];</span><br><span class="line">mid.step=now.step+1;</span><br><span class="line">mid.time=now.time-1;</span><br><span class="line">if(mid.x&lt;0||mid.x&gt;=n||mid.y&lt;0||mid.y&gt;=m||mid.time&lt;=0||a[mid.x][mid.y]==0)continue;</span><br><span class="line">if(a[mid.x][mid.y]==4)</span><br><span class="line">&#123;</span><br><span class="line">a[mid.x][mid.y]=0;</span><br><span class="line">mid.time=6;</span><br><span class="line">&#125;</span><br><span class="line">q.push(mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">if(a[i][j]==2)</span><br><span class="line">&#123;</span><br><span class="line">now.x=i,now.y=j,now.step=0,now.time=6;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="胜利大逃亡"><a href="#胜利大逃亡" class="headerlink" title="胜利大逃亡"></a>胜利大逃亡</h2><p><code>Problem Description</code><br>Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.</p><p>魔王住在一个城堡里,城堡是一个A<em>B</em>C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1.<br><img src="https://i.loli.net/2019/07/27/5d3c67ba74b7b52137.jpg" alt><br><code>Input</code><br>输入数据的第一行是一个正整数K,表明测试数据的数量.每组测试数据的第一行是四个正整数A,B,C和T(1&lt;=A,B,C&lt;=50,1&lt;=T&lt;=1000),它们分别代表城堡的大小和魔王回来的时间.然后是A块输入数据(先是第0块,然后是第1块,第2块……),每块输入数据有B行,每行有C个正整数,代表迷宫的布局,其中0代表路,1代表墙.(如果对输入描述不清楚,可以参考Sample Input中的迷宫描述,它表示的就是上图中的迷宫)</p><p>特别注意:本题的测试数据非常大,请使用scanf输入,我不能保证使用cin能不超时.在本OJ上请使用Visual C++提交.<br><code>Output</code><br>对于每组测试数据,如果Ignatius能够在魔王回来前离开城堡,那么请输出他最少需要多少分钟,否则输出-1.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">3 3 4 20</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 0 0 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 0 0 0</span><br><span class="line">0 1 1 0</span><br><span class="line">0 1 1 0</span><br><span class="line">Sample Output</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,k;</span><br><span class="line">int s[51][51][51];</span><br><span class="line">int vis[51][51][51];</span><br><span class="line">struct node&#123;</span><br><span class="line">int x,y,z,step;</span><br><span class="line">&#125;;</span><br><span class="line">node mz,mid,ne;</span><br><span class="line">int d[6][3]=&#123;1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1,0,0,-1&#125;,ans;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">mz.x=mz.y=mz.z=mz.step=0;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">q.push(mz);</span><br><span class="line">vis[0][0][0]=1;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if(mid.step&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">return  ;</span><br><span class="line">&#125;</span><br><span class="line">if(mid.x==a-1&amp;&amp;mid.y==b-1&amp;&amp;mid.z==c-1&amp;&amp;mid.step&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line">ans=mid.step;</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;6;i++)</span><br><span class="line">&#123;</span><br><span class="line">ne.x=mid.x+d[i][0];</span><br><span class="line">ne.y=mid.y+d[i][1];</span><br><span class="line">ne.z=mid.z+d[i][2];</span><br><span class="line">if(ne.x&lt;0||ne.x&gt;=a||ne.y&lt;0||ne.y&gt;=b||ne.z&lt;0||ne.z&gt;=c||vis[ne.x][ne.y][ne.z]||s[ne.x][ne.y][ne.z]==1)</span><br><span class="line">continue;</span><br><span class="line">ne.step=mid.step+1;</span><br><span class="line">vis[ne.x][ne.y][ne.z]=1;</span><br><span class="line">q.push(ne);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t;scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">ans=-1;</span><br><span class="line">scanf(&quot;%d %d %d %d&quot;,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">for(int i=0;i&lt;a;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;b;j++)</span><br><span class="line">&#123;</span><br><span class="line">for(int k=0;k&lt;c;k++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%1d&quot;,&amp;s[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfs();</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="A-strange-lift"><a href="#A-strange-lift" class="headerlink" title="A strange lift"></a>A strange lift</h2><p><code>Problem Description</code><br>计院有一个bug电梯，可能是hyk造的，很多bug，电梯只有两个按钮，“上”和“下”，电梯每层都可以停，每层都有一个数字Ki（0&lt;=Ki&lt;=n），当你在一层楼，你按“上”键会到1+K1层，你按“下”键会到1-K1层。当然，电梯不能升到N以上，也不能降到1以下。例如，有一个五层楼的建筑，k1=3，k2=3，k3=1，k4=2，k5=5。从第一层开始，你可以按“上”按钮，然后你就上到第四层，如果在第一层按“下”按钮，电梯就不能做到，因为你知道它不能下到负二层。负二楼不存在。<br>那么，你想从A层到B层，你至少要按多少次“上”或“下”按钮呢？<br><code>Input</code><br>输入由几个测试用例组成，每个测试用例包含两行。<br>第一行包含三个整数n，a，b（1&lt;=n，a，b&lt;=200），如上文所述，第二行包含n个整数k1，k2，….kn。<br>单个0表示输入的结束。<br><code>Output</code><br>对于每种情况下的输入输出一个整数，当你在A层，你必须按下按钮的最少次数，你想去B层。如果你不能到达B层，打印“-1”。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 5</span><br><span class="line">3 3 1 2 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a,b,meizi;</span><br><span class="line">int s[250][250],ans;</span><br><span class="line">int vis[250],step[250];</span><br><span class="line">void bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(x);</span><br><span class="line">vis[x]=1,step[x]=0;</span><br><span class="line">while(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">int mid=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">//cout&lt;&lt;mid&lt;&lt;endl;</span><br><span class="line">if(mid==b)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;&quot;?&quot;&lt;&lt;endl;</span><br><span class="line">ans=step[mid];</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s[x][i]&lt;&lt;endl;</span><br><span class="line">if(s[mid][i]&amp;&amp;vis[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">vis[i]=1;</span><br><span class="line">step[i]=step[mid]+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin&gt;&gt;n&amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">memset(vis,0,sizeof(vis));</span><br><span class="line">memset(step,0,sizeof(step));</span><br><span class="line">memset(s,0,sizeof(s));</span><br><span class="line">ans=-1;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;meizi;</span><br><span class="line">if(i+meizi&gt;=1&amp;&amp;i+meizi&lt;=n)s[i][meizi+i]=1;</span><br><span class="line">if(i-meizi&gt;=1&amp;&amp;i-meizi&lt;=n)  s[i][i-meizi]=1;</span><br><span class="line">&#125;</span><br><span class="line">bfs(a);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:12:00 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;Day9&quot;&gt;&lt;a href=&quot;#Day9&quot; class=&quot;headerlink&quot; title=&quot;Day9&quot;&gt;&lt;/a&gt;Day9&lt;/h1&gt;&lt;p&gt;今天是 dfs 和 bfs 加训&lt;br&gt;继续学习 dfs 和 bfs，毕竟这一块还是非常重要的&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="集训" scheme="http://yoursite.com/categories/ACM/%E9%9B%86%E8%AE%AD/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="算法集训" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%9B%86%E8%AE%AD/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜素算法" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自我感想</title>
    <link href="http://yoursite.com/2019/07/25/%E5%BF%83%E6%80%81/"/>
    <id>http://yoursite.com/2019/07/25/心态/</id>
    <published>2019-07-25T05:44:12.262Z</published>
    <updated>2019-08-11T04:31:16.618Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 13 2019 23:11:59 GMT+0800 (GMT+08:00) --><h1 id="心态"><a href="#心态" class="headerlink" title="心态"></a><center>心态</center></h1><p><center>人们常说：心态决定命运<br>今天，写下这篇文章也是想给自己指明方向<br>面朝大海，春暖花开<br><img src="/2019/07/25/心态/2.jpg" alt><br><a id="more"></a></center></p><h2 id="学习的目的"><a href="#学习的目的" class="headerlink" title="学习的目的"></a>学习的目的</h2><p>说实话，每个人都喜欢玩乐，但是，学习，只是让自己去获得某样东西<br>也许，可以是知识，也可以是技能，又或者是友谊等等</p><p>也有人说，学习是件痛苦的事<br>但我想说的只有一点，那就是</p><p>别逼着自己去学习<br>在学习之前，思考并问一下自己，是不是真的想获得某样东西~<br>可以说，没有人不想获得“超能力”，但是这些“超能力”又该怎么来<br>那就是我们的学习</p><p>很多人把学习固定化了，认为那就是学习书本上的知识<br>那样错了！学习不该有范围，因为学习是我们自己与生俱来的能力</p><p>我们总是想要去拥有些什么，然后就会不由自主地去选择学习</p><p>所有说，我们不能因为一些其他的事情而把自己的心态给坏了<br>保持一个良好的心态是我们能够成功的保证</p><p>永远永远永远要端正好自己的态度<br>切记不可半途而废，要做就一定要做到自己所能做到的最好！！！</p><h2 id="树立自己的目标"><a href="#树立自己的目标" class="headerlink" title="树立自己的目标"></a>树立自己的目标</h2><p>曾经很多次，我自己问过我自己，到底想要获得什么，亦或是成为什么样的人<br>也是每一次，都没有一个准确的回复，可能还是不能够很好地定位自己吧</p><p>给自己一个定位，的却是一件不容易的事情<br>毕竟每个人的人生都有无限个可能，想走什么样的路，成就什么样的人生<br>这只能由我们自己去决定</p><p>可能我们会为了某一件事而冲动，亦或是感触良多，从而自发的有了树立目标的冲动<br>也许这就是我们以后要走的路了，是啊~每一个人都不容易</p><h2 id="为什么学算法？"><a href="#为什么学算法？" class="headerlink" title="为什么学算法？"></a>为什么学算法？</h2><p>今天趁着自己有目标的时候给自己点明方向(我，为何要学习算法？)</p><h3 id="学算法的好处"><a href="#学算法的好处" class="headerlink" title="学算法的好处"></a>学算法的好处</h3><p>算法可以帮助人们思考，使得自己的大脑能够一直保持思考的状态，对自己的思维的提升很重要<br>学习算法也是为自己开辟另外一条路，为自己以后能够多一些打算<br>算法也能够很好地帮助我们学习解决一个问题的思路</p><h3 id="算法所能够带来的东西"><a href="#算法所能够带来的东西" class="headerlink" title="算法所能够带来的东西"></a>算法所能够带来的东西</h3><p>能够更好地帮助我们理解计算机的运行原理和内部结构<br>人们都说算法难，学着无聊，很没意思<br>就是因为枯燥无味，所以算法工程师才显得重要<br>计算机专业是一个应该处于持续思考的专业，是要动脑子的 专业<br>算法可以帮助我们很多，总之，学算法对我们自身没有坏处(除了掉头发厉害0.0)</p><h2 id="留给自己的话"><a href="#留给自己的话" class="headerlink" title="留给自己的话"></a>留给自己的话</h2><p>每个人都是在这个世界上第一次的活着<br>那么为什么不好好的为了自己活一次<br>是的，我们不知道结局或是怎样，我们只是为了自己的喜欢而选择去怎么样的生活</p><p>也许我们可能会在这条路上不断地抱怨，不自觉的去和别人对比，但是我只是想给自己说一句话<br>就算对比了，我能得到什么？？是失望亦或是开心？？但是这些没有用呀！！</p><p>为什么不好好的活在当下，喜欢什么就去做什么~<br>是啊，我们现在是没有什么能力，但是我们年轻呀，这就是我们最大的资本</p><p>千万不要比人说什么你就信什么，还是那句话，生而为人，都是第一次<br>别人又有什么能力对你指手画脚的呢？</p><p>为了自己，好好地活过每一天……<br>放慢脚步，去领略这个世界的美丽……<br>面对自己，活出人生的意义……<br><img src="/2019/07/25/心态/1.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 13 2019 23:11:59 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;心态&quot;&gt;&lt;a href=&quot;#心态&quot; class=&quot;headerlink&quot; title=&quot;心态&quot;&gt;&lt;/a&gt;&lt;center&gt;心态&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;&lt;center&gt;人们常说：心态决定命运&lt;br&gt;今天，写下这篇文章也是想给自己指明方向&lt;br&gt;面朝大海，春暖花开&lt;br&gt;&lt;img src=&quot;/2019/07/25/心态/2.jpg&quot; alt&gt;&lt;br&gt;&lt;/center&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
      <category term="想法" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/%E6%83%B3%E6%B3%95/"/>
    
    
      <category term="想法" scheme="http://yoursite.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
</feed>
