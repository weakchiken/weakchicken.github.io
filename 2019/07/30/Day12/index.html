<!-- build time:Wed Aug 14 2019 23:30:03 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1E92FB;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!0,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"83d60ad3"}),daovoice("update")</script><meta name="description" content="Day12今天学习的是 记忆化搜索(还是和dp有关)"><meta name="keywords" content="ACM,Algorithm,算法集训,动态规划"><meta property="og:type" content="article"><meta property="og:title" content="Day12"><meta property="og:url" content="http://yoursite.com/2019/07/30/Day12/index.html"><meta property="og:site_name" content="Dou Qing"><meta property="og:description" content="Day12今天学习的是 记忆化搜索(还是和dp有关)"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i.loli.net/2019/07/30/5d3fd1fb6077481048.png"><meta property="og:image" content="https://i.loli.net/2019/07/30/5d3fd359c720210349.jpg"><meta property="og:updated_time" content="2019-07-31T15:04:25.958Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Day12"><meta name="twitter:description" content="Day12今天学习的是 记忆化搜索(还是和dp有关)"><meta name="twitter:image" content="https://i.loli.net/2019/07/30/5d3fd1fb6077481048.png"><link rel="alternate" href="/atom.xml" title="Dou Qing" type="application/atom+xml"><link rel="canonical" href="http://yoursite.com/2019/07/30/Day12/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Day12 | Dou Qing</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Dou Qing</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">~人间有万紫千红~<br>~唯你是我情之所钟~</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/Day12/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Yan"><meta itemprop="description" content="学无止境 <br> 正是因为不会不懂，才会选择去学习"><meta itemprop="image" content="/images/touxiang2.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Dou Qing"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Day12</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-30T00:00:00+08:00">2019-07-30</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-07-31 23:04:25" itemprop="dateModified" datetime="2019-07-31T23:04:25+08:00">2019-07-31</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/集训/" itemprop="url" rel="index"><span itemprop="name">集训</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">18k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">16 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h1><p>今天学习的是 记忆化搜索(还是和dp有关)</p><a id="more"></a><p><a href="https://vjudge.net/contest/315672#overview" target="_blank" rel="noopener">OJ</a></p><h2 id="什么是记忆化搜索？"><a href="#什么是记忆化搜索？" class="headerlink" title="什么是记忆化搜索？"></a>什么是记忆化搜索？</h2><p>搜索的低效在于没有能够很好地处理重叠子问题；动态规划虽然比较好地处理了重叠子问题，但是在有些拓扑关系比较复杂的题目面前，又显得无奈。记忆化搜索正是在这样的情况下产生的，它采用搜索的形式和动态规划中递推的思想将这两种方法有机地综合在一起，扬长避短，简单实用，在信息学中有着重要的作用。<br>用一个公式简单地说：记忆化搜索=搜索的形式+动态规划的思想。<br>动态规划的一种变形就是记忆化搜索，就是根据动归方程写出递归式，然后在函数的开头直接返回以前计算过的结果，当然这样做也需要一个存储结构记下前面计算过的结果，所以又称为记忆化搜索。<br>记忆化搜索递归式动态规划</p><h3 id="记忆化搜索的思想"><a href="#记忆化搜索的思想" class="headerlink" title="记忆化搜索的思想"></a>记忆化搜索的思想</h3><pre><code>记忆化搜索的思想是,在搜索过程中，会有很多重复计算,如果我们能记录一些状态的答案，就可以减少重复搜索量 
</code></pre><h3 id="记忆化搜索的适用范围"><a href="#记忆化搜索的适用范围" class="headerlink" title="记忆化搜索的适用范围"></a>记忆化搜索的适用范围</h3><pre><code>根据记忆化搜索的思想，它是解决重复计算，而不是重复生成，也就是说，这些搜索必须是在搜索扩展路径的过程中分步计算的题目，也就是“搜索答案与路径相关”的题目，而不能是搜索一个路径之后才能进行计算的题目，必须要分步计算，并且搜索过程中，一个搜索结果必须可以建立在同类型问题的结果上，也就是类似于动态规划解决的那种。 
</code></pre><p>也就是说，他的问题表达，不是单纯生成一个走步方案，而是生成一个走步方案的代价等，而且每走一步，在搜索树/图中生成一个新状态，都可以精确计算出到此为止的费用，也就是，可以分步计算，这样才可以套用已经得到的答案</p><h3 id="记忆化搜索的核心实现"><a href="#记忆化搜索的核心实现" class="headerlink" title="记忆化搜索的核心实现"></a>记忆化搜索的核心实现</h3><pre><code> a. 首先，要通过一个表记录已经存储下的搜索结果，一般用哈希表实现 
 b.状态表示，由于是要用哈希表实现，所以状态最好可以用数字表示，常用的方法是把一个状态连写成一个p进制数字，然后把这个数字对应的十进制数字作为状态 
c.在每一状态搜索的开始，高效的使用哈希表搜索这个状态是否出现过，如果已经做过，直接调用答案，回溯 
d.如果没有，则按正常方法搜索 
</code></pre><h3 id="记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"><a href="#记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。" class="headerlink" title="记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"></a>记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。</h3><h2 id="Function-Run-Fun"><a href="#Function-Run-Fun" class="headerlink" title="Function Run Fun"></a>Function Run Fun</h2><p>Description:<br>We all love recursion! Don’t we?</p><p>Consider a three-parameter recursive function w(a, b, c):</p><p>if a &lt;= 0 or b &lt;= 0 or c &lt;= 0, then w(a, b, c) returns: 1</p><p>if a &gt; 20 or b &gt; 20 or c &gt; 20, then w(a, b, c) returns: w(20, 20, 20)</p><p>if a &lt; b and b &lt; c, then w(a, b, c) returns: w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)</p><p>otherwise it returns: w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)</p><p>This is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.<br><code>Input</code><br>The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.<br><code>Output</code><br>Print the value for w(a,b,c) for each triple.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 1 1</span><br><span class="line">2 2 2</span><br><span class="line">10 4 6</span><br><span class="line">50 50 50</span><br><span class="line">-1 7 18</span><br><span class="line">-1 -1 -1</span><br><span class="line">Sample Output</span><br><span class="line">w(1, 1, 1) = 2</span><br><span class="line">w(2, 2, 2) = 4</span><br><span class="line">w(10, 4, 6) = 523</span><br><span class="line">w(50, 50, 50) = 1048576</span><br><span class="line">w(-1, 7, 18) = 1</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//注意数组越界问题</span><br><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx = 500;</span><br><span class="line">//int ans;</span><br><span class="line">//int dp[maxx];</span><br><span class="line">int mp[maxx][maxx][maxx];</span><br><span class="line">int w(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">	if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return 1;</span><br><span class="line">	if(mp[a][b][c]) return mp[a][b][c];</span><br><span class="line">	else if(a &gt; 20 || b &gt; 20 || c &gt; 20) return mp[a][b][c] = w(20, 20, 20);</span><br><span class="line">	else if(a &lt; b &amp;&amp; b &lt; c) return mp[a][b][c] = w(a, b, c- 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);</span><br><span class="line">	else return mp[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a, b, c;</span><br><span class="line">	while(~scanf(&quot;%d %d %d&quot;,&amp;a, &amp;b, &amp;c))</span><br><span class="line">	&#123;</span><br><span class="line">		if(a == -1 &amp;&amp; b == -1 &amp;&amp; c== -1) break;</span><br><span class="line">		printf(&quot;w(%d, %d, %d) = %d\n&quot;,a, b, c,w(a, b, c));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h2><p>Description:<br>Glory非常喜欢玩滑滑梯游戏，下面给出了一个n,m的滑道，其中的数字表示滑道的高度。Glory可以从一个点出发向下滑行，每次只能滑行到相邻的位置(上下左右)中高度严格低于当前高度的地方，不能重复划行已经滑行过的地方，但他希望在这个滑道上滑行尽量远的距离，也即是找一条最长的滑道。<br><code>Input</code><br>第一行输入两个数n,m代表滑梯范围行n和列m(1 &lt;= n,m &lt;= 100)。下面是n行，每行有m个整数，代表高度h，(0&lt;=h&lt;=20000)<br><code>Output</code><br>输出一个值，代表Glory能够在滑滑梯上面滑行的最长长度是多少<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 3</span><br><span class="line">9 1 2</span><br><span class="line">5 6 7</span><br><span class="line">8 4 3</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">Sample Input</span><br><span class="line">4 7</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">1 5 1 1 1 1 1</span><br><span class="line">1 4 3 1 1 1 1</span><br><span class="line">1 5 6 7 8 1 1</span><br><span class="line">Sample Output</span><br><span class="line">7</span><br><span class="line">hint</span><br><span class="line">样例1：7-&gt;6-&gt;4-&gt;3 长度为4</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 200;</span><br><span class="line">int mp[maxx][maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int n , m; </span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">	0, 1,</span><br><span class="line">	0, -1,</span><br><span class="line">	-1, 0,</span><br><span class="line">	1, 0</span><br><span class="line">&#125;;</span><br><span class="line">int dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	//如果已经找过，退出此次搜索 </span><br><span class="line">	if(dp[x][y]) return dp[x][y];</span><br><span class="line">	int maxlen = 1;</span><br><span class="line">	int len;</span><br><span class="line">	for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int xx = x + d[i][0];</span><br><span class="line">		int yy = y + d[i][1];</span><br><span class="line">		if(xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &lt; m &amp;&amp; mp[xx][yy] &gt; mp[x][y])</span><br><span class="line">		&#123;</span><br><span class="line">			//能够遍历一次，步数+1 </span><br><span class="line">			len = dfs(xx, yy) + 1;</span><br><span class="line">			//不断比较，找该点所能够到达的最大长度 </span><br><span class="line">			maxlen = max(maxlen, len);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[x][y] = maxlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int ans;</span><br><span class="line">	while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		ans = 0;</span><br><span class="line">		memset(mp, 0, sizeof mp);</span><br><span class="line">		memset(dp, 0, sizeof dp);</span><br><span class="line">		for(int i = 0; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; m; j ++)</span><br><span class="line">				cin &gt;&gt; mp[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; m; j ++)</span><br><span class="line">			&#123;</span><br><span class="line">				//便利搜索每一个点所能到达的最大距离并保存 </span><br><span class="line">				dp[i][j] = dfs(i, j);</span><br><span class="line">				//不断比较找出最大值 </span><br><span class="line">				ans = max(ans, dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">//	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="漫步校园"><a href="#漫步校园" class="headerlink" title="漫步校园"></a>漫步校园</h2><p>Description:<br>LL最近沉迷于AC不能自拔，每天寝室、机房两点一线。由于长时间坐在电脑边，缺乏运动。他决定充分利用每次从寝室到机房的时间，在校园里散散步。整个HDU校园呈方形布局，可划分为n*n个小方格，代表各个区域。例如LL居住的18号宿舍位于校园的西北角，即方格(1,1)代表的地方，而机房所在的第三实验楼处于东南端的(n,n)。因有多条路线可以选择，LL希望每次的散步路线都不一样。另外，他考虑从A区域到B区域仅当存在一条从B到机房的路线比任何一条从A到机房的路线更近(否则可能永远都到不了机房了…)。现在他想知道的是，所有满足要求的路线一共有多少条。你能告诉他吗?<br><code>Input</code><br>每组测试数据的第一行为n(2=&lt;n&lt;=50)，接下来的n行每行有n个数，代表经过每个区域所花的时间t(0&lt;t&lt;=50)(由于寝室与机房均在三楼，故起点与终点也得费时)。<br><code>Output</code><br>针对每组测试数据，输出总的路线数(小于2^63)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">Sample Output</span><br><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	int x,y,c;</span><br><span class="line">	bool friend operator &lt; (node a,node b)&#123;</span><br><span class="line">		return a.c &gt; b.c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;r,w;</span><br><span class="line">ll ma[330][330];</span><br><span class="line">int vis[330][330];</span><br><span class="line">ll dis[330][330];</span><br><span class="line">ll dp[330][330];  	//记忆数组 要用long long  </span><br><span class="line">int Next[4][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;</span><br><span class="line">void bfs()</span><br><span class="line">&#123;			//bfs求终点到其余各点的最短路 </span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	r.x = r.y = n-1;r.c = ma[n-1][n-1];		//以终点作为起点 </span><br><span class="line">	dis[n-1][n-1] = ma[n-1][n-1];;			</span><br><span class="line">	vis[n-1][n-1] = 1;</span><br><span class="line">	q.push(r);</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		r = q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i = 0; i &lt; 4; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int nx = r.x + Next[i][0];</span><br><span class="line">			int ny = r.y + Next[i][1];</span><br><span class="line">			if(nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n || vis[nx][ny]) continue;</span><br><span class="line">			w.x = nx;</span><br><span class="line">			w.y = ny;</span><br><span class="line">			w.c = r.c + ma[nx][ny];</span><br><span class="line">			vis[nx][ny] = 1;</span><br><span class="line">			q.push(w); </span><br><span class="line">			dis[nx][ny] = w.c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dfs(int x,int y)</span><br><span class="line">&#123;		//dfs求最短路径条数 </span><br><span class="line">	if(x == n-1 &amp;&amp; y == n-1)</span><br><span class="line">	&#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(dp[x][y] != -1) return dp[x][y];</span><br><span class="line">	dp[x][y] = 0;</span><br><span class="line">		for(int i = 0; i &lt; 4; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			int nx = x + Next[i][0];</span><br><span class="line">			int ny = y + Next[i][1];</span><br><span class="line">			if( nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n || dis[nx][ny] &gt;= dis[x][y]) continue;</span><br><span class="line">			dp[x][y] += dfs(nx,ny);</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	while(cin &gt;&gt; n)</span><br><span class="line">	&#123; </span><br><span class="line">	for(int i = 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j = 0; j &lt; n; j++)</span><br><span class="line">			cin &gt;&gt; ma[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	memset(vis,0,sizeof vis); </span><br><span class="line">	memset(dp,-1,sizeof dp);</span><br><span class="line">	bfs();</span><br><span class="line">	cout &lt;&lt; dfs(0,0) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Free-Candies"><a href="#Free-Candies" class="headerlink" title="Free Candies"></a>Free Candies</h2><p>Description:<br>Little Bob is playing a game. He wants to win some candies in it - as many as possible. There are 4 piles, each pile contains N candies. Bob is given a basket which can hold at most 5 candies. Each time, he puts a candy at the top of one pile into the basket, and if there’re two candies of the same color in it, he can take both of them outside the basket and put them into his own pocket. When the basket is full and there are no two candies of the same color, the game ends. If the game is played perfectly, the game will end with no candies left in the piles. For example, Bob may play this game like this (N = 5):<br><img src="https://i.loli.net/2019/07/30/5d3fd1fb6077481048.png" alt><br>Note that diﬀerent numbers indicate diﬀerent colors, there are 20 kinds of colors numbered 1..20. ‘Seems so hard…’ Bob got very much puzzled. How many pairs of candies could he take home at most?<br><code>Input</code><br>The input will contain not more than 10 test cases. Each test case begins with a line containing a single integer n(1 ≤ n ≤ 40) representing the height of the piles. In the following n lines, each line contains four integers xi1, xi2, xi3, xi4 (in the range 1..20). Each integer indicates the color of the corresponding candy. The test case containing n = 0 will terminate the input, you should not give an answer to this case.<br><code>Output</code><br>Output the number of pairs of candies that the cleverest little child can take home. Print your answer in a single line for each test case.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 2 3 4 1 5 6 7 2 3 3 3 4 9 8 6 8 7 2 1 1 1 2 3 4 3 1 2 3 4 5 6 7 8 1 2 3 4 0</span><br><span class="line">Sample Output</span><br><span class="line">8 0 3</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int dp[55][55][55][55];   //记忆数组 </span><br><span class="line">bool Basket[555];	//标记篮子内的糖果 </span><br><span class="line">int ma[5][55];		//存糖果 </span><br><span class="line">int top[5];			//记录取到第几个糖果 例如 top[0] = 1 表示已经取到了第0堆的第一个糖果 </span><br><span class="line">int dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">	if(dp[top[0]][top[1]][top[2]][top[3]] != -1) return dp[top[0]][top[1]][top[2]][top[3]];		//判断是否搜索 </span><br><span class="line">	if(x == 5) return 0;		//如果篮子内糖果数为5  游戏结束 </span><br><span class="line">	int ans = 0;			</span><br><span class="line">	for(int i = 0; i &lt; 4; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(top[i] == n) continue;		//top[i] == n 表示第i堆取完，continue即取下一堆 </span><br><span class="line">		</span><br><span class="line">		int now = ma[i][top[i]]; 		//now 表示即将要放入篮子的糖果 </span><br><span class="line">		top[i]++;						//top[i]++为下次取糖果准备，即下一次取第i堆的下一个糖果 </span><br><span class="line">		</span><br><span class="line">		if(Basket[now])</span><br><span class="line">		&#123;				//如果篮子中存在与即将要放入篮子的糖果相同的糖果 </span><br><span class="line">			Basket[now] = 0;			//从篮子中拿出糖果 </span><br><span class="line">			ans = max(ans,dfs(x-1) + 1);	//更新结果 </span><br><span class="line">			Basket[now] = 1;			//回溯 </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			Basket[now] = 1;		//如果篮子中不存在这个糖果，将糖果放入篮子 </span><br><span class="line">			ans = max(ans,dfs(x+1)) ;  //更新结果 </span><br><span class="line">			Basket[now] = 0;		//回溯 </span><br><span class="line">		&#125;</span><br><span class="line">		top[i]--;			//回溯 </span><br><span class="line">	&#125;</span><br><span class="line">	return dp[top[0]][top[1]][top[2]][top[3]] = ans;  //记忆 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	while(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i = 0; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; 4; j++)</span><br><span class="line">				cin &gt;&gt; ma[j][i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp,-1,sizeof dp);</span><br><span class="line">		memset(Basket,0,sizeof Basket);</span><br><span class="line">		memset(top,0,sizeof top);</span><br><span class="line">		cout &lt;&lt; dfs(0) &lt;&lt; &apos;\n&apos;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Zipper"><a href="#Zipper" class="headerlink" title="Zipper"></a>Zipper</h2><p>Description:<br>Given three strings, you are to determine whether the third string can be formed by combining the characters in the first two strings. The first two strings can be mixed arbitrarily, but each must stay in its original order.</p><p>For example, consider forming “tcraete” from “cat” and “tree”:</p><p>String A: cat<br>String B: tree<br>String C: tcraete</p><p>As you can see, we can form the third string by alternating characters from the two strings. As a second example, consider forming “catrtee” from “cat” and “tree”:</p><p>String A: cat<br>String B: tree<br>String C: catrtee</p><p>Finally, notice that it is impossible to form “cttaree” from “cat” and “tree”.<br><code>Input</code><br>The first line of input contains a single positive integer from 1 through 1000. It represents the number of data sets to follow. The processing for each data set is identical. The data sets appear on the following lines, one data set per line.<br>For each data set, the line of input consists of three strings, separated by a single space. All strings are composed of upper and lower case letters only. The length of the third string is always the sum of the lengths of the first two strings. The first two strings will have lengths between 1 and 200 characters, inclusive.</p><p><code>Output</code><br>For each data set, print:<br>Data set n: yes<br>if the third string can be formed from the first two, or<br>Data set n: no<br>if it cannot. Of course n should be replaced by the data set number. See the sample output below for an example.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">cat tree tcraete</span><br><span class="line">cat tree catrtee</span><br><span class="line">cat tree cttaree</span><br><span class="line">Sample Output</span><br><span class="line">Data set 1: yes</span><br><span class="line">Data set 2: yes</span><br><span class="line">Data set 3: no</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">string str1, str2, str;</span><br><span class="line">bool pos;</span><br><span class="line">bool vis[maxx][maxx];</span><br><span class="line"></span><br><span class="line">void dfs(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">	//如果长度相同的话就回溯，表示结束 </span><br><span class="line">	if(x == str1.length() &amp;&amp; y == str2.length())</span><br><span class="line">	&#123;</span><br><span class="line">		//能够都遍历表示可以 </span><br><span class="line">		pos = 1;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(str1[x] != str[z] &amp;&amp; str2[y] != str[z]) return;</span><br><span class="line">	if(vis[x][y]) return;</span><br><span class="line">	vis[x][y] = 1;</span><br><span class="line">	if(str1[x] == str[z]) dfs(x + 1, y, z + 1); </span><br><span class="line">	if(str2[y] == str[z]) dfs(x, y + 1, z + 1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k = 1;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while(n --)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(vis, 0, sizeof vis);</span><br><span class="line">		cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str;</span><br><span class="line">		pos = 0;</span><br><span class="line">		dfs(0, 0, 0);</span><br><span class="line">		if(pos)</span><br><span class="line">			printf(&quot;Data set %d: yes\n&quot;,k ++);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;Data set %d: no\n&quot;, k ++);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Bone-Collector"><a href="#Bone-Collector" class="headerlink" title="Bone Collector"></a>Bone Collector</h2><p>Description:<br>Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave …<br>The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?<br><code>Input</code><br>The first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, (N &lt;= 1000 , V &lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.<br><code>Output</code><br>One integer per line representing the maximum of the total value (this number will be less than 2 31).<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1</span><br><span class="line">5 10</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line">Sample Output</span><br><span class="line">14</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 1e3 + 10;</span><br><span class="line">int w[maxx];</span><br><span class="line">int v[maxx];</span><br><span class="line">int s[maxx][maxx]; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t, n, m;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	while(t --)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(s, 0, sizeof s);</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i];	//骨骼价值 </span><br><span class="line">		for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i]; 	//骨骼体积 </span><br><span class="line">		//i表示第i个骨骼,j表示背包容量</span><br><span class="line">		for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt;= m; j ++)</span><br><span class="line">			&#123;</span><br><span class="line">				//是否选择第i个就要看容量是否大于它的重量 </span><br><span class="line">				if(j &gt;= w[i])</span><br><span class="line">				&#123;</span><br><span class="line">					//拿，那么就必须要占用当前背包的空间。即用当前背包总容量 j-w[i]，再占用1个物品空间，所以i-1，此时的总价值就是m [i-1][j-w[i]] 的解+当前的价值v[i] ，得到的就是放入当前物品得到的最优解。 </span><br><span class="line">					s[i][j] = max(s[i - 1][j], s[i - 1][j-w[i]] + v[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">					//不拿，那么就还是上一步的解，m[i-1][j]</span><br><span class="line">					s[i][j] = s[i - 1][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; s[n][m] &lt;&lt; endl;</span><br><span class="line">	&#125; 	</span><br><span class="line">		</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="FatMouse-and-Cheese"><a href="#FatMouse-and-Cheese" class="headerlink" title="FatMouse and Cheese"></a>FatMouse and Cheese</h2><p>Description:<br>有一种游戏是的玩法是这样的：<br>有一个n*n的格子,每个格子有一个数字。<br>遵循以下规则:</p><ol><li>玩家每次可以由所在格子向上下左右四个方向进行直线移动，每次移动的距离不得超过m</li><li>玩家一开始在第一行第一列，并且已经获得该格子的分值</li><li>玩家获得每一次移动到的格子的分值</li><li>玩家下一次移动到达的格子的分值要比当前玩家所在的格子的分值要大。</li><li>游戏所有数字加起来也不大，保证所有数字的和不会超过int型整数的范围</li><li>玩家仅能在n*n的格子内移动，超出格子边界属于非法操作</li><li>当玩家不能再次移动时，游戏结束<br>现在问你，玩家所能获得的最大得分是多少？<br><code>Input</code><br>有多组测试数据<br>每组测试样例第一行是两个整数n,m (1≤n≤100)(1≤m≤100),当n和m都是-1时为程序结束标志，直接退出即可<br>之后n行，每行n个数字，描述n*n的格子里的数字<br><code>Output</code><br>对于每组测试数据输出一行，这一行仅有一个整数，代表玩家所能获得的最高得分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3 1</span><br><span class="line">1 2 5</span><br><span class="line">10 11 6</span><br><span class="line">12 12 7</span><br><span class="line">-1 -1</span><br><span class="line">Sample Output</span><br><span class="line">37</span><br></pre></td></tr></table></figure></li></ol><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxx = 200;</span><br><span class="line">int a[maxx][maxx];</span><br><span class="line">int dp[maxx][maxx];</span><br><span class="line">int m, n;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">	0, 1,</span><br><span class="line">	0, -1,</span><br><span class="line">	1, 0,</span><br><span class="line">	-1, 0</span><br><span class="line">&#125;;</span><br><span class="line">int dfs(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	if(dp[x][y]) return dp[x][y];</span><br><span class="line">	int maxsorce = 0;</span><br><span class="line">	int sorce;</span><br><span class="line">	for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j = 1; j &lt;= m; j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			int xx = x + (d[i][0]) * j; </span><br><span class="line">			int yy = y + (d[i][1]) * j;</span><br><span class="line">			if(xx &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; a[xx][yy] &gt; a[x][y])</span><br><span class="line">			&#123;</span><br><span class="line">				sorce = dfs(xx, yy);</span><br><span class="line">				maxsorce = max(sorce, maxsorce);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	dp[x][y] = maxsorce + a[x][y];//回溯到x，y的最大和(顺序从大到小) </span><br><span class="line">	return dp[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	while(~scanf(&quot;%d %d&quot;,&amp;n, &amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		memset(a, 0, sizeof a);</span><br><span class="line">		memset(dp, 0, sizeof dp);</span><br><span class="line">		if(n == -1 &amp;&amp; m == -1) break;</span><br><span class="line">		for(int i = 0; i &lt; n ; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; n; j ++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; a[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(0, 0);</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; dp[0][0] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1.关于移动问题：由于题中移动范围并不是1可以扩大到1*k所以仍然需要构造移动方向，只是需要dfs四周范围为k。 </span><br><span class="line">2.可以从最后一个节点往回遍历，也就是需要先找到最大的值，然后往回找，如何实现呢，用递归。但是需要标记路径不然会爆的。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="送披萨"><a href="#送披萨" class="headerlink" title="送披萨"></a>送披萨</h2><p>Description:<br>何老板开了一家披萨店，有一天突然收到了n个客户的订单。<br>何老板所在的城市只有一条笔直的大街，我们可以将它想象成数轴，其中位置0是何老板的披萨店，第i个客户所在的位置为Pi,每个客户的位置都不同。如果何老板给第i个客户送披萨，客户会支付Ei-Ti块钱，其中Ti是何老板到达他家的时刻。当然，如果到得太晚，会使得Ei-Ti＜0,这时，何老板可以选择不给他送餐，免得他反过来找何老板要钱。<br>何老板店里面只有一个送餐车（单位时间行驶单位长度的距离），因此只能往返送餐，如下图所示就是一条线路，图中第一行的数字是位置Pi,第二行是Ei。<br>你的任务是帮助何老板计算出最大的收益。<br><img src="https://i.loli.net/2019/07/30/5d3fd359c720210349.jpg" alt><br><code>Input</code><br>第一行，一个整数n<br>第二行，n个空格间隔的整数，从左往右给出了每个客户的位置Pi，即P1,P2,……,Pn<br>第三行，n个空格间隔的整数，从左往右给出了每个客户对应的Ei，即E1,E2,……,En<br><code>Output</code><br>一行，一个整数，表示所求的最佳收益。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">-6 -3 -1 2 5</span><br><span class="line"> 27 10 2 5 20</span><br><span class="line">Sample Output</span><br><span class="line">32</span><br><span class="line">Sample Input</span><br><span class="line">6</span><br><span class="line"> 1 2 4 7 11 14</span><br><span class="line"> 3 6 2 5 18 10</span><br><span class="line">Sample Output</span><br><span class="line">13</span><br><span class="line">Sample Input</span><br><span class="line">11</span><br><span class="line">-14 -13 -12 -11 -10 1 2 3 4 5 100</span><br><span class="line"> 200 200 200 200 200 200 200 200 200 200 200</span><br><span class="line">Sample Output</span><br><span class="line">1937</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">1 ≤ n ≤ 100</span><br><span class="line">-100,000 ≤ Pi ≤ 100,000  且Pi!=0</span><br><span class="line"> 0＜ Ei ≤ 100,000</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[205][205][205][2];</span><br><span class="line">bool mark[205][205][205][2];</span><br><span class="line">int n;</span><br><span class="line">int pos[205],e[205],start;</span><br><span class="line">int dp(int l,int r,int cnt,int p)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if(mark[l][r][cnt][p])return f[l][r][cnt][p];</span><br><span class="line">    mark[l][r][cnt][p]=true;</span><br><span class="line">    if(cnt==0)return f[l][r][cnt][p]=0;</span><br><span class="line">    if(p==0)&#123;</span><br><span class="line">        for(i=1;i&lt;l;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(i,r,cnt-1,0)+e[i]-cnt*abs(pos[l]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=r+1;i&lt;=n+1;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(l,i,cnt-1,1)+e[i]-cnt*abs(pos[l]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        for(i=1;i&lt;l;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(i,r,cnt-1,0)+e[i]-cnt*abs(pos[r]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=r+1;i&lt;=n+1;i++)&#123;</span><br><span class="line">            f[l][r][cnt][p]=max(f[l][r][cnt][p],dp(l,i,cnt-1,1)+e[i]-cnt*abs(pos[r]-pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return f[l][r][cnt][p];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,j,ans=0;</span><br><span class="line">    start=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;pos[i];</span><br><span class="line">        if(pos[i]&gt;0&amp;&amp;start==0)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            pos[i+1]=pos[i];</span><br><span class="line">            pos[i]=0;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">        cin&gt;&gt;e[i];</span><br><span class="line">        if(start==i)&#123;</span><br><span class="line">            e[i+1]=e[i];</span><br><span class="line">            e[i]=0;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=max(ans,dp(start,start,i,0));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></div><div style="text-align:center;color:#ccc;font-size:14px">---------------- The End ----------------</div><div><div id="reward-container"><div></div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Yan 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Yan 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/ACM/" rel="tag"><i class="fa fa-tag"></i> ACM</a> <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a> <a href="/tags/算法集训/" rel="tag"><i class="fa fa-tag"></i> 算法集训</a> <a href="/tags/动态规划/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/07/29/Day11/" rel="next" title="Day11"><i class="fa fa-chevron-left"></i> Day11</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/07/31/Day13/" rel="prev" title="Day13">Day13 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDIxMi8yMDc0NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/touxiang2.png" alt="Yan"><p class="site-author-name" itemprop="name">Yan</p><div class="site-description motion-element" itemprop="description">学无止境<br>正是因为不会不懂，才会选择去学习</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">25</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/weakdouqing/weakdouqing.github.io" title="GitHub &rarr; https://github.com/weakdouqing/weakdouqing.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=UGFkaGFnYmNpYGUQISF_Mz89" title="E-Mail &rarr; http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=UGFkaGFnYmNpYGUQISF_Mz89" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://cndrew.cn/" title="https://cndrew.cn/" rel="noopener" target="_blank">drew</a></li><li class="links-of-blogroll-item"><a href="https://blog.todest.cn/" title="https://blog.todest.cn/" rel="noopener" target="_blank">亦往沧劫</a></li><li class="links-of-blogroll-item"><a href="http://www.sqdxwz.com/" title="http://www.sqdxwz.com/" rel="noopener" target="_blank">赴京书生</a></li><li class="links-of-blogroll-item"><a href="http://inkwall233.github.io" title="http://inkwall233.github.io" rel="noopener" target="_blank">城墙墨</a></li><li class="links-of-blogroll-item"><a href="https://me.csdn.net/Acer12138" title="https://me.csdn.net/Acer12138" rel="noopener" target="_blank">shemplle</a></li><li class="links-of-blogroll-item"><a href="https://blogzhy.cn" title="https://blogzhy.cn" rel="noopener" target="_blank">ZHY</a></li></ul></div><p></p><div class="hitokoto-title"><i class="fa fa-paragraph"></i> <b>每日一句</b></div><div id="hitokoto">:D 获取中...</div><i id="hitofrom">:D 获取中...</i><script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script><script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script><script>fetch("https://v1.hitokoto.cn").then(function(t){return t.json()}).then(function(t){var o=document.getElementById("hitokoto");o.innerText="       "+t.hitokoto;var n=document.getElementById("hitofrom");n.innerText="——"+t.from+" "})["catch"](function(t){console.error(t)})</script></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Day12"><span class="nav-number">1.</span> <span class="nav-text">Day12</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是记忆化搜索？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是记忆化搜索？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#记忆化搜索的思想"><span class="nav-number">1.1.1.</span> <span class="nav-text">记忆化搜索的思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记忆化搜索的适用范围"><span class="nav-number">1.1.2.</span> <span class="nav-text">记忆化搜索的适用范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记忆化搜索的核心实现"><span class="nav-number">1.1.3.</span> <span class="nav-text">记忆化搜索的核心实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。"><span class="nav-number">1.1.4.</span> <span class="nav-text">记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-Run-Fun"><span class="nav-number">1.2.</span> <span class="nav-text">Function Run Fun</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑雪"><span class="nav-number">1.3.</span> <span class="nav-text">滑雪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漫步校园"><span class="nav-number">1.4.</span> <span class="nav-text">漫步校园</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Free-Candies"><span class="nav-number">1.5.</span> <span class="nav-text">Free Candies</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Zipper"><span class="nav-number">1.6.</span> <span class="nav-text">Zipper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bone-Collector"><span class="nav-number">1.7.</span> <span class="nav-text">Bone Collector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FatMouse-and-Cheese"><span class="nav-number">1.8.</span> <span class="nav-text">FatMouse and Cheese</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#送披萨"><span class="nav-number">1.9.</span> <span class="nav-text">送披萨</span></a></li></ol></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Yan</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">567k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:36</span></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><br><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共172.8k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="true"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/schemes/muse.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script><script>window.livereOptions={refer:"2019/07/30/Day12/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>$(".highlight").not(".gist .highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var i=document.execCommand("copy");i?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" color="0,255,255" opacity="1" zindex="-2" count="105" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="/live2d-widget-master/autoload.js"></script><script type="text/javascript" src="/js/src/clicklove.js"></script></body></html><!-- rebuild by neat -->