<!-- build time:Sun Jul 28 2019 22:00:39 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="Day8今天学习了 树的直径树的直径-&amp;gt;双重BFS/DFS跑图学的效果整体还行"><meta name="keywords" content="Algorithm,图论,ACM,算法集训,搜素算法"><meta property="og:type" content="article"><meta property="og:title" content="Day8"><meta property="og:url" content="http://yoursite.com/2019/07/25/Day8/index.html"><meta property="og:site_name" content="Dou Qing"><meta property="og:description" content="Day8今天学习了 树的直径树的直径-&amp;gt;双重BFS/DFS跑图学的效果整体还行"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i.loli.net/2019/07/25/5d393d850e3b759478.jpg"><meta property="og:updated_time" content="2019-07-25T13:58:21.613Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Day8"><meta name="twitter:description" content="Day8今天学习了 树的直径树的直径-&amp;gt;双重BFS/DFS跑图学的效果整体还行"><meta name="twitter:image" content="https://i.loli.net/2019/07/25/5d393d850e3b759478.jpg"><link rel="canonical" href="http://yoursite.com/2019/07/25/Day8/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Day8 | Dou Qing</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Dou Qing</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">~总是要错过万千风景~<br>~才能如愿等到你~</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/25/Day8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Yan"><meta itemprop="description" content="学无止境 <br> 正是因为不会不懂，才会选择去学习"><meta itemprop="image" content="/images/touxiang2.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Dou Qing"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Day8</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-25 00:00:00 / 修改时间：21:58:21" itemprop="dateCreated datePublished" datetime="2019-07-25T00:00:00+08:00">2019-07-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/集训/" itemprop="url" rel="index"><span itemprop="name">集训</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">14k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">13 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><p>今天学习了 树的直径<br>树的直径-&gt;双重BFS/DFS跑图<br>学的效果整体还行<br><a id="more"></a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h3><p>树（tree）是包含n（n&gt;0）个结点的有穷集，其中：<br>每个元素称为结点（node）；<br>有一个特定的结点被称为根结点或树根（root）；<br>除根结点之外的其余数据元素被分为m（m≥0）个互不相交<br>的集合T1，T2，…Tm−1，其中每一个集合Tm−1（1≤i≤m）<br>本身也是一棵树，被称作原树的子树（subtree）。</p><h3 id="树的直径的定义"><a href="#树的直径的定义" class="headerlink" title="树的直径的定义"></a>树的直径的定义</h3><p>树中距离最大的两个结点之间的距离称为树的直径。</p><h3 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h3><p>两次dfs或bfs。第一次任意选一个点进行dfs(bfs)找到离它最远的<br>点，此点就是最长路的一个端点，再以此点进行dfs（bfs），找到<br>离它最远的点，此点就是最长路的另一个端点，于是就找到了树<br>的直径。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>假设此树的最长路径是从s到t,我们选择的点为u。<br>反证法：假设搜到的点是v。<br>1、v在这条最长路径上，那么dis[u,v]&gt;dis[u,v]+dis[v,s],显然矛<br>盾。<br>2、v不在这条最长路径上，我们在最长路径上选择一个点为po，<br>则dis[u,v]&gt;dis[u,po]+dis[po,t]，那么有dis[s,v]=dis[s,po]+dis[po,u]<br>+dis[u,v]&gt;dis[s,po]+dis[po,t]=dis[s,t],即dis[s,v]&gt;dis[s,t],矛盾。<br>也许你想说u本身就在最长路径，或则其它的一些情况，但其实<br>都能用类似于上面的反证法来证明的。<br>综上所述，你两次dfs(bfs)就可以求出最长路径的两个端点和路<br>径长度</p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>POJ 2631<br>POJ 1985<br>POJ 1383</p><h3 id="带权图相关代码模板-用的时候要合理变动"><a href="#带权图相关代码模板-用的时候要合理变动" class="headerlink" title="带权图相关代码模板(用的时候要合理变动)"></a>带权图相关代码模板(用的时候要合理变动)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;cstring&gt;</span><br><span class="line"># include &lt;queue&gt;</span><br><span class="line"># include &lt;vector&gt;</span><br><span class="line">const int maxn =100020;</span><br><span class="line">using namespace std ;</span><br><span class="line">int dis[maxn], ans ;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;pair&lt;int ,int&gt; &gt; V[maxn];</span><br><span class="line"></span><br><span class="line">int bfs(int x)&#123;</span><br><span class="line">	memset(dis ,0 , sizeof(dis));</span><br><span class="line">	memset(vis ,0 , sizeof(vis));</span><br><span class="line">	queue&lt;int &gt; Q ;</span><br><span class="line">	Q.push(x);</span><br><span class="line">	vis[x]=1;</span><br><span class="line">	int point=0;</span><br><span class="line">	while (!Q.empty())&#123;</span><br><span class="line">		int F = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		if(dis[F] &gt; ans )&#123;</span><br><span class="line">			ans = dis[F];</span><br><span class="line">			point = F;</span><br><span class="line">		&#125;</span><br><span class="line">		pair &lt;int ,int &gt; t ;</span><br><span class="line">		for (int i =0; i &lt; V [F].size (); i ++)&#123;</span><br><span class="line">			t = V[F][i];</span><br><span class="line">			if(vis[t.first]==0)&#123;</span><br><span class="line">				vis[t.first]=1;</span><br><span class="line">				dis[t.first]=dis[F] + t.second ;</span><br><span class="line">				Q.push (t.first);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int x,y,z ;</span><br><span class="line">	输入</span><br><span class="line">	ans=0;</span><br><span class="line">	int point=bfs(1);</span><br><span class="line">	ans=0;</span><br><span class="line">	bfs(point);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl ;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OJ链接：<a href="https://vjudge.net/contest/313488#overview" target="_blank" rel="noopener">https://vjudge.net/contest/313488#overview</a></p><h2 id="Labyrinth"><a href="#Labyrinth" class="headerlink" title="Labyrinth"></a>Labyrinth</h2><p><code>Problem Description</code><br>The northern part of the Pyramid contains a very large and complicated labyrinth. The labyrinth is divided into square blocks, each of them either filled by rock, or free. There is also a little hook on the floor in the center of every free block. The ACM have found that two of the hooks must be connected by a rope that runs through the hooks in every block on the path between the connected ones. When the rope is fastened, a secret door opens. The problem is that we do not know which hooks to connect. That means also that the neccessary length of the rope is unknown. Your task is to determine the maximum length of the rope we could need for a given labyrinth.<br><code>Input</code><br>The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers C and R (3 &lt;= C,R &lt;= 1000) indicating the number of columns and rows. Then exactly R lines follow, each containing C characters. These characters specify the labyrinth. Each of them is either a hash mark (#) or a period (.). Hash marks represent rocks, periods are free blocks. It is possible to walk between neighbouring blocks only, where neighbouring blocks are blocks sharing a common side. We cannot walk diagonally and we cannot step out of the labyrinth.<br>The labyrinth is designed in such a way that there is exactly one path between any two free blocks. Consequently, if we find the proper hooks to connect, it is easy to find the right path connecting them.<br><code>Output</code><br>Your program must print exactly one line of output for each test case. The line must contain the sentence “Maximum rope length is X.” where Xis the length of the longest path between any two free blocks, measured in blocks.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">###</span><br><span class="line">#.#</span><br><span class="line">###</span><br><span class="line">7 6</span><br><span class="line">#######</span><br><span class="line">#.#.###</span><br><span class="line">#.#.###</span><br><span class="line">#.#.#.#</span><br><span class="line">#.....#</span><br><span class="line">#######</span><br><span class="line">Sample Output</span><br><span class="line">Maximum rope length is 0.</span><br><span class="line">Maximum rope length is 8.</span><br><span class="line">Hint</span><br><span class="line">Huge input, scanf is recommended. </span><br><span class="line">If you use recursion, maybe stack overflow. and now C++/c &apos;s stack size is larger than G++/gcc</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n, m;</span><br><span class="line">char a[2000][3000];</span><br><span class="line">int dis[2000][2000];</span><br><span class="line">int ans;</span><br><span class="line">int d[4][2] = &#123;</span><br><span class="line">	1, 0,</span><br><span class="line">	-1, 0,</span><br><span class="line">	0, 1,</span><br><span class="line">	0, -1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">&#125;first, second;</span><br><span class="line"></span><br><span class="line">void bfs(node first)</span><br><span class="line">&#123;</span><br><span class="line">	ans = 0;</span><br><span class="line">	memset(dis, -1, sizeof dis);</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	node e1, e2;</span><br><span class="line">	e1.x = first.x, e1.y = first.y, dis[e1.x][e1.y] = 0;</span><br><span class="line">	q.push(e1);</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		e1 = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line"></span><br><span class="line">		for(int i = 0; i &lt; 4; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			e2.x = e1.x + d[i][0];</span><br><span class="line">			e2.y = e1.y + d[i][1];</span><br><span class="line">			if(e2.x &gt;= 0 &amp;&amp; e2.y &gt;= 0 &amp;&amp; e2.x &lt; n &amp;&amp; e2.y &lt; m &amp;&amp; a[e2.x][e2.y] != &apos;#&apos; &amp;&amp; dis[e2.x][e2.y] == -1)</span><br><span class="line">			&#123;</span><br><span class="line">				q.push(e2);</span><br><span class="line">				dis[e2.x][e2.y] = dis[e1.x][e1.y] + 1;</span><br><span class="line">				if(ans &lt; dis[e2.x][e2.y])</span><br><span class="line">				&#123;</span><br><span class="line">					ans = dis[e2.x][e2.y];</span><br><span class="line">					second.x = e2.x;</span><br><span class="line">					second.y = e2.y;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	while(T --)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">		for(int i = 0; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%s&quot;,&amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 0; j &lt; m; j ++)</span><br><span class="line">			&#123;</span><br><span class="line">				if(a[i][j] == &apos;.&apos;)</span><br><span class="line">				&#123;</span><br><span class="line">					first.x = i;</span><br><span class="line">					first.y = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(first);</span><br><span class="line">		bfs(second);</span><br><span class="line">		printf(&quot;Maximum rope length is %d.\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cow-Marathon"><a href="#Cow-Marathon" class="headerlink" title="Cow Marathon"></a>Cow Marathon</h2><p><code>Problem Description</code><br>After hearing about the epidemic of obesity in the USA, Farmer John wants his cows to get more exercise, so he has committed to create a bovine marathon for his cows to run. The marathon route will include a pair of farms and a path comprised of a sequence of roads between them. Since FJ wants the cows to get as much exercise as possible he wants to find the two farms on his map that are the farthest apart from each other (distance being measured in terms of total length of road on the path between the two farms). Help him determine the distances between this farthest pair of farms.<br>有n个农田和m条路，以及每条路的方向（方向在这道题中没有用），求最长的一条路，也就是两点间的最大距离，即树的直径.<br><code>Input</code></p><ul><li>Lines 1…..: Same input format as “Navigation Nightmare”.<br><code>Output</code></li><li>Line 1: An integer giving the distance between the farthest pair of farms.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">7 6</span><br><span class="line">1 6 13 E</span><br><span class="line">6 3 9 E</span><br><span class="line">3 5 7 S</span><br><span class="line">4 1 3 N</span><br><span class="line">2 4 20 W</span><br><span class="line">4 7 2 S</span><br><span class="line">Sample Output</span><br><span class="line">52</span><br><span class="line">Hint</span><br><span class="line">The longest marathon runs from farm 2 via roads 4, 1, 6 and 3 to farm 5 and is of length 20+3+13+9+7=52.</span><br></pre></td></tr></table></figure></li></ul><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn = 5e5 + 10;//数组不要太大，不然会超时 </span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn];</span><br><span class="line">int ans, en;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector &lt;pair&lt;int,int&gt; &gt;V[maxn];</span><br><span class="line">int bfs(int x) </span><br><span class="line">&#123;</span><br><span class="line">	ans = 0;</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line"> 	memset(vis,0,sizeof(vis));</span><br><span class="line"> 	queue&lt;int&gt; q;</span><br><span class="line"> 	q.push(x);</span><br><span class="line">	vis[x]=1;</span><br><span class="line"> 	en = 0;</span><br><span class="line"> 	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line"> 		int f = q.front();</span><br><span class="line"> 		q.pop();</span><br><span class="line"> 		if(dis[f] &gt; ans)</span><br><span class="line">		&#123;</span><br><span class="line"> 			ans = dis[f];</span><br><span class="line">			en = f;</span><br><span class="line">		&#125;</span><br><span class="line"> 		pair&lt;int,int &gt; t;</span><br><span class="line"> 		for(int i = 0; i &lt; V[f].size();i ++)</span><br><span class="line">		&#123;</span><br><span class="line"> 			t = V[f][i];</span><br><span class="line"> 			if(vis[t.first] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[t.first] = 1;</span><br><span class="line"> 				dis[t.first] = dis[f] + t.second;</span><br><span class="line"> 				q.push(t.first);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return en;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	char c[100];</span><br><span class="line">	int n, m;</span><br><span class="line">	while(~scanf(&quot;%d %d&quot;,&amp;m,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i = 0;i &lt; n; i ++)</span><br><span class="line">			V[i].clear();//注意每次用完vector之后要清空 </span><br><span class="line">		for(int i = 0; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d %d %d %s&quot;,&amp;x,&amp;y,&amp;z,&amp;c);</span><br><span class="line">			V[x].push_back(make_pair(y,z));</span><br><span class="line">	 		V[y].push_back(make_pair(x,z));</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(1);</span><br><span class="line">	 	bfs(en);</span><br><span class="line">	 	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Roads-in-the-North"><a href="#Roads-in-the-North" class="headerlink" title="Roads in the North"></a>Roads in the North</h2><p><code>Problem Description</code><br>Building and maintaining roads among communities in the far North is an expensive business. With this in mind, the roads are build such that there is only one route from a village to a village that does not pass through some other village twice.<br>Given is an area in the far North comprising a number of villages and roads among them such that any village can be reached by road from any other village. Your job is to find the road distance between the two most remote villages in the area.</p><p>The area has up to 10,000 villages connected by road segments. The villages are numbered from 1.<br><code>Input</code><br>Input to the problem is a sequence of lines, each containing three positive integers: the number of a village, the number of a different village, and the length of the road segment connecting the villages in kilometers. All road segments are two-way.<br><code>Output</code><br>You are to output a single integer: the road distance between the two most remote villages in the area.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5 1 6</span><br><span class="line">1 4 5</span><br><span class="line">6 3 9</span><br><span class="line">2 6 8</span><br><span class="line">6 1 7</span><br><span class="line">Sample Output</span><br><span class="line">22</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">typedef long long ll;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt;v[maxx];</span><br><span class="line">int ans;</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int en; //不要用end，是一个保留字 </span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">	//每次bfs都要初始化 </span><br><span class="line">	ans = 0;</span><br><span class="line">	memset(vis, 0, sizeof vis);</span><br><span class="line">	memset(dis, 0, sizeof dis);</span><br><span class="line">	//套用bfs模板 </span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	vis[x] = 1;</span><br><span class="line">	q.push(x);</span><br><span class="line">	en = 0;</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int f = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		//随着ans的不断更新，直到找到一个端点，标记下来 </span><br><span class="line">		if(dis[f] &gt; ans)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = dis[f];</span><br><span class="line">			en = f;//一段的开始 </span><br><span class="line">		&#125;</span><br><span class="line">		//创建新的数对，表示的是与v[]相连的点 </span><br><span class="line">		pair&lt;int , int&gt; p;</span><br><span class="line">		//遍历所有地点 ，根据距离，寻找一端的点 </span><br><span class="line">		for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			p = v[f][i];//表示 寻找这个点在图中的所有可能 </span><br><span class="line">			if(vis[p.first] == 0) //如果这个地点没有经过 </span><br><span class="line">			&#123;</span><br><span class="line">				vis[p.first] = 1;//先标记 </span><br><span class="line">				dis[p.first] = dis[f] + p.second;//加上距离 ，更新ans </span><br><span class="line">				q.push(p.first);//入队，寻找这个点的所有可能性 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	return en;//将一端的标记返回出去 </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	while(~scanf(&quot;%d %d %d&quot;,&amp;x, &amp;y, &amp;z))</span><br><span class="line">	&#123;</span><br><span class="line">		//存图，意思就是将与x,y相连的点和对应的权值存储起来，因为是双向的，所以权值一样 </span><br><span class="line">		v[x].push_back(make_pair(y, z));</span><br><span class="line">		v[y].push_back(make_pair(x, z));</span><br><span class="line">	&#125;</span><br><span class="line">	//第一次bfs随便找个点去找到整个图的一个端点 </span><br><span class="line">	bfs(1);</span><br><span class="line">	//第二次bfs从一个端点出发去找另一个端点，即为树的直径 </span><br><span class="line">	bfs(en);</span><br><span class="line">	//输出答案ans </span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">题意：</span><br><span class="line">有10000个村庄，有很多条路，现在这些路已经把村庄都连了起来，求最远的两个村庄的路的距离。</span><br><span class="line"></span><br><span class="line">思路，把每一边都历遍一下，找到两个距离最远的村庄。</span><br><span class="line"></span><br><span class="line">这里有一个结论，在图中，要找到距离最远的两点，先随便从一个点入手BFS，找到距离这个点最远的点，在从这个点BFS找到距离这点最远的点，这两点之间的距离就是这棵树的直径。所以直接进行BFS搜索就行了。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p></p><h2 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h2><p><code>Problem Description</code><br>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.</p><p><img src="https://i.loli.net/2019/07/25/5d393d850e3b759478.jpg" alt></p><p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p><p><code>Input</code><br>输入文件包含多组测试样例。在每组样例中，第一行中都有自然数n（n&lt;=10000），然后是（n-1）行，其中包含对计算机的描述。第i行包含两个自然数-第i计算机所连接的计算机和用于连接的电缆长度。电缆总长度不超过10^9。输入行中的数字用空格分隔。<br><code>Output</code><br>对于每组样例，输出n行。第i行第i台计算机的到其他计算机的最大长度Si（1&lt;=i&lt;=n）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">提示</span><br><span class="line">示例输入与此图对应。从图中，你可以看到计算机4离1最远，所以s1=3。计算机4和5是距离2最远的，所以s2=2。计算机5是离3最远的，所以s3=3。我们也得到了s4=4，s5=4。</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e5 + 10;</span><br><span class="line">typedef long long ll;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; v[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int diss[maxx];</span><br><span class="line">int ans;</span><br><span class="line"></span><br><span class="line">int bfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">	ans = 0;</span><br><span class="line">	memset(vis, 0, sizeof vis);</span><br><span class="line">	memset(dis, 0, sizeof dis);</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(x);</span><br><span class="line">	vis[x] = 1;</span><br><span class="line">	int point;</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int f = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(ans &lt; dis[f])</span><br><span class="line">		&#123;</span><br><span class="line">			ans = dis[f];</span><br><span class="line">			point = f;</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; v[f].size(); i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(vis[v[f][i].first] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[v[f][i].first] = 1;</span><br><span class="line">				dis[v[f][i].first] = v[f][i].second + dis[f];</span><br><span class="line">				q.push(v[f][i].first);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	int a, b;</span><br><span class="line">	while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i = 0; i &lt;= n; i ++) v[i].clear();</span><br><span class="line">		for(int i = 1; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			v[i + 1].push_back(make_pair(a, b));</span><br><span class="line">			v[a].push_back(make_pair(i + 1, b));</span><br><span class="line">		&#125;</span><br><span class="line">		int point;</span><br><span class="line">		point = bfs(bfs(1));</span><br><span class="line">		for(int i = 1; i &lt;= n; i ++) diss[i] = dis[i];</span><br><span class="line">		bfs(point);</span><br><span class="line">		for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; max(dis[i], diss[i]) &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Farthest-Nodes-in-a-Tree"><a href="#Farthest-Nodes-in-a-Tree" class="headerlink" title="Farthest Nodes in a Tree"></a>Farthest Nodes in a Tree</h2><p><code>Problem Description</code><br>Given a tree (a connected graph with no cycles), you have to find the farthest nodes in the tree. The edges of the tree are weighted and undirected. That means you have to find two nodes in the tree whose distance is maximum amongst all nodes.<br><code>Input</code><br>Input starts with an integer T (≤ 10), denoting the number of test cases.<br>Each case starts with an integer n (2 ≤ n ≤ 30000) denoting the total number of nodes in the tree. The nodes are numbered from 0 to n-1. Each of the next n-1 lines will contain three integers u v w (0 ≤ u, v &lt; n, u ≠ v, 1 ≤ w ≤ 10000) denoting that node u and v are connected by an edge whose weight is w. You can assume that the input will form a valid tree.<br><code>Output</code><br>For each case, print the case number and the maximum distance.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">0 1 20</span><br><span class="line">1 2 30</span><br><span class="line">2 3 50</span><br><span class="line">5</span><br><span class="line">0 2 20</span><br><span class="line">2 1 10</span><br><span class="line">0 3 29</span><br><span class="line">0 4 50</span><br><span class="line">Sample Output</span><br><span class="line">Case 1: 100</span><br><span class="line">Case 2: 80</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//e</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">const int maxn = 5e5 + 10;</span><br><span class="line">using namespace std;</span><br><span class="line">int dis[maxn];</span><br><span class="line">int ans, en;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector &lt;pair&lt;int,int&gt; &gt;V[maxn];</span><br><span class="line">int bfs(int x) </span><br><span class="line">&#123;</span><br><span class="line">	ans = 0;</span><br><span class="line">	memset(dis,0,sizeof(dis));</span><br><span class="line"> 	memset(vis,0,sizeof(vis));</span><br><span class="line"> 	queue&lt;int&gt;q;</span><br><span class="line"> 	q.push(x);</span><br><span class="line">	vis[x]=1;</span><br><span class="line"> 	en = 0;</span><br><span class="line"> 	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line"> 		int f = q.front();</span><br><span class="line"> 		q.pop();</span><br><span class="line"> 		if(dis[f] &gt; ans)</span><br><span class="line">		&#123;</span><br><span class="line"> 			ans = dis[f];</span><br><span class="line">			en = f;</span><br><span class="line">		&#125;</span><br><span class="line"> 		pair&lt;int,int &gt; t;</span><br><span class="line"> 		for(int i = 0; i &lt; V[f].size();i ++)</span><br><span class="line">		&#123;</span><br><span class="line"> 			t = V[f][i];</span><br><span class="line"> 			if(vis[t.first] == 0)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[t.first] = 1;</span><br><span class="line"> 				dis[t.first] = dis[f] + t.second;</span><br><span class="line"> 				q.push(t.first);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return en;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	int T, n;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	int k = 1;</span><br><span class="line">	while(T --)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		for(int i = 0;i &lt; n; i ++)</span><br><span class="line">			V[i].clear();//注意每次用完vector之后要清空 </span><br><span class="line">		for(int i = 0; i &lt; n - 1; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			V[x].push_back(make_pair(y,z));</span><br><span class="line">	 		V[y].push_back(make_pair(x,z));</span><br><span class="line">		&#125;</span><br><span class="line">		bfs(0);</span><br><span class="line">	 	bfs(en);</span><br><span class="line">	 	printf(&quot;Case %d: %d\n&quot;,k ++, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></div><div style="text-align:center;color:#ccc;font-size:14px">---------------- The End ----------------</div><div><div id="reward-container"><div></div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Yan 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Yan 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Algorithm/" rel="tag"># Algorithm</a> <a href="/tags/图论/" rel="tag"># 图论</a> <a href="/tags/ACM/" rel="tag"># ACM</a> <a href="/tags/算法集训/" rel="tag"># 算法集训</a> <a href="/tags/搜素算法/" rel="tag"># 搜素算法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/07/24/Day7/" rel="next" title="Day7"><i class="fa fa-chevron-left"></i> Day7</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/07/25/心态/" rel="prev" title="自我感想">自我感想 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDIxMi8yMDc0NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/touxiang2.png" alt="Yan"><p class="site-author-name" itemprop="name">Yan</p><div class="site-description motion-element" itemprop="description">学无止境<br>正是因为不会不懂，才会选择去学习</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://cndrew.cn/" title="https://cndrew.cn/" rel="noopener" target="_blank">drew</a></li><li class="links-of-blogroll-item"><a href="https://blog.todest.cn/" title="https://blog.todest.cn/" rel="noopener" target="_blank">亦往沧劫</a></li><li class="links-of-blogroll-item"><a href="http://www.sqdxwz.com/" title="http://www.sqdxwz.com/" rel="noopener" target="_blank">赴京书生</a></li><li class="links-of-blogroll-item"><a href="http://inkwall233.github.io" title="http://inkwall233.github.io" rel="noopener" target="_blank">城墙墨</a></li><li class="links-of-blogroll-item"><a href="https://me.csdn.net/Acer12138" title="https://me.csdn.net/Acer12138" rel="noopener" target="_blank">shemplle</a></li><li class="links-of-blogroll-item"><a href="https://blogzhy.cn" title="https://blogzhy.cn" rel="noopener" target="_blank">ZHY</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Day8"><span class="nav-number">1.</span> <span class="nav-text">Day8</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">1.1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是树？"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树的直径的定义"><span class="nav-number">1.1.2.</span> <span class="nav-text">树的直径的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求解方法"><span class="nav-number">1.1.3.</span> <span class="nav-text">求解方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#证明"><span class="nav-number">1.1.4.</span> <span class="nav-text">证明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关题目"><span class="nav-number">1.1.5.</span> <span class="nav-text">相关题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带权图相关代码模板-用的时候要合理变动"><span class="nav-number">1.1.6.</span> <span class="nav-text">带权图相关代码模板(用的时候要合理变动)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Labyrinth"><span class="nav-number">1.2.</span> <span class="nav-text">Labyrinth</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cow-Marathon"><span class="nav-number">1.3.</span> <span class="nav-text">Cow Marathon</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Roads-in-the-North"><span class="nav-number">1.4.</span> <span class="nav-text">Roads in the North</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Computer"><span class="nav-number">1.5.</span> <span class="nav-text">Computer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Farthest-Nodes-in-a-Tree"><span class="nav-number">1.6.</span> <span class="nav-text">Farthest Nodes in a Tree</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Yan</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">302k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">4:35</span></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><br><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共93.6k字</span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="true"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/affix.js?v=7.1.1"></script><script src="/js/schemes/pisces.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script><script>window.livereOptions={refer:"2019/07/25/Day8/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>$(".highlight").not(".gist .highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var i=document.execCommand("copy");i?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" color="87,250,255" opacity="0.85" zindex="-2" count="105" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/clicklove.js"></script></body></html><!-- rebuild by neat -->