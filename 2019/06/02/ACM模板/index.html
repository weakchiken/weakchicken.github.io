<!-- build time:Sun Mar 08 2020 22:08:18 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1E92FB;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2"><link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!0,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!0,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="ACM模板总结了一些可能会用到的模板下面是一些板子，可能不全"><meta name="keywords" content="ACM"><meta property="og:type" content="article"><meta property="og:title" content="ACM模板"><meta property="og:url" content="http://yoursite.com/2019/06/02/ACM模板/index.html"><meta property="og:site_name" content="Dou Qing"><meta property="og:description" content="ACM模板总结了一些可能会用到的模板下面是一些板子，可能不全"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i.loli.net/2019/08/27/Ky61jAnMgTQkIzB.jpg"><meta property="og:updated_time" content="2019-08-27T08:43:34.913Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ACM模板"><meta name="twitter:description" content="ACM模板总结了一些可能会用到的模板下面是一些板子，可能不全"><meta name="twitter:image" content="https://i.loli.net/2019/08/27/Ky61jAnMgTQkIzB.jpg"><link rel="alternate" href="/atom.xml" title="Dou Qing" type="application/atom+xml"><link rel="canonical" href="http://yoursite.com/2019/06/02/ACM模板/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>ACM模板 | Dou Qing</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Dou Qing</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">~人间有万紫千红~<br>~唯你是我情之所钟~</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-resources"><a href="/resources" rel="section"><i class="menu-item-icon fa fa-fw fa-download"></i><br>资源站</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/ACM模板/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Yan"><meta itemprop="description" content="学无止境 <br> 正是因为不会不懂，才会选择去学习"><meta itemprop="image" content="/images/touxiang2.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Dou Qing"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">ACM模板</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-06-02 10:06:44" itemprop="dateCreated datePublished" datetime="2019-06-02T10:06:44+08:00">2019-06-02</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-27 16:43:34" itemprop="dateModified" datetime="2019-08-27T16:43:34+08:00">2019-08-27</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/Algorithm/模板/" itemprop="url" rel="index"><span itemprop="name">模板</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论数：</span> <a href="/2019/06/02/ACM模板/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/06/02/ACM模板/" itemprop="commentCount"></span> </a></span><span id="/2019/06/02/ACM模板/" class="leancloud_visitors" data-flag-title="ACM模板"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">33k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">30 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="ACM模板"><a href="#ACM模板" class="headerlink" title="ACM模板"></a><center>ACM模板</center></h1><p><center>总结了一些可能会用到的模板<br>下面是一些板子，可能不全<br><img src="https://i.loli.net/2019/08/27/Ky61jAnMgTQkIzB.jpg" alt><br><a id="more"></a></center></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define _CRT_SBCURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace std<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> maxn = <span class="number">110</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> INF = <span class="number">0x3f3f3f3f</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h2><h3 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |埃式筛法|</span></span><br><span class="line"><span class="comment">    |快速筛选素数|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> prime[maxn];  </span><br><span class="line"><span class="built_in">bool</span> is_prime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sieve(<span class="built_in">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;   <span class="comment">//  注意数组大小是n</span></span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])&#123;</span><br><span class="line">            prime[p++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + i; j &lt;= n; j += i)  <span class="comment">//  轻剪枝，j必定是i的倍数</span></span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">//  返回素数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |快速幂|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> long long LL;   <span class="comment">//  视数据大小的情况而定</span></span><br><span class="line"></span><br><span class="line">LL powerMod(LL x, LL n, LL m)</span><br><span class="line">&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>  (n &amp; <span class="number">1</span>) <span class="comment">//  判断是否为奇数，若是则true</span></span><br><span class="line">            res = (res * x) % m;</span><br><span class="line">        x = (x * x) % m;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;    <span class="comment">//  相当于n /= 2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数模拟"><a href="#大数模拟" class="headerlink" title="大数模拟"></a>大数模拟</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">大数加法</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |大数模拟加法|</span></span><br><span class="line"><span class="comment">    |用string模拟|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx, thanks to caojiji|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add1</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">""</span> &amp;&amp; s2 == <span class="string">""</span>)   <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">""</span>)   <span class="keyword">return</span> s2;</span><br><span class="line">    <span class="keyword">if</span> (s2 == <span class="string">""</span>)   <span class="keyword">return</span> s1;</span><br><span class="line">    <span class="built_in">string</span> maxx = s1, minn = s2;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() &lt; s2.length())&#123;</span><br><span class="line">        maxx = s2;</span><br><span class="line">        minn = s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = maxx.length() - <span class="number">1</span>, b = minn.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        maxx[a--] += minn[i] - <span class="string">'0'</span>; <span class="comment">//  a一直在减 ， 额外还要减个'0'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxx.length()<span class="number">-1</span>; i &gt; <span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxx[i] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">            maxx[i] -= <span class="number">10</span>;<span class="comment">//注意这个是减10</span></span><br><span class="line">            maxx[i - <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxx[<span class="number">0</span>] &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        maxx[<span class="number">0</span>] -= <span class="number">10</span>;</span><br><span class="line">        maxx = <span class="string">'1'</span> + maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">大数阶乘</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |大数模拟阶乘|</span></span><br><span class="line"><span class="comment">    |用数组模拟|</span></span><br><span class="line"><span class="comment">    |16/12/02ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[maxn], len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在mult函数中，形参部分：len每次调用函数都会发生改变，n表示每次要乘以的数，最终返回的是结果的长度</span></span><br><span class="line"><span class="comment">    tip: 阶乘都是先求之前的(n-1)!来求n!</span></span><br><span class="line"><span class="comment">    初始化Init函数很重要，不要落下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> num[], <span class="keyword">int</span> len, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LL tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">         tmp = tmp + num[i] * n;    <span class="comment">//从最低位开始，等号左边的tmp表示当前位，右边的tmp表示进位（之前进的位）</span></span><br><span class="line">         num[i] = tmp % <span class="number">10</span>; <span class="comment">//  保存在对应的数组位置，即去掉进位后的一位数</span></span><br><span class="line">         tmp = tmp / <span class="number">10</span>;    <span class="comment">//  取整用于再次循环,与n和下一个位置的乘积相加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp) &#123;    <span class="comment">//  之后的进位处理</span></span><br><span class="line">         num[len++] = tmp % <span class="number">10</span>;</span><br><span class="line">         tmp = tmp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = <span class="number">1977</span>; <span class="comment">// 求的阶乘数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        len = mult(num, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,num[i]);    <span class="comment">//  从最高位依次输出,数据比较多采用printf输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |辗转相除法|</span></span><br><span class="line"><span class="comment">    |欧几里得算法|</span></span><br><span class="line"><span class="comment">    |求最大公约数|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gcd(<span class="keyword">int</span> big, <span class="keyword">int</span> <span class="keyword">small</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">small</span> &gt; big) swap(big, <span class="keyword">small</span>);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">small</span> != <span class="number">0</span>)&#123; <span class="comment">//  辗转相除法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">small</span> &gt; big) swap(big, <span class="keyword">small</span>);</span><br><span class="line">        temp = big % <span class="keyword">small</span>;</span><br><span class="line">        big = <span class="keyword">small</span>;</span><br><span class="line">        <span class="keyword">small</span> = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCM"><a href="#LCM" class="headerlink" title="LCM"></a>LCM</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |辗转相除法|</span></span><br><span class="line"><span class="comment">    |欧几里得算法|</span></span><br><span class="line"><span class="comment">    |求最小公倍数|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gcd(<span class="keyword">int</span> big, <span class="keyword">int</span> <span class="keyword">small</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">small</span> &gt; big) swap(big, <span class="keyword">small</span>);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">small</span> != <span class="number">0</span>)&#123; <span class="comment">//  辗转相除法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">small</span> &gt; big) swap(big, <span class="keyword">small</span>);</span><br><span class="line">        temp = big % <span class="keyword">small</span>;</span><br><span class="line">        big = <span class="keyword">small</span>;</span><br><span class="line">        <span class="keyword">small</span> = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(big);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求1到n的全排列, 有条件|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx, thanks to wangqiqi|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pern</span><span class="params">(<span class="keyword">int</span> <span class="built_in">list</span>[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;   <span class="comment">//  k表示前k个数不动仅移动后面n-k位数</span></span><br><span class="line">    <span class="keyword">if</span> (k == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; i++) &#123;   <span class="comment">//  输出的是满足移动条件所有全排列</span></span><br><span class="line">            swap(<span class="built_in">list</span>[k], <span class="built_in">list</span>[i]);</span><br><span class="line">            Pern(<span class="built_in">list</span>, k + <span class="number">1</span>, n);</span><br><span class="line">            swap(<span class="built_in">list</span>[k], <span class="built_in">list</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |二分搜索|</span></span><br><span class="line"><span class="comment">    |要求：先排序|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx, thanks to wangxiaocai|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  left为最开始元素, right是末尾元素的下一个数，x是要找的数</span></span><br><span class="line">int bsearch(int *<span class="type">A</span>, int <span class="keyword">left</span>, int <span class="keyword">right</span>, int x)&#123;</span><br><span class="line">    int m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>)&#123;</span><br><span class="line">        m = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">A</span>[m] &gt;= x)  <span class="keyword">right</span> = m;   <span class="keyword">else</span> <span class="keyword">left</span> = m + <span class="number">1</span>;    </span><br><span class="line">        <span class="comment">// 如果要替换为 upper_bound, 改为:if (A[m] &lt;= v) x = m+1; else y = m;     </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后left == right  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果没有找到135577找6，返回7  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果找有多少的x，可以用lower_bound查找一遍，upper_bound查找一遍，下标相减  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    C++自带的lower_bound(a,a+n,x)返回数组中最后一个x的下一个数的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    upper_bound(a,a+n,x)返回数组中第一个x的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果a+n内没有找到x或x的下一个地址，返回a+n的地址  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    lower_bound(a,a+n,x）-upper_bound(a,a+n,x)返回数组中x的个数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |合并节点操作|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx, thanks to chaixiaojun|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> father<span class="literal">[<span class="identifier">maxn</span>]</span>;   <span class="comment">//  储存i的father父节点  </span></span><br><span class="line"></span><br><span class="line">void make<span class="constructor">Set()</span> &#123;  </span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; maxn; i++)   </span><br><span class="line">        father<span class="literal">[<span class="identifier">i</span>]</span> = i;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> find<span class="constructor">Root(<span class="params">int</span> <span class="params">x</span>)</span> &#123;   <span class="comment">//  迭代找根节点</span></span><br><span class="line">    <span class="built_in">int</span> root = x; <span class="comment">// 根节点  </span></span><br><span class="line">    <span class="keyword">while</span> (root != father<span class="literal">[<span class="identifier">root</span>]</span>) &#123; <span class="comment">// 寻找根节点  </span></span><br><span class="line">        root = father<span class="literal">[<span class="identifier">root</span>]</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;  </span><br><span class="line">        <span class="built_in">int</span> tmp = father<span class="literal">[<span class="identifier">x</span>]</span>;  </span><br><span class="line">        father<span class="literal">[<span class="identifier">x</span>]</span> = root; <span class="comment">// 根节点赋值  </span></span><br><span class="line">        x = tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return root;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void <span class="constructor">Union(<span class="params">int</span> <span class="params">x</span>, <span class="params">int</span> <span class="params">y</span>)</span> &#123;  <span class="comment">//  将x所在的集合和y所在的集合整合起来形成一个集合。  </span></span><br><span class="line">    <span class="built_in">int</span> a, b;  </span><br><span class="line">    a = find<span class="constructor">Root(<span class="params">x</span>)</span>;  </span><br><span class="line">    b = find<span class="constructor">Root(<span class="params">y</span>)</span>;  </span><br><span class="line">    father<span class="literal">[<span class="identifier">a</span>]</span> = b;  <span class="comment">// y连在x的根节点上   或father[b] = a为x连在y的根节点上；  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在findRoot(x)中：</span></span><br><span class="line"><span class="comment">    路径压缩 迭代 最优版</span></span><br><span class="line"><span class="comment">    关键在于在路径上的每个节点都可以直接连接到根上</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>MST</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>Kruskal</p><h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Kruskal算法|</span></span><br><span class="line"><span class="comment">    |适用于 稀疏图 求最小生成树|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx thanks to wangqiqi|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一步：点、边、加入vector，把所有边按从小到大排序</span></span><br><span class="line"><span class="comment">    第二步：并查集部分 + 下面的code</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Kruskal() &#123;    </span><br><span class="line">    ans = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (Find(<span class="keyword">edge</span>[i]<span class="variable">.a</span>) != Find(<span class="keyword">edge</span>[i]<span class="variable">.b</span>)) &#123;    </span><br><span class="line">            Union(<span class="keyword">edge</span>[i]<span class="variable">.a</span>, <span class="keyword">edge</span>[i]<span class="variable">.b</span>);    </span><br><span class="line">            ans += <span class="keyword">edge</span>[i]<span class="variable">.len</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>普里姆算法<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Prim算法|</span></span><br><span class="line"><span class="comment">    |适用于 稠密图 求最小生成树|</span></span><br><span class="line"><span class="comment">    |堆优化版，时间复杂度：O(elgn)|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx, thanks to chaixiaojun|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node &#123;  </span><br><span class="line">    <span class="keyword">int</span> v, <span class="built_in">len</span>;  </span><br><span class="line">    node(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> <span class="built_in">len</span> = <span class="number">0</span>) :v(v), <span class="built_in">len</span>(<span class="built_in">len</span>) &#123;&#125;  </span><br><span class="line">    <span class="keyword">bool</span> operator &lt; (<span class="keyword">const</span> node &amp;a)<span class="keyword">const</span> &#123;  <span class="comment">// 加入队列的元素自动按距离从小到大排序  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>&gt; a.<span class="built_in">len</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"></span><br><span class="line">void init() &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;maxn; i++) &#123;  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">        vis[i] = <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">int</span> Prim(<span class="keyword">int</span> s) &#123;  </span><br><span class="line">    priority_queue&lt;node&gt;Q; <span class="comment">// 定义优先队列  </span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    Q.push(node(s,<span class="number">0</span>));  <span class="comment">// 起点加入队列  </span></span><br><span class="line">    while (!Q.empty()) &#123;   </span><br><span class="line">        node now = Q.top(); Q.pop();  <span class="comment">// 取出距离最小的点  </span></span><br><span class="line">        <span class="keyword">int</span> v = now.v;  </span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;  <span class="comment">// 同一个节点，可能会推入2次或2次以上队列，这样第一个被标记后，剩下的需要直接跳过。  </span></span><br><span class="line">        vis[v] = <span class="literal">true</span>;  <span class="comment">// 标记一下  </span></span><br><span class="line">        ans += now.<span class="built_in">len</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G[v].size(); i++) &#123;  <span class="comment">// 开始更新  </span></span><br><span class="line">            <span class="keyword">int</span> v2 = G[v][i].v;  </span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">len</span> = G[v][i].<span class="built_in">len</span>;  </span><br><span class="line">            <span class="keyword">if</span> (!vis[v2] &amp;&amp; dis[v2] &gt; <span class="built_in">len</span>) &#123;   </span><br><span class="line">                dis[v2] = <span class="built_in">len</span>;  </span><br><span class="line">                Q.push(node(v2, dis[v2]));  <span class="comment">// 更新的点加入队列并排序  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>迪杰斯特拉算法<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Dijkstra算法|</span></span><br><span class="line"><span class="comment">    |适用于边权为正的有向图或者无向图|</span></span><br><span class="line"><span class="comment">    |求从单个源点出发，到所有节点的最短路|</span></span><br><span class="line"><span class="comment">    |优化版：时间复杂度 O(elbn)|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx, thanks to chaixiaojun|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node &#123;  </span><br><span class="line">    <span class="keyword">int</span> v, <span class="built_in">len</span>;  </span><br><span class="line">    node(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> <span class="built_in">len</span> = <span class="number">0</span>) :v(v), <span class="built_in">len</span>(<span class="built_in">len</span>) &#123;&#125;  </span><br><span class="line">    <span class="keyword">bool</span> operator &lt; (<span class="keyword">const</span> node &amp;a)<span class="keyword">const</span> &#123;  <span class="comment">//  距离从小到大排序  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span> &gt; a.<span class="built_in">len</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">vector&lt;node&gt;G[maxn];  </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];  </span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"></span><br><span class="line">void init() &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;maxn; i++) &#123;  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">        vis[i] = <span class="literal">false</span>;  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">int</span> dijkstra(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;  </span><br><span class="line">    priority_queue&lt;node&gt;Q;  </span><br><span class="line">    Q.push(node(s, <span class="number">0</span>)); <span class="comment">//  加入队列并排序  </span></span><br><span class="line">    dis[s] = <span class="number">0</span>;  </span><br><span class="line">    while (!Q.empty()) &#123;  </span><br><span class="line">        node now = Q.top();     <span class="comment">//  取出当前最小的  </span></span><br><span class="line">        Q.pop();  </span><br><span class="line">        <span class="keyword">int</span> v = now.v;  </span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;   <span class="comment">//  如果标记过了, 直接continue  </span></span><br><span class="line">        vis[v] = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G[v].size(); i++) &#123;   <span class="comment">//  更新  </span></span><br><span class="line">            <span class="keyword">int</span> v2 = G[v][i].v;  </span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">len</span> = G[v][i].<span class="built_in">len</span>;  </span><br><span class="line">            <span class="keyword">if</span> (!vis[v2] &amp;&amp; dis[v2] &gt; dis[v] + <span class="built_in">len</span>) &#123;  </span><br><span class="line">                dis[v2] = dis[v] + <span class="built_in">len</span>;  </span><br><span class="line">                Q.push(node(v2, dis[v2]));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> dis[e];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>最短路径快速算法（Shortest Path Faster Algorithm）<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |SPFA算法|</span></span><br><span class="line"><span class="comment">    |队列优化|</span></span><br><span class="line"><span class="comment">    |可处理负环|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> inqueue[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; maxn ; ++i)&#123;  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">        dist[i] = INF;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> v1,v2,weight;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;  </span><br><span class="line">    <span class="built_in">memset</span>(inqueue,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inqueue)); <span class="comment">// 标记是否在队列中  </span></span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt)); <span class="comment">// 加入队列的次数  </span></span><br><span class="line">    dist[s] = <span class="number">0</span>;  </span><br><span class="line">    Q.push(s); <span class="comment">// 起点加入队列  </span></span><br><span class="line">    inqueue[s] = <span class="literal">true</span>; <span class="comment">// 标记  </span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())&#123;  </span><br><span class="line">        v1 = Q.front();  </span><br><span class="line">        Q.pop();  </span><br><span class="line">        inqueue[v1] = <span class="literal">false</span>; <span class="comment">// 取消标记  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G[v1].size() ; ++i)&#123; <span class="comment">// 搜索v1的链表  </span></span><br><span class="line">            v2 = G[v1][i].vex;  </span><br><span class="line">            weight = G[v1][i].weight;  </span><br><span class="line">            <span class="keyword">if</span>(dist[v2] &gt; dist[v1] + weight)&#123; <span class="comment">// 松弛操作  </span></span><br><span class="line">                dist[v2] = dist[v1] + weight;  </span><br><span class="line">                <span class="keyword">if</span>(inqueue[v2] == <span class="literal">false</span>)&#123;  <span class="comment">// 再次加入队列  </span></span><br><span class="line">                    inqueue[v2] = <span class="literal">true</span>;  </span><br><span class="line">                    <span class="comment">//cnt[v2]++;  // 判负环  </span></span><br><span class="line">                    <span class="comment">//if(cnt[v2] &gt; n) return -1;  </span></span><br><span class="line">                    Q.push(v2);  </span><br><span class="line">                &#125; &#125; &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> dist[e];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    不断的将s的邻接点加入队列，取出不断的进行松弛操作，直到队列为空  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果一个结点被加入队列超过n-1次，那么显然图中有负环  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h4><p>弗洛伊德算法<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |Floyd算法|</span></span><br><span class="line"><span class="comment">    |任意点对最短路算法|</span></span><br><span class="line"><span class="comment">    |求图中任意两点的最短距离的算法|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;   <span class="comment">//  初始化为0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++)  </span><br><span class="line">        scanf(<span class="string">"%lf"</span>, &amp;dis[i][j]);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><h4 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |交叉染色法判断二分图|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bipartite(<span class="keyword">int</span> s) &#123;  </span><br><span class="line">    <span class="keyword">int</span> u, v;  </span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt;Q;  </span><br><span class="line">    <span class="keyword">color</span>[s] = <span class="number">1</span>;  </span><br><span class="line">    Q.push(s);  </span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;  </span><br><span class="line">        u = Q.front();  </span><br><span class="line">        Q.pop();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="keyword">size</span>(); i++) &#123;  </span><br><span class="line">            v = G[u][i];  </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">color</span>[v] == <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">color</span>[v] = -<span class="keyword">color</span>[u];  </span><br><span class="line">                Q.push(v);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">color</span>[v] == <span class="keyword">color</span>[u])  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求解最大匹配问题|</span></span><br><span class="line"><span class="comment">    |递归实现|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[maxn];  </span><br><span class="line"><span class="keyword">bool</span> inpath[maxn];  <span class="comment">//  标记  </span></span><br><span class="line"><span class="keyword">int</span> match[maxn];    <span class="comment">//  记录匹配对象  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(match, <span class="number">-1</span>, <span class="keyword">sizeof</span>(match));  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;  </span><br><span class="line">        G[i].clear();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findpath</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[k].size(); ++i) &#123;  </span><br><span class="line">        <span class="keyword">int</span> v = G[k][i];  </span><br><span class="line">        <span class="keyword">if</span> (!inpath[v]) &#123;  </span><br><span class="line">            inpath[v] = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (match[v] == <span class="number">-1</span> || findpath(match[v])) &#123; <span class="comment">// 递归  </span></span><br><span class="line">                match[v] = k; <span class="comment">// 即匹配对象是“k妹子”的  </span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// m为需要匹配的“妹子”数  </span></span><br><span class="line">        <span class="built_in">memset</span>(inpath, <span class="literal">false</span>, <span class="keyword">sizeof</span>(inpath)); <span class="comment">// 每次都要初始化  </span></span><br><span class="line">        <span class="keyword">if</span> (findpath(i)) cnt++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求解最大匹配问题|</span></span><br><span class="line"><span class="comment">    |dfs实现|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v1, v2;  </span><br><span class="line"><span class="keyword">bool</span> Map[<span class="number">501</span>][<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">int</span> link[<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">int</span> result;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= v2; ++y)  &#123;  </span><br><span class="line">        <span class="keyword">if</span> (Map[x][y] &amp;&amp; !visit[y])  &#123;  </span><br><span class="line">            visit[y] = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (link[y] == <span class="number">0</span> || dfs(link[y]))  &#123;  </span><br><span class="line">                link[y] = x;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125; &#125; &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= v1; x++)  &#123;  </span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));  </span><br><span class="line">        <span class="keyword">if</span> (dfs(x))  </span><br><span class="line">            result++;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |01背包|</span></span><br><span class="line"><span class="comment">    |完全背包|</span></span><br><span class="line"><span class="comment">    |多重背包|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">//  <span class="number">01</span>背包：  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> bag01(<span class="type">int</span> <span class="keyword">cost</span>,<span class="type">int</span> weight)  &#123;  </span><br><span class="line">    <span class="keyword">for</span>(i = v; i &gt;= <span class="keyword">cost</span>; <span class="comment">--i)  </span></span><br><span class="line">    dp[i] = max(dp[i], dp[i-<span class="keyword">cost</span>]+weight);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//  完全背包：  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> complete(<span class="type">int</span> <span class="keyword">cost</span>, <span class="type">int</span> weight)  &#123;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="keyword">cost</span> ; i &lt;= v; ++i)  </span><br><span class="line">    dp[i] = max(dp[i], dp[i - <span class="keyword">cost</span>] + weight);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//  多重背包：  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> multiply(<span class="type">int</span> <span class="keyword">cost</span>, <span class="type">int</span> weight, <span class="type">int</span> amount)  &#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">cost</span> * amount &gt;= v)  </span><br><span class="line">        complete(<span class="keyword">cost</span>, weight);  </span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        k = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (k &lt; amount)&#123;  </span><br><span class="line">            bag01(k * <span class="keyword">cost</span>, k * weight);  </span><br><span class="line">            amount -= k;  </span><br><span class="line">            k += k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        bag01(<span class="keyword">cost</span> * amount, weight * amount);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> dp[<span class="number">1000000</span>];</span><br><span class="line"><span class="built_in">int</span> c[<span class="number">55</span>], m[<span class="number">110</span>];</span><br><span class="line"><span class="built_in">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> CompletePack(<span class="built_in">int</span> c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> v = c; v &lt;= sum / <span class="number">2</span>; ++v)&#123;</span><br><span class="line">        dp[v] = max(dp[v], dp[v - c] + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> ZeroOnePack(<span class="built_in">int</span> c) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> v = sum / <span class="number">2</span>; v &gt;= c; --v) &#123;</span><br><span class="line">        dp[v] = max(dp[v], dp[v - c] + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> multiplePack(<span class="built_in">int</span> c, <span class="built_in">int</span> m） &#123;</span><br><span class="line">    <span class="keyword">if</span> (m * c &gt; sum / <span class="number">2</span>)</span><br><span class="line">        CompletePack(c);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; m)&#123;</span><br><span class="line">            ZeroOnePack(k * c);</span><br><span class="line">            m -= k;</span><br><span class="line">            k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="number">0</span>)&#123;</span><br><span class="line">            ZeroOnePack(m * c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h3><p>最长上升子序列<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |最长上升子序列|</span></span><br><span class="line"><span class="comment">    |状态转移|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    状态转移dp[i] = max&#123; 1.dp[j] + 1 &#125;;  j&lt;i; a[j]&lt;a[i];</span></span><br><span class="line"><span class="comment">    d[i]是以i结尾的最长上升子序列</span></span><br><span class="line"><span class="comment">    与i之前的 每个a[j]&lt;a[i]的 j的位置的最长上升子序列+1后的值比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> solve()&#123;   <span class="comment">// 参考挑战程序设计入门经典;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;  </span><br><span class="line">        dp[i] = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i])&#123;  </span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);  </span><br><span class="line">            &#125; &#125; &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    优化方法：</span></span><br><span class="line"><span class="comment">    dp[i]表示长度为i+1的上升子序列的最末尾元素  </span></span><br><span class="line"><span class="comment">    找到第一个比dp末尾大的来代替</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> solve() &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">            *lower_bound(dp, dp + n, a[i]) = a[i];  <span class="comment">//  返回一个指针  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        printf(<span class="string">"%d\n"</span>, *lower_bound(dp, dp + n, INF) - dp;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    函数lower_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><p>最长公共子序列<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求最长公共子序列|</span></span><br><span class="line"><span class="comment">    |递推形式|</span></span><br><span class="line"><span class="comment">    |16/11/05ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> solve() &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;  </span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);  </span><br><span class="line">            &#125; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><h3 id="向量基本用法"><a href="#向量基本用法" class="headerlink" title="向量基本用法"></a>向量基本用法</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node &#123;  </span><br><span class="line">    double x; <span class="comment">// 横坐标  </span></span><br><span class="line">    double y; <span class="comment">// 纵坐标  </span></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">typedef node Vector;</span><br><span class="line"></span><br><span class="line">Vector operator + (Vector A, Vector B) &#123; return <span class="constructor">Vector(A.<span class="params">x</span> + B.<span class="params">x</span>, A.<span class="params">y</span> + B.<span class="params">y</span>)</span>; &#125;  </span><br><span class="line">Vector operator - (Point A, Point B) &#123; return <span class="constructor">Vector(A.<span class="params">x</span> - B.<span class="params">y</span>, A.<span class="params">y</span> - B.<span class="params">y</span>)</span>; &#125;  </span><br><span class="line">Vector operator<span class="operator"> * </span>(Vector A, double p) &#123; return <span class="constructor">Vector(A.<span class="params">x</span><span class="operator">*</span><span class="params">p</span>, A.<span class="params">y</span><span class="operator">*</span><span class="params">p</span>)</span>; &#125;  </span><br><span class="line">Vector operator<span class="operator"> / </span>(Vector A, double p) &#123; return <span class="constructor">Vector(A.<span class="params">x</span> <span class="operator">/</span> <span class="params">p</span>, A.<span class="params">y</span><span class="operator">*</span><span class="params">p</span>)</span>; &#125;  </span><br><span class="line"></span><br><span class="line">double <span class="constructor">Dot(Vector A, Vector B)</span> &#123; return <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x*<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x + <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y*<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y; &#125; <span class="comment">// 向量点乘  </span></span><br><span class="line">double <span class="constructor">Length(Vector A)</span> &#123; return sqrt(<span class="constructor">Dot(A, A)</span>); &#125;  <span class="comment">// 向量模长  </span></span><br><span class="line">double <span class="constructor">Angle(Vector A, Vector B)</span> &#123; return acos(<span class="constructor">Dot(A, B)</span><span class="operator"> / </span><span class="constructor">Length(A)</span><span class="operator"> / </span><span class="constructor">Length(B)</span>); &#125;  <span class="comment">// 向量之间夹角  </span></span><br><span class="line"></span><br><span class="line">double <span class="constructor">Cross(Vector A, Vector B)</span> &#123; <span class="comment">// 叉积计算 公式  </span></span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x*<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y - <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y*<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Vector <span class="constructor">Rotate(Vector A, <span class="params">double</span> <span class="params">rad</span>)</span> <span class="comment">// 向量旋转 公式  &#123;  </span></span><br><span class="line">    return <span class="constructor">Vector(A.<span class="params">x</span><span class="operator">*</span><span class="params">cos</span>(<span class="params">rad</span>)</span> - <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y*sin(rad), <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x*sin(rad) + <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y*cos(rad));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Point get<span class="constructor">LineIntersection(Point P, Vector <span class="params">v</span>, Point Q, Vector <span class="params">w</span>)</span> &#123; <span class="comment">// 两直线交点t1 t2计算公式   </span></span><br><span class="line">    Vector u = P - Q;   </span><br><span class="line">    double t = <span class="constructor">Cross(<span class="params">w</span>, <span class="params">u</span>)</span><span class="operator"> / </span><span class="constructor">Cross(<span class="params">v</span>, <span class="params">w</span>)</span>;  <span class="comment">// 求得是横坐标  </span></span><br><span class="line">    return P + v*t;  <span class="comment">// 返回一个点  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求多边形面积"><a href="#求多边形面积" class="headerlink" title="求多边形面积"></a>求多边形面积</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">node G[maxn];  </span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(node a, node b)</span> </span>&#123; <span class="comment">// 叉积计算  </span></span><br><span class="line">    <span class="keyword">return</span> a.x*b.y - a.y*b.x;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF &amp;&amp; n) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;G[i].x, &amp;G[i].y);  </span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;  </span><br><span class="line">        G[n].x = G[<span class="number">0</span>].x;  </span><br><span class="line">        G[n].y = G[<span class="number">0</span>].y;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;   </span><br><span class="line">                sum += Cross(G[i], G[i + <span class="number">1</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 或者  </span></span><br><span class="line">            <span class="comment">//for (int i = 0; i &lt; n; i++) &#123;  </span></span><br><span class="line">                <span class="comment">//sum += fun(G[i], G[（i + 1）% n]);  </span></span><br><span class="line">            <span class="comment">//&#125;  </span></span><br><span class="line">        sum = sum / <span class="number">2.0</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, sum);  </span><br><span class="line">    &#125;  </span><br><span class="line">    system(<span class="string">"pause"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断线段相交"><a href="#判断线段相交" class="headerlink" title="判断线段相交"></a>判断线段相交</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">node P<span class="literal">[<span class="number">35</span>]</span><span class="literal">[<span class="number">105</span>]</span>;     </span><br><span class="line"></span><br><span class="line">double <span class="constructor">Cross_Prouct(<span class="params">node</span> A,<span class="params">node</span> B,<span class="params">node</span> C)</span> &#123;     <span class="comment">//  计算BA叉乘CA     </span></span><br><span class="line">    return (<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x-<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x)*(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y-<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y)-(<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y-<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y)*(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x-<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x);      </span><br><span class="line">&#125;      </span><br><span class="line"><span class="built_in">bool</span> <span class="constructor">Intersect(<span class="params">node</span> A,<span class="params">node</span> B,<span class="params">node</span> C,<span class="params">node</span> D)</span>  &#123;  <span class="comment">//  通过叉乘判断线段是否相交；           </span></span><br><span class="line">    <span class="keyword">if</span>(min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)&lt;=max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&amp;&amp;         <span class="comment">//  快速排斥实验；      </span></span><br><span class="line">       min(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>x)&lt;=max(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>x,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>x)&amp;&amp;      </span><br><span class="line">       min(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y)&lt;=max(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&amp;&amp;      </span><br><span class="line">       min(<span class="module-access"><span class="module"><span class="identifier">C</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">D</span>.</span></span>y)&lt;=max(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>y,<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>y)&amp;&amp;      </span><br><span class="line">       <span class="constructor">Cross_Prouct(A,B,C)</span>*<span class="constructor">Cross_Prouct(A,B,D)</span>&lt;<span class="number">0</span>&amp;&amp;      <span class="comment">//  跨立实验；      </span></span><br><span class="line">       <span class="constructor">Cross_Prouct(C,D,A)</span>*<span class="constructor">Cross_Prouct(C,D,B)</span>&lt;<span class="number">0</span>)       <span class="comment">//  叉乘异号表示在两侧；      </span></span><br><span class="line">       return <span class="literal">true</span>;      </span><br><span class="line">    <span class="keyword">else</span> return <span class="literal">false</span>;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求三角形外心"><a href="#求三角形外心" class="headerlink" title="求三角形外心"></a>求三角形外心</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Point</span> circumcenter(const Point &amp;a, const Point &amp;<span class="keyword">b, </span>const Point &amp;c) &#123; //返回三角形的外心        </span><br><span class="line">    Point ret<span class="comment">;  </span></span><br><span class="line">    double <span class="built_in">a1</span> = <span class="keyword">b.x </span>- a.x, <span class="keyword">b1 </span>= <span class="keyword">b.y </span>- a.y, <span class="built_in">c1</span> = (<span class="built_in">a1</span>*<span class="built_in">a1</span> + <span class="keyword">b1*b1) </span>/ <span class="number">2</span><span class="comment">;  </span></span><br><span class="line">    double <span class="built_in">a2</span> = c.x - a.x, <span class="keyword">b2 </span>= c.y - a.y, <span class="built_in">c2</span> = (<span class="built_in">a2</span>*<span class="built_in">a2</span> + <span class="keyword">b2*b2) </span>/ <span class="number">2</span><span class="comment">;  </span></span><br><span class="line">    double d = <span class="built_in">a1</span>*<span class="keyword">b2 </span>- <span class="built_in">a2</span>*<span class="keyword">b1; </span> </span><br><span class="line">    ret.x = a.x + (<span class="built_in">c1</span>*<span class="keyword">b2 </span>- <span class="built_in">c2</span>*<span class="keyword">b1) </span>/ d<span class="comment">;  </span></span><br><span class="line">    ret.y = a.y + (<span class="built_in">a1</span>*<span class="built_in">c2</span> - <span class="built_in">a2</span>*<span class="built_in">c1</span>) / d<span class="comment">;  </span></span><br><span class="line">    return ret<span class="comment">;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a>极角排序</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">double</span> cross(point <span class="built_in">p1</span>, point <span class="built_in">p2</span>, point <span class="built_in">q1</span>, point <span class="built_in">q2</span>) &#123;  // 叉积计算   </span><br><span class="line">    return (<span class="built_in">q2</span>.y - <span class="built_in">q1</span>.y)*(<span class="built_in">p2</span>.x - <span class="built_in">p1</span>.x) - (<span class="built_in">q2</span>.x - <span class="built_in">q1</span>.x)*(<span class="built_in">p2</span>.y - <span class="built_in">p1</span>.y)<span class="comment">;  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">bool </span><span class="keyword">cmp(point </span>a, point <span class="keyword">b) </span> &#123;  </span><br><span class="line">    point o<span class="comment">;  </span></span><br><span class="line">    o.x = o.y = <span class="number">0</span><span class="comment">;  </span></span><br><span class="line">    return cross(o, <span class="keyword">b, </span>o, a) &lt; <span class="number">0</span><span class="comment">; // 叉积判断  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="symbol">sort</span>(convex + <span class="number">1</span>, convex + cnt, <span class="keyword">cmp); </span>// 按角排序, 从小到大</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><p>克努特-莫里斯-普拉特操作<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |kmp算法|</span></span><br><span class="line"><span class="comment">    |字符串匹配|</span></span><br><span class="line"><span class="comment">    |17/1/21ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> getnext(char str[maxn], <span class="built_in">int</span> nextt[maxn]) &#123;</span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>, k = <span class="number">-1</span>;</span><br><span class="line">    nextt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || str[j] == str[k]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">            nextt[j] = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k = nextt[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> kmp(<span class="built_in">int</span> a[maxn], <span class="built_in">int</span> b[maxn]) &#123;    </span><br><span class="line">    <span class="built_in">int</span> nextt[maxm];    </span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;    </span><br><span class="line">    getnext(b, nextt);    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || a[i] == b[j]) &#123; <span class="comment">// 母串不动，子串移动    </span></span><br><span class="line">            j++;    </span><br><span class="line">            i++;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">// i不需要回溯了    </span></span><br><span class="line">            <span class="comment">// i = i - j + 1;    </span></span><br><span class="line">            j = nextt[j];    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;    </span><br><span class="line">            printf(<span class="string">"%d\n"</span>, i - m + <span class="number">1</span>); <span class="comment">// 母串的位置减去子串的长度+1    </span></span><br><span class="line">            <span class="keyword">return</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    printf(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="kmp扩展"><a href="#kmp扩展" class="headerlink" title="kmp扩展"></a>kmp扩展</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;    </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MM=<span class="number">100005</span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next[MM],extand[MM];    </span><br><span class="line"><span class="keyword">char</span> S[MM],T[MM];    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *T)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(T),a = <span class="number">0</span>;    </span><br><span class="line">    next[<span class="number">0</span>] = len;    </span><br><span class="line">    <span class="keyword">while</span>(a &lt; len - <span class="number">1</span> &amp;&amp; T[a] == T[a + <span class="number">1</span>]) a++;    </span><br><span class="line">    next[<span class="number">1</span>] = a;    </span><br><span class="line">    a = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; len; k ++) &#123;    </span><br><span class="line">        <span class="keyword">int</span> p = a + next[a] - <span class="number">1</span>,L = next[k - a];    </span><br><span class="line">        <span class="keyword">if</span>( (k - <span class="number">1</span>) + L &gt;= p) &#123;    </span><br><span class="line">            <span class="keyword">int</span> j = (p - k + <span class="number">1</span>) &gt; <span class="number">0</span> ? (p - k + <span class="number">1</span>) : <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">while</span>(k + j &lt; len &amp;&amp; T[k + j] == T[j]) j++;    </span><br><span class="line">            next[k] = j;    </span><br><span class="line">            a = k;    </span><br><span class="line">        &#125;<span class="keyword">else</span> next[k] = L;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExtand</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *S,<span class="keyword">const</span> <span class="keyword">char</span> *T)</span> </span>&#123;    </span><br><span class="line">    GetNext(T);    </span><br><span class="line">    <span class="keyword">int</span> slen = <span class="built_in">strlen</span>(S),tlen = <span class="built_in">strlen</span>(T),a = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> MinLen = slen &lt; tlen ? slen : tlen;    </span><br><span class="line">    <span class="keyword">while</span>(a &lt; MinLen &amp;&amp; S[a] == T[a]) a++;    </span><br><span class="line">    extand[<span class="number">0</span>] = a;     </span><br><span class="line">    a = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; slen; k ++) &#123;    </span><br><span class="line">        <span class="keyword">int</span> p = a + extand[a] - <span class="number">1</span>, L = next[k - a];    </span><br><span class="line">        <span class="keyword">if</span>( (k - <span class="number">1</span>) + L &gt;= p) &#123;    </span><br><span class="line">            <span class="keyword">int</span> j = (p - k + <span class="number">1</span>) &gt; <span class="number">0</span> ? (p - k + <span class="number">1</span>) : <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">while</span>(k + j &lt; slen &amp;&amp; j &lt; tlen &amp;&amp; S[k + j] == T[j]) j ++;    </span><br><span class="line">            extand[k] = j;    </span><br><span class="line">            a = k;    </span><br><span class="line">        &#125; <span class="keyword">else</span>    </span><br><span class="line">            extand[k] = L;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *s,<span class="keyword">int</span> len)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)    </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; s[i] &lt;&lt; <span class="string">' '</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T) &#123;    </span><br><span class="line">        GetExtand(S,T);    </span><br><span class="line">        show(next,<span class="built_in">strlen</span>(T));    </span><br><span class="line">        show(extand,<span class="built_in">strlen</span>(S));    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> cnt;  </span><br><span class="line">    Trie *next[maxn];  </span><br><span class="line">    Trie()&#123;  </span><br><span class="line">        cnt = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Trie *root;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> *word)</span>  </span>&#123;  </span><br><span class="line">    Trie *tem = root;  </span><br><span class="line">    <span class="keyword">while</span>(*word != <span class="string">'\0'</span>)  &#123;  </span><br><span class="line">        <span class="keyword">int</span> x = *word - <span class="string">'a'</span>;  </span><br><span class="line">        <span class="keyword">if</span>(tem-&gt;next[x] == <span class="literal">NULL</span>)  </span><br><span class="line">            tem-&gt;next[x] = <span class="keyword">new</span> Trie;  </span><br><span class="line">        tem = tem-&gt;next[x];  </span><br><span class="line">        tem-&gt;cnt++;  </span><br><span class="line">        word++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">char</span> *word)</span>  </span>&#123;  </span><br><span class="line">    Trie *tem = root;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;word[i]!=<span class="string">'\0'</span>;i++)  &#123;  </span><br><span class="line">        <span class="keyword">int</span> x = word[i]-<span class="string">'a'</span>;  </span><br><span class="line">        <span class="keyword">if</span>(tem-&gt;next[x] == <span class="literal">NULL</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        tem = tem-&gt;next[x];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> tem-&gt;cnt;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">char</span> *word,<span class="keyword">int</span> t)</span> </span>&#123;  </span><br><span class="line">    Trie *tem = root;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;word[i]!=<span class="string">'\0'</span>;i++)  &#123;  </span><br><span class="line">        <span class="keyword">int</span> x = word[i]-<span class="string">'a'</span>;  </span><br><span class="line">        tem = tem-&gt;next[x];  </span><br><span class="line">        (tem-&gt;cnt)-=t;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)  </span><br><span class="line">        tem-&gt;next[i] = <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n;  </span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">50</span>];  </span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">50</span>];  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)  &#123;  </span><br><span class="line">        root = <span class="keyword">new</span> Trie;  </span><br><span class="line">        <span class="keyword">while</span>(n--)  &#123;  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,str1,str2);  </span><br><span class="line">            <span class="keyword">if</span>(str1[<span class="number">0</span>]==<span class="string">'i'</span>) &#123;</span><br><span class="line">                Insert(str2);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1[<span class="number">0</span>] == <span class="string">'s'</span>)  &#123;  </span><br><span class="line">                <span class="keyword">if</span>(Search(str2))  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);  </span><br><span class="line">                <span class="keyword">else</span>  </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);  </span><br><span class="line">            &#125;<span class="keyword">else</span>  &#123;  </span><br><span class="line">                <span class="keyword">int</span> t = Search(str2);  </span><br><span class="line">                <span class="keyword">if</span>(t)  </span><br><span class="line">                    Delete(str2,t);  </span><br><span class="line">            &#125; &#125; &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N], keyword[N];  </span><br><span class="line"><span class="keyword">int</span> head, tail;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>  </span><br><span class="line">    node *fail;  </span><br><span class="line">    node *next[<span class="number">26</span>];  </span><br><span class="line">    <span class="keyword">int</span> count;  </span><br><span class="line">    node() &#123; <span class="comment">//init  </span></span><br><span class="line">        fail = <span class="literal">NULL</span>;<span class="comment">// 默认为空  </span></span><br><span class="line">        count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)  </span><br><span class="line">            next[i] = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;*q[N];  </span><br><span class="line"></span><br><span class="line">node *root;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *str)</span>  </span>&#123; <span class="comment">// 建立Trie  </span></span><br><span class="line">    <span class="keyword">int</span> temp, len;  </span><br><span class="line">    node *p = root;  </span><br><span class="line">    len = <span class="built_in">strlen</span>(str);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)  &#123;  </span><br><span class="line">        temp = str[i] - <span class="string">'a'</span>;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next[temp] == <span class="literal">NULL</span>)  </span><br><span class="line">            p-&gt;next[temp] = <span class="keyword">new</span> node();  </span><br><span class="line">        p = p-&gt;next[temp];  </span><br><span class="line">    &#125;  </span><br><span class="line">    p-&gt;count++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_ac</span><span class="params">()</span> </span>&#123; <span class="comment">// 初始化fail指针，BFS 数组模拟队列：   </span></span><br><span class="line">    q[tail++] = root;  </span><br><span class="line">    <span class="keyword">while</span>(head != tail)  &#123;  </span><br><span class="line">        node *p = q[head++]; <span class="comment">// 弹出队头  </span></span><br><span class="line">        node *temp = <span class="literal">NULL</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)  &#123;  </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next[i] != <span class="literal">NULL</span>)  &#123;  </span><br><span class="line">                <span class="keyword">if</span>(p == root) &#123; <span class="comment">// 第一个元素fail必指向根  </span></span><br><span class="line">                    p-&gt;next[i]-&gt;fail = root;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                    temp = p-&gt;fail; <span class="comment">// 失败指针  </span></span><br><span class="line">                    <span class="keyword">while</span>(temp != <span class="literal">NULL</span>) &#123; <span class="comment">// 2种情况结束：匹配为空or找到匹配</span></span><br><span class="line">                        <span class="keyword">if</span>(temp-&gt;next[i] != <span class="literal">NULL</span>) &#123; <span class="comment">// 找到匹配  </span></span><br><span class="line">                            p-&gt;next[i]-&gt;fail = temp-&gt;next[i];  </span><br><span class="line">                            <span class="keyword">break</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        temp = temp-&gt;fail;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>) <span class="comment">// 为空则从头匹配  </span></span><br><span class="line">                        p-&gt;next[i]-&gt;fail = root;  </span><br><span class="line">                &#125;  </span><br><span class="line">                q[tail++] = p-&gt;next[i]; <span class="comment">// 入队  </span></span><br><span class="line">            &#125; &#125; &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">()</span> <span class="comment">// 扫描  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> index, len, result;  </span><br><span class="line">    node *p = root; <span class="comment">// Tire入口  </span></span><br><span class="line">    result = <span class="number">0</span>;  </span><br><span class="line">    len = <span class="built_in">strlen</span>(str);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        index = str[i] - <span class="string">'a'</span>;  </span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next[index] == <span class="literal">NULL</span> &amp;&amp; p != root) <span class="comment">// 跳转失败指针  </span></span><br><span class="line">            p = p-&gt;fail;  </span><br><span class="line">        p = p-&gt;next[index];  </span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)  </span><br><span class="line">            p = root;  </span><br><span class="line">        node *temp = p; <span class="comment">// p不动，temp计算后缀串  </span></span><br><span class="line">        <span class="keyword">while</span>(temp != root &amp;&amp; temp-&gt;count != <span class="number">-1</span>)   &#123;  </span><br><span class="line">            result += temp-&gt;count;  </span><br><span class="line">            temp-&gt;count = <span class="number">-1</span>;  </span><br><span class="line">            temp = temp-&gt;fail;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num;  </span><br><span class="line">    head= tail = <span class="number">0</span>;  </span><br><span class="line">    root = <span class="keyword">new</span> node();  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);  </span><br><span class="line">    getchar();  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;  </span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%s"</span>,keyword);  </span><br><span class="line">        insert(keyword);  </span><br><span class="line">    &#125;  </span><br><span class="line">    build_ac();  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);  </span><br><span class="line">    <span class="keyword">if</span>(query())  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设有N个模式串，平均长度为L；文章长度为M。 建立Trie树：O(N*L) 建立fail指针：O(N*L) 模式匹配：O(M*L) 所以，总时间复杂度为:O( (N+M)*L )。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>线段树<br>1）点更新<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/12/07ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> left, right;</span><br><span class="line">    <span class="built_in">int</span> max, sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="built_in">int</span> a[maxn];</span><br><span class="line"><span class="built_in">int</span> n;</span><br><span class="line"><span class="built_in">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> p, q;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> build(<span class="built_in">int</span> m, <span class="built_in">int</span> l, <span class="built_in">int</span> r)<span class="comment">//m 是 树的标号</span></span><br><span class="line">&#123;</span><br><span class="line">    tree[m].left = l;</span><br><span class="line">    tree[m].right = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">        tree[m].max = a[l];</span><br><span class="line">        tree[m].sum = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(m &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    build(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    tree[m].max = max(tree[m &lt;&lt; <span class="number">1</span>].max, tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">    tree[m].sum = tree[m &lt;&lt; <span class="number">1</span>].sum + tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> update(<span class="built_in">int</span> m, <span class="built_in">int</span> a, <span class="built_in">int</span> val)<span class="comment">//a 是 节点位置， val 是 更新的值（加减的值）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[m].left == a &amp;&amp; tree[m].right == a)&#123;</span><br><span class="line">        tree[m].max += val;</span><br><span class="line">        tree[m].sum += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= mid)&#123;</span><br><span class="line">        update(m &lt;&lt; <span class="number">1</span>, a, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, a, val);</span><br><span class="line">    &#125;</span><br><span class="line">    tree[m].max = max(tree[m &lt;&lt; <span class="number">1</span>].max, tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].max);</span><br><span class="line">    tree[m].sum = tree[m &lt;&lt; <span class="number">1</span>].sum + tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> querySum(<span class="built_in">int</span> m, <span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == tree[m].left &amp;&amp; r == tree[m].right)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[m].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(m &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> querySum(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> querySum(m &lt;&lt; <span class="number">1</span>, l, mid) + querySum(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> queryMax(<span class="built_in">int</span> m, <span class="built_in">int</span> l, <span class="built_in">int</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == tree[m].left &amp;&amp; r == tree[m].right)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[m].max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryMax(m &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryMax(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(queryMax(m &lt;&lt; <span class="number">1</span>, l, mid), queryMax(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>build(1,1,n);<br>update(1,a,b);<br>query(1,a,b);</p><h3 id="区间更新"><a href="#区间更新" class="headerlink" title="区间更新"></a>区间更新</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,q;  </span><br><span class="line">ll anssum;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> node&#123;  </span><br><span class="line">    ll l,r;  </span><br><span class="line">    ll addv,sum;  </span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">2</span>];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> maintain(<span class="keyword">int</span> <span class="keyword">id</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="keyword">id</span>].l &gt;= tree[<span class="keyword">id</span>].r)  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    tree[<span class="keyword">id</span>].sum = tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>].sum + tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> pushdown(<span class="keyword">int</span> <span class="keyword">id</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="keyword">id</span>].l &gt;= tree[<span class="keyword">id</span>].r)  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="keyword">id</span>].addv)&#123;  </span><br><span class="line">        <span class="keyword">int</span> tmp = tree[<span class="keyword">id</span>].addv;  </span><br><span class="line">        tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>].addv += tmp;  </span><br><span class="line">        tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].addv += tmp;  </span><br><span class="line">        tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>].sum += (tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>].r - tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>].l + <span class="number">1</span>)*tmp;  </span><br><span class="line">        tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum += (tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].r - tree[<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].l + <span class="number">1</span>)*tmp;  </span><br><span class="line">        tree[<span class="keyword">id</span>].addv = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> build(<span class="keyword">int</span> <span class="keyword">id</span>,ll l,ll r) &#123;  </span><br><span class="line">    tree[<span class="keyword">id</span>].l = l;  </span><br><span class="line">    tree[<span class="keyword">id</span>].r = r;  </span><br><span class="line">    tree[<span class="keyword">id</span>].addv = <span class="number">0</span>;  </span><br><span class="line">    tree[<span class="keyword">id</span>].sum = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(l==r)  &#123;  </span><br><span class="line">        tree[<span class="keyword">id</span>].sum = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ll mid = (l+r)&gt;&gt;<span class="number">1</span>;  </span><br><span class="line">    build(<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>,l,mid);  </span><br><span class="line">    build(<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);  </span><br><span class="line">    maintain(<span class="keyword">id</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updateAdd(<span class="keyword">int</span> <span class="keyword">id</span>,ll l,ll r,ll val) &#123;  </span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="keyword">id</span>].l &gt;= l &amp;&amp; tree[<span class="keyword">id</span>].r &lt;= r)  </span><br><span class="line">    &#123;  </span><br><span class="line">        tree[<span class="keyword">id</span>].addv += val;  </span><br><span class="line">        tree[<span class="keyword">id</span>].sum += (tree[<span class="keyword">id</span>].r - tree[<span class="keyword">id</span>].l+<span class="number">1</span>)*val;  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pushdown(<span class="keyword">id</span>);  </span><br><span class="line">    ll mid = (tree[<span class="keyword">id</span>].l+tree[<span class="keyword">id</span>].r)&gt;&gt;<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)  </span><br><span class="line">        updateAdd(<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>,l,r,val);  </span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r)  </span><br><span class="line">        updateAdd(<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,val);  </span><br><span class="line">    maintain(<span class="keyword">id</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> query(<span class="keyword">int</span> <span class="keyword">id</span>,ll l,ll r) &#123;  </span><br><span class="line">    <span class="keyword">if</span>(tree[<span class="keyword">id</span>].l &gt;= l &amp;&amp; tree[<span class="keyword">id</span>].r &lt;= r)&#123;  </span><br><span class="line">        anssum += tree[<span class="keyword">id</span>].sum;  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pushdown(<span class="keyword">id</span>);  </span><br><span class="line">    ll mid = (tree[<span class="keyword">id</span>].l + tree[<span class="keyword">id</span>].r)&gt;&gt;<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid)  </span><br><span class="line">        query(<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>,l,r);  </span><br><span class="line">    <span class="keyword">if</span>(mid &lt; r)  </span><br><span class="line">        query(<span class="keyword">id</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);  </span><br><span class="line">    maintain(<span class="keyword">id</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;  </span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;t);  </span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span> ;  </span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;  </span><br><span class="line">        scanf(<span class="string">"%d %d"</span>,&amp;n,&amp;q);  </span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);  </span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">id</span>;  </span><br><span class="line">        ll x,y;  </span><br><span class="line">        ll val;  </span><br><span class="line">        printf(<span class="string">"Case %d:\n"</span>,++kase);  </span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;  </span><br><span class="line">            scanf(<span class="string">"%d"</span>,&amp;<span class="keyword">id</span>);  </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">id</span>==<span class="number">0</span>)&#123;  </span><br><span class="line">                scanf(<span class="string">"%lld %lld %lld"</span>,&amp;x,&amp;y,&amp;val);  </span><br><span class="line">                updateAdd(<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">1</span>,val);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>&#123;  </span><br><span class="line">                scanf(<span class="string">"%lld %lld"</span>,&amp;x,&amp;y);  </span><br><span class="line">                anssum = <span class="number">0</span>;  </span><br><span class="line">                query(<span class="number">1</span>,x+<span class="number">1</span>,y+<span class="number">1</span>);  </span><br><span class="line">                printf(<span class="string">"%lld\n"</span>,anssum);  </span><br><span class="line">            &#125; &#125; &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t &amp; (-t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (t &lt;= n)&#123;</span><br><span class="line">        a[t] += d;</span><br><span class="line">        t = t + lowbit(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        sum += a[t];</span><br><span class="line">        t = t - lowbit(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, k, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    k= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">            insert(i, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, k++);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">"End"</span>)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="string">"Query"</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getSum(y) - getSum(x - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"Add"</span>)</span><br><span class="line">                insert(x, y);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">"Sub"</span>)</span><br><span class="line">                insert(x, -y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="中国剩余定理（孙子定理）"><a href="#中国剩余定理（孙子定理）" class="headerlink" title="中国剩余定理（孙子定理）"></a>中国剩余定理（孙子定理）</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |16/11/06ztx|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> CRT(<span class="built_in">int</span> a[],<span class="built_in">int</span> m[],<span class="built_in">int</span> n)  &#123;    </span><br><span class="line">    <span class="built_in">int</span> M = <span class="number">1</span>;    </span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; i++)    </span><br><span class="line">        M *= m[i];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  &#123;    </span><br><span class="line">        <span class="built_in">int</span> x, y;    </span><br><span class="line">        <span class="built_in">int</span> Mi = M / m[i];    </span><br><span class="line">        extend_Euclid(Mi, m[i], x, y);    </span><br><span class="line">        ans = (ans + Mi * x * a[i]) % M;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) ans += M;    </span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> extend_Euclid(<span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> &amp;x, <span class="built_in">int</span> &amp;y)  &#123;  </span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;  </span><br><span class="line">        x = <span class="number">1</span>;  </span><br><span class="line">        y = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    extend_Euclid(b, a % b, x, y);  </span><br><span class="line">    <span class="built_in">int</span> tmp = x;  </span><br><span class="line">    x = y;  </span><br><span class="line">    y = tmp - (a / b) * y;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div style="text-align:center;color:#ccc;font-size:14px">---------------- The End ----------------</div><div><div id="reward-container"><div></div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Yan 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Yan 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/ACM/" rel="tag"><i class="fa fa-tag"></i> ACM</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/06/01/最短路径/" rel="next" title="最短路径算法"><i class="fa fa-chevron-left"></i> 最短路径算法</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/06/02/并查集+最小生成树/" rel="prev" title="并查集与最小生成树">并查集与最小生成树 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/touxiang2.png" alt="Yan"><p class="site-author-name" itemprop="name">Yan</p><div class="site-description motion-element" itemprop="description">学无止境<br>正是因为不会不懂，才会选择去学习</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">87</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">35</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/weakdouqing/weakdouqing.github.io" title="GitHub &rarr; https://github.com/weakdouqing/weakdouqing.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=UGFkaGFnYmNpYGUQISF_Mz89" title="E-Mail &rarr; http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=UGFkaGFnYmNpYGUQISF_Mz89" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://cndrew.cn/" title="https://cndrew.cn/" rel="noopener" target="_blank">drew</a></li><li class="links-of-blogroll-item"><a href="https://blog.todest.cn/" title="https://blog.todest.cn/" rel="noopener" target="_blank">亦往沧劫</a></li><li class="links-of-blogroll-item"><a href="http://sqdxwz.com/" title="http://sqdxwz.com/" rel="noopener" target="_blank">赴京书生</a></li><li class="links-of-blogroll-item"><a href="http://inkwall233.github.io" title="http://inkwall233.github.io" rel="noopener" target="_blank">城墙墨</a></li><li class="links-of-blogroll-item"><a href="https://me.csdn.net/Acer12138" title="https://me.csdn.net/Acer12138" rel="noopener" target="_blank">shemplle</a></li><li class="links-of-blogroll-item"><a href="https://blogzhy.cn" title="https://blogzhy.cn" rel="noopener" target="_blank">ZHY</a></li><li class="links-of-blogroll-item"><a href="https://www.cnblogs.com/Friends-A/" title="https://www.cnblogs.com/Friends-A/" rel="noopener" target="_blank">执念</a></li><li class="links-of-blogroll-item"><a href="https://blog.csdn.net/hpuer_random" title="https://blog.csdn.net/hpuer_random" rel="noopener" target="_blank">鸿杰</a></li><li class="links-of-blogroll-item"><a href="https://hpumengzhao.github.io/" title="https://hpumengzhao.github.io/" rel="noopener" target="_blank">Codancer</a></li></ul></div><p></p><div class="hitokoto-title"><i class="fa fa-paragraph"></i> <b>每日一句</b></div><div id="hitokoto">:D 获取中...</div><i id="hitofrom">:D 获取中...</i><script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script><script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script><script>fetch("https://v1.hitokoto.cn").then(function(t){return t.json()}).then(function(t){var o=document.getElementById("hitokoto");o.innerText="       "+t.hitokoto;var n=document.getElementById("hitofrom");n.innerText="——"+t.from+" "})["catch"](function(t){console.error(t)})</script></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ACM模板"><span class="nav-number">1.</span> <span class="nav-text">ACM模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#头文件"><span class="nav-number">1.1.</span> <span class="nav-text">头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典"><span class="nav-number">1.2.</span> <span class="nav-text">经典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#埃拉托斯特尼筛法"><span class="nav-number">1.2.1.</span> <span class="nav-text">埃拉托斯特尼筛法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速幂"><span class="nav-number">1.2.2.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大数模拟"><span class="nav-number">1.2.3.</span> <span class="nav-text">大数模拟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD"><span class="nav-number">1.2.4.</span> <span class="nav-text">GCD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCM"><span class="nav-number">1.2.5.</span> <span class="nav-text">LCM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全排列"><span class="nav-number">1.2.6.</span> <span class="nav-text">全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分搜索"><span class="nav-number">1.2.7.</span> <span class="nav-text">二分搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">1.3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集"><span class="nav-number">1.3.1.</span> <span class="nav-text">并查集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图论"><span class="nav-number">1.4.</span> <span class="nav-text">图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树"><span class="nav-number">1.4.1.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#克鲁斯卡尔算法"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">克鲁斯卡尔算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Prim"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Prim</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单源最短路"><span class="nav-number">1.4.2.</span> <span class="nav-text">单源最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Dijkstra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPFA"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">SPFA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Floyd-Warshall"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Floyd-Warshall</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分图"><span class="nav-number">1.4.3.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#染色法"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">染色法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匈牙利算法"><span class="nav-number">1.4.4.</span> <span class="nav-text">匈牙利算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">1.5.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#背包"><span class="nav-number">1.5.1.</span> <span class="nav-text">背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#other"><span class="nav-number">1.5.2.</span> <span class="nav-text">other</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LIS"><span class="nav-number">1.5.3.</span> <span class="nav-text">LIS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCS"><span class="nav-number">1.5.4.</span> <span class="nav-text">LCS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算几何"><span class="nav-number">1.6.</span> <span class="nav-text">计算几何</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向量基本用法"><span class="nav-number">1.6.1.</span> <span class="nav-text">向量基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求多边形面积"><span class="nav-number">1.6.2.</span> <span class="nav-text">求多边形面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断线段相交"><span class="nav-number">1.6.3.</span> <span class="nav-text">判断线段相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求三角形外心"><span class="nav-number">1.6.4.</span> <span class="nav-text">求三角形外心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#极角排序"><span class="nav-number">1.6.5.</span> <span class="nav-text">极角排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">1.7.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kmp"><span class="nav-number">1.7.1.</span> <span class="nav-text">kmp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kmp扩展"><span class="nav-number">1.7.2.</span> <span class="nav-text">kmp扩展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">1.8.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字典树"><span class="nav-number">1.8.1.</span> <span class="nav-text">字典树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AC自动机"><span class="nav-number">1.8.2.</span> <span class="nav-text">AC自动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线段树"><span class="nav-number">1.8.3.</span> <span class="nav-text">线段树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区间更新"><span class="nav-number">1.8.4.</span> <span class="nav-text">区间更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树状数组"><span class="nav-number">1.8.5.</span> <span class="nav-text">树状数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">1.9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中国剩余定理（孙子定理）"><span class="nav-number">1.9.1.</span> <span class="nav-text">中国剩余定理（孙子定理）</span></a></li></ol></li></ol></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Yan</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">720k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">10:55</span></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><br><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共217k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="true"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/schemes/muse.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script><script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!1,notify:!1,appId:"2RhbNgkDwN1cG75P53SEky2Q-MdYXbMMI",appKey:"G8BKIMpqujmgf4j20pa9RyFq",placeholder:"ヾﾉ≧∀≦)o 来呀！吐槽一番吧！",avatar:"mm",meta:guest,pageSize:"10",visitor:!0,lang:"zh-cn"})</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>$(".highlight").not(".gist .highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var i=document.execCommand("copy");i?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" color="0,255,255" opacity="1" zindex="-2" count="105" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="/live2d-widget-master/autoload.js"></script><script type="text/javascript" src="/js/src/clicklove.js"></script></body></html><!-- rebuild by neat -->