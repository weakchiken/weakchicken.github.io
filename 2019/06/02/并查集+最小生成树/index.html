<!-- build time:Sun Jun 09 2019 16:13:00 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="大佬博客：https://blog.csdn.net/qq_40772692/article/details/79667455并查集1234567891011121314故事读完，并查集就会了~~~~~江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋"><meta name="keywords" content="ACM"><meta property="og:type" content="article"><meta property="og:title" content="最短路径算法"><meta property="og:url" content="http://yoursite.com/2019/06/02/并查集+最小生成树/index.html"><meta property="og:site_name" content="Dou Qing"><meta property="og:description" content="大佬博客：https://blog.csdn.net/qq_40772692/article/details/79667455并查集1234567891011121314故事读完，并查集就会了~~~~~江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-06-07T13:40:00.282Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="最短路径算法"><meta name="twitter:description" content="大佬博客：https://blog.csdn.net/qq_40772692/article/details/79667455并查集1234567891011121314故事读完，并查集就会了~~~~~江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋"><link rel="canonical" href="http://yoursite.com/2019/06/02/并查集+最小生成树/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>最短路径算法 | Dou Qing</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Dou Qing</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">确认过眼神，终将遇到对的人~</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/02/并查集+最小生成树/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Yan"><meta itemprop="description" content="学无止境"><meta itemprop="image" content="/images/touxiang2.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Dou Qing"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">最短路径算法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-06-02 10:09:11" itemprop="dateCreated datePublished" datetime="2019-06-02T10:09:11+08:00">2019-06-02</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-06-07 21:40:00" itemprop="dateModified" datetime="2019-06-07T21:40:00+08:00">2019-06-07</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">6.8k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">6 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p>大佬博客：<a href="https://blog.csdn.net/qq_40772692/article/details/79667455" target="_blank" rel="noopener">https://blog.csdn.net/qq_40772692/article/details/79667455</a></p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">故事读完，并查集就会了~~~~~</span><br><span class="line">江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。</span><br><span class="line">但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。</span><br><span class="line">这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，</span><br><span class="line">于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</span><br><span class="line">我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……</span><br><span class="line">两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，</span><br><span class="line">只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。</span><br><span class="line">这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，</span><br><span class="line">我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，</span><br><span class="line">就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，</span><br><span class="line">以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</span><br></pre></td></tr></table></figure><p>下面我们来看并查集的实现。<br>int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。<br>如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。<br>每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//find函数来查找队长</span><br><span class="line">int pre[1000 ];  </span><br><span class="line">int find(int x)                                       //查找根节点  </span><br><span class="line">&#123;   </span><br><span class="line">    int r=x;  </span><br><span class="line">    while ( pre[r] != r )                           //返回根节点 r  </span><br><span class="line">          r=pre[r];  </span><br><span class="line">   </span><br><span class="line">    int i=x , j ;  </span><br><span class="line">    while( i != r )                                   //路径压缩  </span><br><span class="line">    &#123;  </span><br><span class="line">         j = pre[ i ];              // 在改变上级之前用临时变量  j 记录下他的值   </span><br><span class="line">         pre[ i ]= r ;              //把上级改为根节点  </span><br><span class="line">         i=j;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return r ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>路径压缩(有时候在find函数里面可以省略)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。</span><br><span class="line"> 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？”</span><br><span class="line"> 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 </span><br><span class="line"> “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。</span><br><span class="line"> “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 </span><br><span class="line"> 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，</span><br><span class="line"> 以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 </span><br><span class="line"> 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上</span><br><span class="line"> 。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。</span><br></pre></td></tr></table></figure><p></p><p>再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。<br>这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？<br>还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，<br>那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。<br>这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，<br>我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！<br>反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？<br>我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。<br>反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//join函数连接  注意：join函数一般写在find函数下边</span><br><span class="line"></span><br><span class="line">void join(int x,int y)                           //判断x y是否连通，  </span><br><span class="line">                                               //如果已经连通，就不用管了 如果不连通，就把它们所在的连通分支合并起,  </span><br><span class="line">&#123;  </span><br><span class="line">    int fx=find(x),fy=find(y);  </span><br><span class="line">    if(fx!=fy)  </span><br><span class="line">        pre[fx ]=fy;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>1.最小生成树概念：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树（使所有点联通+建立所有边的代价和最小）</p><p>2.最小生成树应用：要在n个城市之间铺设光缆，主要目标是要使这 n 个城市的任意两个之间都可以通信，但铺设光缆的费用很高，<br>且各个城市之间铺设光缆的费用不同，因此另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。</p><h2 id="Prim（普里姆）算法（加点法）"><a href="#Prim（普里姆）算法（加点法）" class="headerlink" title="Prim（普里姆）算法（加点法）"></a>Prim（普里姆）算法（加点法）</h2><p>(1)算法思想：以任意一点为树根出发，集合V是已经确定最短路的点集合，集合U是没有确立最短路的集合。初始时只有树根点在V中。</p><p>每一次循环就代表要修建一条最短路，到达没到达的点（U），我们只能从已经建成的局部最短路点集V中选取V中所有已确定点能到达的所有其他点里面最小的来建设，<br>有点贪心思想，每次选取代价最小的路，逐渐完善点，知道恰好覆盖所有的点。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f</span><br><span class="line"></span><br><span class="line">int G[1000][1000];//邻接矩阵存图</span><br><span class="line">int dis[1000];//存储最小距离（总的集合U里的）</span><br><span class="line"></span><br><span class="line">bool judge[1000];//判断该点是否已经加入最小点集合</span><br><span class="line"></span><br><span class="line">int pre[1000];//记录每个点的前导，用于输出路径</span><br><span class="line">int n,m;</span><br><span class="line">int prim(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int sum=0;//记录总和</span><br><span class="line">    int pos;//记录位置</span><br><span class="line">    int minn;</span><br><span class="line"></span><br><span class="line">    judge[a]=1;</span><br><span class="line">    pos=a;</span><br><span class="line"></span><br><span class="line">    for(int i=1; i&lt;=n-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minn=INF;</span><br><span class="line"></span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!judge[j]&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                pos=j;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        judge[pos]=1;</span><br><span class="line">        sum+=minn;</span><br><span class="line">        cout&lt;&lt;&quot;V&quot;&lt;&lt;pre[pos]&lt;&lt;&quot; -- &quot;&lt;&lt;&quot;V&quot;&lt;&lt;pos&lt;&lt;&quot; is &quot;&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(dis[j]&gt;G[pos][j]&amp;&amp;!judge[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j]=G[pos][j];</span><br><span class="line">                pre[j]=pos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">	</span><br><span class="line">    while(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=1; j&lt;=n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(i==j)</span><br><span class="line">                    G[i][j]=0;</span><br><span class="line">                else</span><br><span class="line">                    G[i][j]=INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(judge,0,sizeof(judge));</span><br><span class="line">        for(int i=0; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int a,b,c;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">            G[a][b]=G[b][a]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        int s;</span><br><span class="line"></span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i]=s;</span><br><span class="line">            dis[i]=G[s][i];</span><br><span class="line">        &#125;</span><br><span class="line">        int k=prim(s);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="克鲁斯克尔（Kruskal）算法（加边法）"><a href="#克鲁斯克尔（Kruskal）算法（加边法）" class="headerlink" title="克鲁斯克尔（Kruskal）算法（加边法）"></a>克鲁斯克尔（Kruskal）算法（加边法）</h2><p>算法思想：最小生成树最后一定是只有n-1条边！所以我们只要选取最小的n-1条边来吧n个点联通起来即可，但是注意不能产生回路，于是我们就用到了并查集！</p><p>记Graph中有v个顶点，e条边；<br>新建图Graphnew，Graphnew中拥有原图中的v个顶点，但没有边;<br>将原图Graph中所有e条边按权值从小到大排序；<br>循环：从权值最小的边开始，判断并添加每条边，直至添加了n-1条边：<br>注意：加边的条件是不产生回路！即要连接的两定点不在一个集合里面！（并查集判断是否可以加边）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int s,e,v;</span><br><span class="line"></span><br><span class="line">    bool operator &lt;(const Node &amp;n)const&#123;</span><br><span class="line">        return v&lt;n.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node node[1000];</span><br><span class="line">int pre[1000];</span><br><span class="line">int ranked[1000];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line">int finded(int v)//查找</span><br><span class="line">&#123;</span><br><span class="line">	int i=v;</span><br><span class="line"></span><br><span class="line">    while(i!=pre[i])//return pre[v]=v?v:pre[v]=find(pre[v]);//递归</span><br><span class="line">        i=pre[i];</span><br><span class="line"></span><br><span class="line">    int j;</span><br><span class="line">    while(v!=i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        j=pre[v];</span><br><span class="line">        pre[v]=i;</span><br><span class="line"></span><br><span class="line">        v=j;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">void join(int a,int b)//合并</span><br><span class="line">&#123;</span><br><span class="line">    int fx=finded(a);</span><br><span class="line">    int fy=finded(b);</span><br><span class="line">    if(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ranked[fx]&lt;ranked[fy])</span><br><span class="line">        &#123;</span><br><span class="line">            pre[fx]=fy;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pre[fy]=fx;</span><br><span class="line">            if(ranked[fx]==ranked[fy])</span><br><span class="line">                ranked[fx]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Kruskal()</span><br><span class="line">&#123;</span><br><span class="line">    sort(node,node+m);</span><br><span class="line">    int sizen=0;</span><br><span class="line">    int sum=0;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m&amp;&amp;sizen!=n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(finded(node[i].s)!=finded(node[i].e))</span><br><span class="line">        &#123;</span><br><span class="line">            join(node[i].s,node[i].e);</span><br><span class="line">            sum+=node[i].v;</span><br><span class="line">            sizen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sizen&lt;n-1)return -1;</span><br><span class="line"></span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	</span><br><span class="line">    memset(ranked,0,sizeof(ranked));</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;node[i].s&gt;&gt;node[i].e&gt;&gt;node[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    int k=Kruskal();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div style="text-align:center;color:#ccc;font-size:14px">---------------- The End ----------------</div><div><div id="reward-container"><div></div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Yan 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Yan 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/ACM/" rel="tag"># ACM</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/06/02/ACM模板/" rel="next" title="ACM模板"><i class="fa fa-chevron-left"></i> ACM模板</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/06/02/动态规划/" rel="prev" title="动态规划算法(DP)">动态规划算法(DP) <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDIxMi8yMDc0NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/touxiang2.png" alt="Yan"><p class="site-author-name" itemprop="name">Yan</p><div class="site-description motion-element" itemprop="description">学无止境</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://cndrew.cn/" title="https://cndrew.cn/" rel="noopener" target="_blank">drew</a></li><li class="links-of-blogroll-item"><a href="https://blog.todest.cn/" title="https://blog.todest.cn/" rel="noopener" target="_blank">亦往沧劫</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#并查集"><span class="nav-number">1.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小生成树"><span class="nav-number">2.</span> <span class="nav-text">最小生成树</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#Prim（普里姆）算法（加点法）"><span class="nav-number"></span> <span class="nav-text">Prim（普里姆）算法（加点法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#克鲁斯克尔（Kruskal）算法（加边法）"><span class="nav-number"></span> <span class="nav-text">克鲁斯克尔（Kruskal）算法（加边法）</span></a></li></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Yan</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">65k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">59 分钟</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div><br><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数:<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共20.7k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.7" zindex="-2" count="99" src="true"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/affix.js?v=7.1.1"></script><script src="/js/schemes/pisces.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script><script>window.livereOptions={refer:"2019/06/02/并查集+最小生成树/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script></body></html><!-- rebuild by neat -->