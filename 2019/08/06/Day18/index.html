<!-- build time:Wed Aug 07 2019 23:10:04 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><meta name="theme-color" content="#222"><style>.pace .pace-progress{background:#1E92FB;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1"><link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.1.1",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!0,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="Day18今天讲的是最短路算法补题OJ链接"><meta name="keywords" content="ACM,Algorithm,算法集训,图论"><meta property="og:type" content="article"><meta property="og:title" content="Day18"><meta property="og:url" content="http://yoursite.com/2019/08/06/Day18/index.html"><meta property="og:site_name" content="Dou Qing"><meta property="og:description" content="Day18今天讲的是最短路算法补题OJ链接"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2019-08-07T14:30:49.761Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Day18"><meta name="twitter:description" content="Day18今天讲的是最短路算法补题OJ链接"><link rel="alternate" href="/atom.xml" title="Dou Qing" type="application/atom+xml"><link rel="canonical" href="http://yoursite.com/2019/08/06/Day18/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Day18 | Dou Qing</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Dou Qing</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">~人间有万紫千红~<br>~唯你是我情之所钟~</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/Day18/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Yan"><meta itemprop="description" content="学无止境 <br> 正是因为不会不懂，才会选择去学习"><meta itemprop="image" content="/images/touxiang2.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Dou Qing"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Day18</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-06T00:00:00+08:00">2019-08-06</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-07 22:30:49" itemprop="dateModified" datetime="2019-08-07T22:30:49+08:00">2019-08-07</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ACM/集训/" itemprop="url" rel="index"><span itemprop="name">集训</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">24k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">22 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Day18"><a href="#Day18" class="headerlink" title="Day18"></a>Day18</h1><p>今天讲的是最短路算法<br><code>补题</code><br><a href="https://vjudge.net/contest/317592#overview" target="_blank" rel="noopener">OJ链接</a><br><a id="more"></a></p><blockquote><p>提醒自己一下，因为今天有事没有写完这些题目，所以大部分的题解和代码都是在网上找到的，希望以后自己可以把这部分题补上</p></blockquote><h2 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h2><p>详情链接-&gt;<a href="https://cdreamer.cn/2019/06/01/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" target="_blank" rel="noopener">传送</a></p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>Description:<br>在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t-shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？</p><p><code>Input</code><br>输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;=100，M&lt;=10000），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（1&lt;=A,B&lt;=N,1&lt;=C&lt;=1000）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。<br>输入保证至少存在1条商店到赛场的路线。<br><code>Output</code><br>对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2 1</span><br><span class="line">1 2 3</span><br><span class="line">3 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">0 0</span><br><span class="line">Sample Output</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p></p><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int mod = 1e9;</span><br><span class="line">const int maxx = 1e3;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int map[maxx][maxx];</span><br><span class="line">int dj(int x, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int p;</span><br><span class="line">	for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">		dis[i] = map[1][i];</span><br><span class="line">	memset(vis, 0, sizeof vis);</span><br><span class="line">	vis[x] = 1;</span><br><span class="line">	for(int i = 1; i &lt;= n ; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		int minn = INF;</span><br><span class="line">		for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">			&#123;</span><br><span class="line">				minn = dis[j];</span><br><span class="line">				p = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[p] = 1;</span><br><span class="line">		for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(!vis[j] &amp;&amp; dis[p] + map[p][j] &lt; dis[j])</span><br><span class="line">				dis[j] = dis[p] + map[p][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, c;</span><br><span class="line">	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		if(n == 0 &amp;&amp; m == 0) break; </span><br><span class="line">		for(int i = 1; i &lt;= n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int j = 1; j &lt;= n; j ++)</span><br><span class="line">			&#123;</span><br><span class="line">				map[i][j] = INF;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		memset(vis, 0, sizeof vis);</span><br><span class="line">		for(int i = 1; i &lt;= m; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">			if(map[a][b] &gt; c)</span><br><span class="line">				map[a][b] = map[b][a] = c;</span><br><span class="line">		&#125;</span><br><span class="line">		dj(1, n);</span><br><span class="line">		cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Frogger"><a href="#Frogger" class="headerlink" title="Frogger"></a>Frogger</h2><p>Description:<br>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.<br>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.<br>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.<br>The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.</p><p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.<br><code>Input</code><br>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n.<br><code>Output</code><br>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">0 0</span><br><span class="line">3 4</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">17 4</span><br><span class="line">19 4</span><br><span class="line">18 5</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">Scenario #1</span><br><span class="line">Frog Distance = 5.000</span><br><span class="line"></span><br><span class="line">Scenario #2</span><br><span class="line">Frog Distance = 1.414</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">//Floyd解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for(int k=1; k&lt;=n; k++)</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=min(map[i][j],max(map[i][k],map[k][j]));//许多通路中最长边中的最小边</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        floyd();</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,map[1][2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//dijkstra解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">double dis[maxnum];</span><br><span class="line">int vis[maxnum];</span><br><span class="line">void dj(int s)</span><br><span class="line">&#123;</span><br><span class="line">    mem(vis,0);</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;//这里最好别用memset</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minn=inf,k;</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            if(vis[j]==0&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                k=j;</span><br><span class="line">                minn=dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        vis[k]=1;</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            dis[j]=min(dis[j],max(dis[k],map[k][j]));//dis[j]为从一号石头到第j号石头所有通路中最长边中的最小边</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        dj(1);</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,dis[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//SPFA解法</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define mem(a,b) memset(a,b,sizeof(a))</span><br><span class="line">#define maxnum 300</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">using namespace std;</span><br><span class="line">int x[maxnum],y[maxnum],n;</span><br><span class="line">double map[maxnum][maxnum];</span><br><span class="line">double dis[maxnum];</span><br><span class="line">int vis[maxnum];</span><br><span class="line">void spfa()</span><br><span class="line">&#123;</span><br><span class="line">    queue&lt;int&gt;q;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    dis[1]=0;</span><br><span class="line">    for(int i=1; i&lt;=n; i++)</span><br><span class="line">        vis[i]=0;</span><br><span class="line">    vis[1]=1;</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int k=q.front();</span><br><span class="line">        vis[k]=0;</span><br><span class="line">        q.pop();</span><br><span class="line">        for(int j=1; j&lt;=n; j++)</span><br><span class="line">            if(max(dis[k],map[k][j])&lt;dis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j]=max(dis[k],map[k][j]);</span><br><span class="line">                if(vis[j]==0)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(j);</span><br><span class="line">                    vis[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int q=1;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        mem(map,0);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">            for(int j=i+1; j&lt;=n; j++)</span><br><span class="line">                map[i][j]=map[j][i]=sqrt(double(x[i]-x[j])*(x[i]-x[j])+double(y[i]-y[j])*(y[i]-y[j]));</span><br><span class="line">        spfa();</span><br><span class="line">        printf(&quot;Scenario #%d\nFrog Distance = %.3lf\n\n&quot;,q++,dis[2]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Stockbroker-Grapevine"><a href="#Stockbroker-Grapevine" class="headerlink" title="Stockbroker Grapevine"></a>Stockbroker Grapevine</h2><p>Description:<br>Stockbrokers are known to overreact to rumours. You have been contracted to develop a method of spreading disinformation amongst the stockbrokers to give your employer the tactical edge in the stock market. For maximum effect, you have to spread the rumours in the fastest possible way.</p><p>Unfortunately for you, stockbrokers only trust information coming from their “Trusted sources” This means you have to take into account the structure of their contacts when starting a rumour. It takes a certain amount of time for a specific stockbroker to pass the rumour on to each of his colleagues. Your task will be to write a program that tells you which stockbroker to choose as your starting point for the rumour, as well as the time it will take for the rumour to spread throughout the stockbroker community. This duration is measured as the time needed for the last person to receive the information.<br><code>Input</code><br>Your program will input data for different sets of stockbrokers. Each set starts with a line with the number of stockbrokers. Following this is a line for each stockbroker which contains the number of people who they have contact with, who these people are, and the time taken for them to pass the message to each person. The format of each stockbroker line is as follows: The line starts with the number of contacts (n), followed by n pairs of integers, one pair for each contact. Each pair lists first a number referring to the contact (e.g. a ‘1’ means person number one in the set), followed by the time in minutes taken to pass a message to that person. There are no special punctuation symbols or spacing rules.</p><p>Each person is numbered 1 through to the number of stockbrokers. The time taken to pass the message on will be between 1 and 10 minutes (inclusive), and the number of contacts will range between 0 and one less than the number of stockbrokers. The number of stockbrokers will range from 1 to 100. The input is terminated by a set of stockbrokers containing 0 (zero) people.</p><p><code>Output</code><br>For each set of data, your program must output a single line containing the person who results in the fastest message transmission, and how long before the last person will receive any given message after you give it to this person, measured in integer minutes.<br>It is possible that your program will receive a network of connections that excludes some persons, i.e. some people may be unreachable. If your program detects such a broken network, simply output the message “disjoint”. Note that the time taken to pass the message from person A to person B is not necessarily the same as the time taken to pass it from B to A, if such transmission is possible at all.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">3</span><br><span class="line">2 2 4 3 5</span><br><span class="line">2 1 2 3 6</span><br><span class="line">2 1 2 2 2</span><br><span class="line">5</span><br><span class="line">3 4 4 2 8 5 3</span><br><span class="line">1 5 8</span><br><span class="line">4 1 6 4 10 2 7 5 2</span><br><span class="line">0</span><br><span class="line">2 2 5 1 5</span><br><span class="line">0</span><br><span class="line">Sample Output</span><br><span class="line">3 2</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">经典水题floyd这道题重点在于找到从某一个源点出发的最短路</span><br><span class="line">怎么找？可以找到从一个源点出发最长的时间，即是传递结束，</span><br><span class="line">然后找最长的最短。当然会出现有些人没有传递到，但是这道</span><br><span class="line">题的bug在于此，不会出现disjoint的情况。</span><br><span class="line">*/</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define inf 20</span><br><span class="line">#define M 210</span><br><span class="line"> </span><br><span class="line">int dist[M][M];</span><br><span class="line">int n;</span><br><span class="line"> </span><br><span class="line">void floyd()</span><br><span class="line">&#123;</span><br><span class="line">    for(int k = 1;k &lt;= n; k++)</span><br><span class="line">        for(int i = 1;i &lt;= n; i++)</span><br><span class="line">            for(int j = 1;j &lt;= n; j++)</span><br><span class="line">                if(i != j &amp;&amp; dist[i][j] &gt; dist[i][k] + dist[k][j])</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line"> </span><br><span class="line">    int minlength = inf;</span><br><span class="line">    int maxlength,pos;</span><br><span class="line">    for(int i = 1;i &lt;= n; i++)&#123;</span><br><span class="line">        maxlength = 0;</span><br><span class="line">        for(int j = 1;j &lt;= n; j++)</span><br><span class="line">            if(i != j &amp;&amp; maxlength &lt; dist[i][j])</span><br><span class="line">                maxlength = dist[i][j];</span><br><span class="line">        if(minlength &gt; maxlength)&#123;</span><br><span class="line">            minlength = maxlength;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;minlength&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        memset(dist,inf,sizeof(dist));</span><br><span class="line"> </span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line"> </span><br><span class="line">        if(!n)</span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        for(int i = 1;i &lt;= n; i++)&#123;</span><br><span class="line">            int n1;</span><br><span class="line">            cin&gt;&gt;n1;</span><br><span class="line">            for(int j = 1;j &lt;= n1; j++)&#123;</span><br><span class="line">                int p,t;</span><br><span class="line">                cin&gt;&gt;p&gt;&gt;t;</span><br><span class="line">                dist[i][p] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        floyd();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Invitation-Cards"><a href="#Invitation-Cards" class="headerlink" title="Invitation Cards"></a>Invitation Cards</h2><p>Description:<br>In the age of television, not many people attend theater performances. Antique Comedians of Malidinesia are aware of this fact. They want to propagate theater and, most of all, Antique Comedies. They have printed invitation cards with all the necessary information and with the programme. A lot of students were hired to distribute these invitations among the people. Each student volunteer has assigned exactly one bus stop and he or she stays there the whole day and gives invitation to people travelling by bus. A special course was taken where students learned how to influence people and what is the difference between influencing and robbery.</p><p>The transport system is very special: all lines are unidirectional and connect exactly two stops. Buses leave the originating stop with passangers each half an hour. After reaching the destination stop they return empty to the originating stop, where they wait until the next full half an hour, e.g. X:00 or X:30, where ‘X’ denotes the hour. The fee for transport between two stops is given by special tables and is payable on the spot. The lines are planned in such a way, that each round trip (i.e. a journey starting and finishing at the same stop) passes through a Central Checkpoint Stop (CCS) where each passenger has to pass a thorough check including body scan.</p><p>All the ACM student members leave the CCS each morning. Each volunteer is to move to one predetermined stop to invite passengers. There are as many volunteers as stops. At the end of the day, all students travel back to CCS. You are to write a computer program that helps ACM to minimize the amount of money to pay every day for the transport of their employees.<br><code>Input</code><br>The input consists of N cases. The first line of the input contains only positive integer N. Then follow the cases. Each case begins with a line containing exactly two integers P and Q, 1 &lt;= P,Q &lt;= 1000000. P is the number of stops including CCS and Q the number of bus lines. Then there are Q lines, each describing one bus line. Each of the lines contains exactly three numbers - the originating stop, the destination stop and the price. The CCS is designated by number 1. Prices are positive integers the sum of which is smaller than 1000000000. You can also assume it is always possible to get from any stop to any other stop.<br><code>Output</code><br>For each case, print one line containing the minimum amount of money to be paid each day by ACM for the travel costs of its volunteers.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 2 13</span><br><span class="line">2 1 33</span><br><span class="line">4 6</span><br><span class="line">1 2 10</span><br><span class="line">2 1 60</span><br><span class="line">1 3 20</span><br><span class="line">3 4 10</span><br><span class="line">2 4 5</span><br><span class="line">4 1 50</span><br><span class="line">Sample Output</span><br><span class="line">46</span><br><span class="line">210</span><br></pre></td></tr></table></figure><p><code>题意</code><br>求1到各个顶点和各个定点到1的路线总长最短。有向图。<br>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//各个点到1顶点的总和最短可以反向建图来实现。而不是反复最短路</span><br><span class="line">//因为有1000000的顶点所以采用了邻接表。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1000000+100;</span><br><span class="line">const int inf=0x3f3f3f3f;</span><br><span class="line">int b[N],w[N],e[N];</span><br><span class="line">int fir[N],nxt[N];</span><br><span class="line">int n,m;</span><br><span class="line">int dis[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void  spfa(int &amp;ans)</span><br><span class="line">&#123;</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=i==1?0:inf;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[1]=0;vis[1]=1;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    while(!q.empty()) q.pop();</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int now=q.front();</span><br><span class="line">        int k=fir[now];</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[now]=0;</span><br><span class="line">        while(k!=-1)</span><br><span class="line">        &#123;</span><br><span class="line">            if(dis[e[k]]&gt;dis[b[k]]+w[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[e[k]]=dis[b[k]]+w[k];</span><br><span class="line">                if(!vis[e[k]]) q.push(e[k]),vis[e[k]]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            k=nxt[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">        for(int i=1; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fir[i]=-1;</span><br><span class="line">            nxt[i]=-1;</span><br><span class="line">            dis[i]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;b[i],&amp;e[i],&amp;w[i]);</span><br><span class="line">            nxt[i]=fir[b[i]];</span><br><span class="line">            fir[b[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(ans);</span><br><span class="line">        memset(nxt,-1,sizeof nxt);</span><br><span class="line">        memset(fir,-1,sizeof fir);</span><br><span class="line">        for(int i=1; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int t=b[i];</span><br><span class="line">            b[i]=e[i];</span><br><span class="line">            e[i]=t;</span><br><span class="line">            nxt[i]=fir[b[i]];</span><br><span class="line">            fir[b[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        spfa(ans);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Skiing"><a href="#Skiing" class="headerlink" title="Skiing"></a>Skiing</h2><p>Description:<br>Bessie and the rest of Farmer John’s cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 &lt;= R &lt;= 100) by C (1 &lt;= C &lt;= 100) grid of elevations E (-25 &lt;= E &lt;= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.</p><p>Bessie starts out travelling at a initial speed V (1 &lt;= V &lt;= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.</p><p>Find the both smallest amount of time it will take Bessie to join her cow friends.<br><code>Input</code></p><ul><li><p>Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie’s initial velocity and the number of rows and columns in the grid.</p></li><li><p>Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid.<br><code>Output</code><br>A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Sample Input</span><br><span class="line">1 3 3</span><br><span class="line">1 5 3</span><br><span class="line">6 3 5</span><br><span class="line">2 4 3</span><br><span class="line">Sample Output</span><br><span class="line">29.00</span><br><span class="line">Hint</span><br><span class="line">Bessie&apos;s best route is: </span><br><span class="line">Start at 1,1 time 0 speed 1 </span><br><span class="line">East to 1,2 time 1 speed 1/16 </span><br><span class="line">South to 2,2 time 17 speed 1/4 </span><br><span class="line">South to 3,2 time 21 speed 1/8 </span><br><span class="line">East to 3,3 time 29 speed 1/4</span><br></pre></td></tr></table></figure><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">//dijkstra解法</span><br><span class="line">/*dijkstra解法题解：每个节点的耗时就是从左上角（1，1）点到（i,j)点的2^高度差,而速度是其倒数，需输出的啦~，先把节点存储成耗时的静态邻接表，然后利用dijkstra的堆优化进行（nlogn)的求解。*/</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define eps 1e-8</span><br><span class="line">#define maxn 111</span><br><span class="line">#define inf 999999999999</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">struct node&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	double dis;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const&#123;</span><br><span class="line">		return dis&gt;a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int dic[4][2]=&#123;0,1,1,0,-1,0,0,-1&#125;;</span><br><span class="line">int at[maxn][maxn];</span><br><span class="line">double mp[maxn][maxn];</span><br><span class="line">double dis[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int v,r,c;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=1;i&lt;=r;i++)</span><br><span class="line">		for(int j=1;j&lt;=c;j++)</span><br><span class="line">			dis[i][j]=inf;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">&#125;</span><br><span class="line">double get_cost(int h)</span><br><span class="line">&#123;</span><br><span class="line">	return v*1.0*pow(2*1.0,at[1][1]-h);</span><br><span class="line">&#125;</span><br><span class="line">bool ok(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	if(x&gt;0&amp;&amp;x&lt;=r&amp;&amp;y&gt;0&amp;&amp;y&lt;=c)</span><br><span class="line">		return true;</span><br><span class="line">	else </span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	node now,next;</span><br><span class="line">	now.x=1;</span><br><span class="line">	now.y=1;</span><br><span class="line">	now.dis=0;</span><br><span class="line">	dis[1][1]=0;</span><br><span class="line">	q.push(now);</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		now=q.top();</span><br><span class="line">		q.pop();</span><br><span class="line">		if(vis[now.x][now.y]) continue;</span><br><span class="line">		vis[now.x][now.y]=true;</span><br><span class="line">		if(now.x==r&amp;&amp;now.y==c)</span><br><span class="line">			break;</span><br><span class="line">		int x;int y;</span><br><span class="line">		for(int i=0;i&lt;4;i++)	</span><br><span class="line">		&#123;</span><br><span class="line">			x=now.x+dic[i][0];</span><br><span class="line">			y=now.y+dic[i][1];</span><br><span class="line">			if(!ok(x,y)) continue;</span><br><span class="line">			if(!vis[x][y]&amp;&amp;dis[x][y]&gt;now.dis+1.0/mp[now.x][now.y])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[x][y]=now.dis+1.0/mp[now.x][now.y];</span><br><span class="line">				next.x=x;</span><br><span class="line">				next.y=y;</span><br><span class="line">				next.dis=dis[x][y];</span><br><span class="line">				q.push(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;	</span><br><span class="line">	scanf(&quot;%d%d%d&quot;,&amp;v,&amp;r,&amp;c);</span><br><span class="line">	init();</span><br><span class="line">	//printf(&quot;%lf\n&quot;,dis[1][1]);</span><br><span class="line">	for(int i=1;i&lt;=r;i++)</span><br><span class="line">		for(int j=1;j&lt;=c;j++)</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;at[i][j]);</span><br><span class="line">	for(int i=1;i&lt;=r;i++)</span><br><span class="line">		for(int j=1;j&lt;=c;j++)</span><br><span class="line">			mp[i][j]=get_cost(at[i][j]);</span><br><span class="line">	dijkstra();</span><br><span class="line">	printf(&quot;%.2f\n&quot;,dis[r][c]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//SPFA解法</span><br><span class="line">/*题解：可以看出每个点的速度都与第一个点有关，因为V*2^(A-B)*2^(B-C)它就等于V*2^(A-C)，所以每个点的速度都可以用第一个点算出来。然后把每个点对应到下一个点的时间存到这个点的位置上。*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cfloat&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const double inf = 0x3f3f3f3f;</span><br><span class="line">const int MAX = 200;</span><br><span class="line">int v,r,c;</span><br><span class="line">int vis[MAX][MAX];</span><br><span class="line">double mp[MAX][MAX],t[MAX][MAX],dis[MAX][MAX];// mp要用double 待会用到pow函数要不然报错</span><br><span class="line">int mv[4][2]=&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">struct hh&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">void spfa()&#123;</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	for(int i=1;i&lt;=r;i++)&#123;// 赋一个很大的值给double类型的数组，要用这种形式，要不然用下面那种形式，不对。</span><br><span class="line">		for(int j=1;j&lt;=c;j++)&#123;</span><br><span class="line">			dis[i][j] = DBL_MAX;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//memset(dis,inf,sizeof(dis));		</span><br><span class="line">	queue&lt;hh&gt; q;</span><br><span class="line">	hh tmp,nex;</span><br><span class="line">	int xx,yy;</span><br><span class="line">	tmp.x=1;</span><br><span class="line">	tmp.y=1;</span><br><span class="line">	dis[1][1]=0;//注意赋值为0，dis数组表示别的点到这个点需要的时间，不包括这个点到别的点的时间，也就是不包括这个点所存的时间</span><br><span class="line">	q.push(tmp);</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		tmp=q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		vis[tmp.x][tmp.y]=0;// 注意要赋值0，要不然会错，因为这个点我们可能需要重新走</span><br><span class="line">		for (int i = 0; i &lt; 4;i++)&#123;</span><br><span class="line">			xx=tmp.x+mv[i][0];</span><br><span class="line">			yy=tmp.y+mv[i][1];</span><br><span class="line">			if(xx&lt;1|yy&lt;1||xx&gt;r||yy&gt;c) continue;</span><br><span class="line">			if(dis[xx][yy]&gt;t[tmp.x][tmp.y]+dis[tmp.x][tmp.y])&#123;</span><br><span class="line">				dis[xx][yy]=t[tmp.x][tmp.y]+dis[tmp.x][tmp.y];</span><br><span class="line">				if(!vis[xx][yy])&#123;</span><br><span class="line">					vis[xx][yy]=1;</span><br><span class="line">					nex.x=xx;</span><br><span class="line">					nex.y=yy;</span><br><span class="line">					q.push(nex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin &gt;&gt; v &gt;&gt; r &gt;&gt; c;</span><br><span class="line">	for (int i = 1; i &lt;= r;i++)&#123;</span><br><span class="line">		for (int j = 1; j &lt;= c;j++)&#123;</span><br><span class="line">			cin &gt;&gt; mp[i][j];</span><br><span class="line">			t[i][j]=1/(v*(pow(2,mp[1][1]-mp[i][j])));//计算每个点到下一个点所需要的时间，存到这个点上</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	spfa();</span><br><span class="line">	printf(&quot;%.2lf\n&quot;,dis[r][c]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Cow-Hurdles"><a href="#Cow-Hurdles" class="headerlink" title="Cow Hurdles"></a>Cow Hurdles</h2><p>Description:<br>Farmer John wants the cows to prepare for the county jumping competition, so Bessie and the gang are practicing jumping over hurdles. They are getting tired, though, so they want to be able to use as little energy as possible to jump over the hurdles.</p><p>Obviously, it is not very difficult for a cow to jump over several very short hurdles, but one tall hurdle can be very stressful. Thus, the cows are only concerned about the height of the tallest hurdle they have to jump over.</p><p>The cows’ practice room has N (1 ≤ N ≤ 300) stations, conveniently labeled 1..N. A set of M (1 ≤ M ≤ 25,000) one-way paths connects pairs of stations; the paths are also conveniently labeled 1..M. Path i travels from station Si to station Ei and contains exactly one hurdle of height Hi (1 ≤ Hi ≤ 1,000,000). Cows must jump hurdles in any path they traverse.</p><p>The cows have T (1 ≤ T ≤ 40,000) tasks to complete. Task i comprises two distinct numbers, Ai and Bi (1 ≤ Ai ≤ N; 1 ≤ Bi ≤ N), which connote that a cow has to travel from station Ai to station Bi (by traversing over one or more paths over some route). The cows want to take a path the minimizes the height of the tallest hurdle they jump over when traveling from Ai to Bi . Your job is to write a program that determines the path whose tallest hurdle is smallest and report that height.</p><p><code>Input</code></p><ul><li>Line 1: Three space-separated integers: N, M, and T</li><li>Lines 2..M+1: Line i+1 contains three space-separated integers: Si , Ei , and Hi</li><li>Lines M+2..M+T+1: Line i+M+1 contains two space-separated integers that describe task i: Ai and Bi</li></ul><p><code>Output</code></p><ul><li>Lines 1..T: Line i contains the result for task i and tells the smallest possible maximum height necessary to travel between the stations. Output -1 if it is impossible to travel between the two stations.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ample Input</span><br><span class="line">5 6 3</span><br><span class="line">1 2 12</span><br><span class="line">3 2 8</span><br><span class="line">1 3 5</span><br><span class="line">2 5 3</span><br><span class="line">3 4 4</span><br><span class="line">2 4 8</span><br><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">5 1</span><br><span class="line">Sample Output</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><blockquote><p>题意：有一头牛，要进行跳木桩训练，已知有n个木桩，而且知道m对木桩之间的高度差。但是它很懒，它想尽可能的跳最小的高度就完成从任意一个木桩到任意一个木桩的跳跃，给m对点，问是否存在最小的跳跃高度使得其能够完成跳跃，如果有就输出最小高度；否则输出-1。</p></blockquote><blockquote><p>解析：对于每一次询问，求的是每条路径上边权值的最大值（该路径所经过的相邻两木桩之间的差值的最大值），然后取其中的最小值即可。因为只要能跳过这个高度差最大的，高度差小的当然能跳过去了。由于是求任意两木桩之间的所有路径上最大高度差值的最小值，所以我们可以用Floyd算法，对其进行处理，处理之后得到的最终结果即为所求了。</p></blockquote><p>code:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 123456789</span><br><span class="line">int a[302][302];        //最大高度的最小值矩阵</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, t;</span><br><span class="line">    int x, y, w;</span><br><span class="line">    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t)!=EOF)&#123;</span><br><span class="line">        for(int i=1; i&lt;=n; i++)                 //初始化</span><br><span class="line">            for(int j=1; j&lt;=n; j++) a[i][j] = i==j ? 0 : INF;</span><br><span class="line">        for(int i=1; i&lt;=m; i++)&#123;                //读入高度差</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            a[x][y] = min(a[x][y], w);          //更新最大高度差</span><br><span class="line">        &#125;</span><br><span class="line">        for(int k=1; k&lt;=n; k++)                 //Floyd</span><br><span class="line">            for(int i=1; i&lt;=n; i++)</span><br><span class="line">                for(int j=1; j&lt;=n; j++)&#123;</span><br><span class="line">                    a[i][j] = min(a[i][j], max(a[i][k], a[k][j]));      </span><br><span class="line">                &#125;</span><br><span class="line">        for(int i=1; i&lt;=t; i++)&#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">            printf(&quot;%d\n&quot;, a[x][y]==INF ? -1 : a[x][y]);       //输出，如果还是INF，那就代表不可达，两者时之间没有路径满足要求</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></div><div style="text-align:center;color:#ccc;font-size:14px">---------------- The End ----------------</div><div><div id="reward-container"><div></div><button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Yan 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Yan 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/ACM/" rel="tag"><i class="fa fa-tag"></i> ACM</a> <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a> <a href="/tags/算法集训/" rel="tag"><i class="fa fa-tag"></i> 算法集训</a> <a href="/tags/图论/" rel="tag"><i class="fa fa-tag"></i> 图论</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/08/05/Day17/" rel="next" title="Day17"><i class="fa fa-chevron-left"></i> Day17</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/08/07/Day19/" rel="prev" title="Day19">Day19 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NDIxMi8yMDc0NQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/touxiang2.png" alt="Yan"><p class="site-author-name" itemprop="name">Yan</p><div class="site-description motion-element" itemprop="description">学无止境<br>正是因为不会不懂，才会选择去学习</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">24</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/weakdouqing/weakdouqing.github.io" title="GitHub &rarr; https://github.com/weakdouqing/weakdouqing.github.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=UGFkaGFnYmNpYGUQISF_Mz89" title="E-Mail &rarr; http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=UGFkaGFnYmNpYGUQISF_Mz89" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://cndrew.cn/" title="https://cndrew.cn/" rel="noopener" target="_blank">drew</a></li><li class="links-of-blogroll-item"><a href="https://blog.todest.cn/" title="https://blog.todest.cn/" rel="noopener" target="_blank">亦往沧劫</a></li><li class="links-of-blogroll-item"><a href="http://www.sqdxwz.com/" title="http://www.sqdxwz.com/" rel="noopener" target="_blank">赴京书生</a></li><li class="links-of-blogroll-item"><a href="http://inkwall233.github.io" title="http://inkwall233.github.io" rel="noopener" target="_blank">城墙墨</a></li><li class="links-of-blogroll-item"><a href="https://me.csdn.net/Acer12138" title="https://me.csdn.net/Acer12138" rel="noopener" target="_blank">shemplle</a></li><li class="links-of-blogroll-item"><a href="https://blogzhy.cn" title="https://blogzhy.cn" rel="noopener" target="_blank">ZHY</a></li></ul></div><p></p><div id="hitokoto">:D 获取中...</div><i id="hitofrom">:D 获取中...</i><script src="https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js"></script><script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js"></script><script>fetch("https://v1.hitokoto.cn").then(function(t){return t.json()}).then(function(t){var o=document.getElementById("hitokoto");o.innerText="       "+t.hitokoto;var n=document.getElementById("hitofrom");n.innerText="——"+t.from+" "})["catch"](function(t){console.error(t)})</script></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Day18"><span class="nav-number">1.</span> <span class="nav-text">Day18</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路算法"><span class="nav-number">1.1.</span> <span class="nav-text">最短路算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路"><span class="nav-number">1.2.</span> <span class="nav-text">最短路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Frogger"><span class="nav-number">1.3.</span> <span class="nav-text">Frogger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stockbroker-Grapevine"><span class="nav-number">1.4.</span> <span class="nav-text">Stockbroker Grapevine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Invitation-Cards"><span class="nav-number">1.5.</span> <span class="nav-text">Invitation Cards</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Skiing"><span class="nav-number">1.6.</span> <span class="nav-text">Skiing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cow-Hurdles"><span class="nav-number">1.7.</span> <span class="nav-text">Cow Hurdles</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Yan</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">453k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:52</span></div><div class="powered-by"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><br><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共144.6k字</span></div></div></footer></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="true"></script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.1"></script><script src="/js/motion.js?v=7.1.1"></script><script src="/js/affix.js?v=7.1.1"></script><script src="/js/schemes/pisces.js?v=7.1.1"></script><script src="/js/scrollspy.js?v=7.1.1"></script><script src="/js/post-details.js?v=7.1.1"></script><script src="/js/next-boot.js?v=7.1.1"></script><script>window.livereOptions={refer:"2019/08/06/Day18/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script>$(".highlight").not(".gist .highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code").find(".line").map(function(t,e){return $(e).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=e,document.body.appendChild(n),n.select(),n.setSelectionRange(0,e.length),n.readOnly=!1;var i=document.execCommand("copy");i?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})</script><script type="text/javascript" color="0,255,255" opacity="1" zindex="-2" count="105" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script src="/live2d-widget-master/autoload.js"></script><script type="text/javascript" src="/js/src/clicklove.js"></script></body></html><!-- rebuild by neat -->